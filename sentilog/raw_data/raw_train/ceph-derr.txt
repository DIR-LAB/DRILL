./auth/Crypto.cc:      lderr(cct) << "ERROR: cct->get_crypto_handler(type=" << t << ") returned NULL" << dendl;
./auth/AuthMethodList.cc:    lderr(cct) << "WARNING: empty auth protocol list" << dendl;
./auth/AuthMethodList.cc:      lderr(cct) << "WARNING: unknown auth protocol defined: " << *iter << dendl;
./auth/AuthMethodList.cc:    lderr(cct) << "WARNING: no auth protocol defined, use 'cephx' by default" << dendl;
./auth/AuthRegistry.cc:    lderr(cct) << "WARNING: empty auth protocol list" << dendl;
./auth/AuthRegistry.cc:      lderr(cct) << "WARNING: unknown auth protocol defined: " << i << dendl;
./auth/AuthRegistry.cc:    lderr(cct) << "WARNING: no auth protocol defined" << dendl;
./auth/AuthRegistry.cc:    lderr(cct) << "WARNING: empty auth protocol list" << dendl;
./auth/AuthRegistry.cc:      lderr(cct) << "WARNING: unknown connection mode " << i << dendl;
./auth/AuthRegistry.cc:    lderr(cct) << "WARNING: no connection modes defined" << dendl;
./auth/KeyRing.cc:      lderr(cct) << "failed to decode key '" << conf->key << "'" << dendl;
./auth/KeyRing.cc:      lderr(cct) << err << dendl;
./auth/KeyRing.cc:      lderr(cct) << "failed to decode key '" << k << "'" << dendl;
./auth/KeyRing.cc:    lderr(cct) << "error reading file: " << filename << ": " << err << dendl;
./auth/KeyRing.cc:    lderr(cct) << "error parsing file " << filename << ": " << err.what() << dendl;
./auth/cephx/CephxClientHandler.cc:	      lderr(cct) << "could not verify extra service_tickets" << dendl;
./auth/cephx/CephxSessionHandler.cc:      lderr(cct) << __func__ << " failed to encrypt signature block" << dendl;
./auth/cephx/CephxSessionHandler.cc:      lderr(cct) << __func__ << " failed to encrypt signature block" << dendl;
./crypto/qat/qcccrypto.cc:  derr << "Failure during QAT init sequence. Quitting" << dendl;
./crypto/qat/qcccrypto.cc:    derr << "Unable to load memory driver" << dendl;
./crypto/qat/qcccrypto.cc:    derr << "Unable to start qat device" << dendl;
./crypto/qat/qcccrypto.cc:    derr << "Unable to alloc mem for instance struct" << dendl;
./crypto/qat/qcccrypto.cc:    derr << "Unable to find available instances" << dendl;
./crypto/qat/qcccrypto.cc:    derr << "Unable to allocate instances array memory" << dendl;
./crypto/qat/qcccrypto.cc:    derr << "Unable to get instances" << dendl;
./crypto/qat/qcccrypto.cc:      derr << "Unable to start instance" << dendl;
./crypto/qat/qcccrypto.cc:    derr << "Unable to allocate memory for session struct" << dendl;
./crypto/qat/qcccrypto.cc:    derr << "Unable to allocate memory for opmem struct" << dendl;
./crypto/qat/qcccrypto.cc:    derr << "Unable to allocate memory for pthreads" << dendl;
./crypto/qat/qcccrypto.cc:      derr << "Unable to find address translations of instance " << iter << dendl;
./crypto/qat/qcccrypto.cc:      derr << "QAT init failed" << dendl;
./crypto/qat/qcccrypto.cc:    derr << "Unable to get an QAT instance. Failing request" << dendl;
./crypto/qat/qcccrypto.cc:      derr << "Unable to get buff meta size" << dendl;
./crypto/qat/qcccrypto.cc:      derr << "Unable to allocate private metadata memory" << dendl;
./crypto/qat/qcccrypto.cc:      derr << "Unable to allocate bufferlist memory" << dendl;
./crypto/qat/qcccrypto.cc:      derr << "Unable to allocate bufferlist memory" << dendl;
./crypto/qat/qcccrypto.cc:      derr << "Unable to allocate opdata memory" << dendl;
./crypto/qat/qcccrypto.cc:      derr << "Unable to find session size" << dendl;
./crypto/qat/qcccrypto.cc:      derr << "Unable to allocate contig memory" << dendl;
./crypto/qat/qcccrypto.cc:    derr << "Unable to init session" << dendl;
./crypto/qat/qcccrypto.cc:      derr << "Unable to allocate contig memory" << dendl;
./crypto/qat/qcccrypto.cc:    derr << "Unable to create thread for crypt operation" << dendl;
./crypto/qat/qcccrypto.cc:    derr << "Unable to perform crypt operation" << dendl;
./crypto/openssl/openssl_crypto_accel.cc:    derr << "failed to create evp cipher context" << dendl;
./crypto/openssl/openssl_crypto_accel.cc:    derr << "EVP_CipherInit_ex failed" << dendl;
./crypto/openssl/openssl_crypto_accel.cc:    derr << "failed to disable PKCS padding" << dendl;
./crypto/openssl/openssl_crypto_accel.cc:    derr << "EVP_CipherUpdate failed" << dendl;
./crypto/openssl/openssl_crypto_accel.cc:    derr << "EVP_CipherFinal_ex failed" << dendl;
./osd/PG.cc:      derr << __func__ << ": remove_oid returned " << cpp_strerror(r) << dendl;
./osd/PG.cc:    derr << __func__ << ": remove_oid returned " << cpp_strerror(r) << dendl;
./osd/PG.cc:	  derr << __func__ << " remove_oid " << i->soid << " failed with " << r << dendl;
./osd/PG.cc:	  derr << __func__ << " decode snaps failure on " << *i << dendl;
./osd/PG.cc:    derr << __func__ << " set_collection_opts returns error:" << r << dendl;
./osd/OSDMap.cc:	    lderr(cct) << __func__ << " no pool " << tier_pool << dendl;
./osd/OSDMap.cc:	  lderr(cct) << __func__ << " " << r->first << " tier_of != " << new_pool.first << dendl;
./osd/OSDMap.cc:	lderr(cct) << "[osd." << o << "] in config has id > mon_max_osd " << cct->_conf->mon_max_osd << dendl;
./osd/OSDMap.cc:    lderr(cct) << ss.str() << dendl;
./osd/OSDMap.cc:    lderr(cct) << __func__ << " abort due to osd_weight_total == 0" << dendl;
./osd/OSDMap.cc:    lderr(cct) << __func__ << " abort due to max <= 0" << dendl;
./osd/Watch.cc:	lgeneric_derr(cct) << __func__ << " not still connected to " << (*i) << dendl;
./osd/ReplicatedBackend.cc:    lgeneric_derr(cct) << __func__ << " sleeping for " << sleeptime << dendl;
./osd/pg_scrubber.cc:	derr << __func__ << " no head for " << hoid << " (have " << head << ")" << dendl;
./osd/pg_scrubber.cc:	derr << __func__ << " no clone_snaps for " << hoid << " in " << snapset << dendl;
./osd/pg_scrubber.cc:	derr << __func__ << ": get_snaps returned " << cpp_strerror(r) << dendl;
./osd/pg_scrubber.cc:	    derr << __func__ << ": remove_oid returned " << cpp_strerror(r) << dendl;
./osd/pg_scrubber.cc:	    derr << __func__ << ": queue_transaction got " << cpp_strerror(e) << dendl;
./osd/ECBackend.cc:    lgeneric_derr(cct) << __func__ << " sleeping for " << sleeptime << dendl;
./osd/PrimaryLogPG.cc:      derr << __func__ << " " << hoid << " had no clone_snaps" << dendl;
./osd/PrimaryLogPG.cc:	derr << "bad op order, already applied " << p->second << " > this " << t << dendl;
./osd/PrimaryLogPG.cc:    derr << "removing snap head" << dendl;
./osd/PrimaryLogPG.cc:    derr << "invalid length ws data length " << op.writesame.data_length << " actual len " << osd_op.indata.length() << dendl;
./osd/PrimaryLogPG.cc:    derr << "do_writesame do_osd_ops failed " << result << dendl;
./osd/PrimaryLogPG.cc:      derr << __func__ << ": do_osd_ops failed: " << cpp_strerror(r) << dendl;
./osd/PrimaryLogPG.cc:    derr << __func__ << " failed " << result << dendl;
./osd/PrimaryLogPG.cc:	  derr << "method " << cname << "." << mname << " tried to read object but is not marked RD" << dendl;
./osd/PrimaryLogPG.cc:	  derr << "method " << cname << "." << mname << " tried to update object but is not marked WR" << dendl;
./osd/PrimaryLogPG.cc:    derr << __func__ << " injecting copyfrom failure" << dendl;
./osd/PrimaryLogPG.cc:    derr << __func__ << " unexpected promote error " << cpp_strerror(r) << dendl;
./osd/PrimaryLogPG.cc:    derr << __func__ << " unexpected promote error " << cpp_strerror(r) << dendl;
./osd/PrimaryLogPG.cc:    derr << __func__ << ": obc->ssc not available, not returning context" << dendl;
./osd/PrimaryLogPG.cc:      derr << __func__ << ": object " << i.first << " obc still alive" << dendl;
./osd/PrimaryLogPG.cc:	  derr << __func__ << " on non-replicated pool" << dendl;
./osd/PrimaryLogPG.cc:	  derr << __func__ << ": could not load hitset " << oid << dendl;
./osd/PGLog.cc:    derr << "log.log.size() != log_keys_debug.size()" << dendl;
./osd/PGLog.cc:    derr << "actual log:" << dendl;
./osd/PGLog.cc:      derr << "    " << *i << dendl;
./osd/PGLog.cc:    derr << "log_keys_debug:" << dendl;
./osd/PGLog.cc:      derr << "    " << *i << dendl;
./osd/PGBackend.cc:      derr << __func__ << " list collection " << ch << " got: " << cpp_strerror(r) << dendl;
./osd/PGBackend.cc:    derr << __func__ << " got: " << cpp_strerror(r) << dendl;
./osd/OSD.cc:  derr << "live pgids:" << dendl;
./osd/OSD.cc:    derr << "\t" << *i << dendl;
./osd/OSD.cc:      derr << "agent queue not empty, for example " << (*top.begin())->get_pgid() << dendl;
./osd/OSD.cc:    derr << __func__ << " full_ratio, backfillfull_ratio or nearfull_ratio is <= 0" << dendl;
./osd/OSD.cc:      derr << __func__ << " missing full map " << since << dendl;
./osd/OSD.cc:	derr << __func__ << " also missing full map " << e << dendl;
./osd/OSD.cc:    derr << __func__ << " unable to load latest map " << m->newest_map << dendl;
./osd/OSD.cc:      derr << "failed to load OSD map for epoch " << epoch << ", got " << bl.length() << " bytes" << dendl;
./osd/OSD.cc:      derr << "OSD::mkfs: have meta collection but no superblock" << dendl;
./osd/OSD.cc:  derr << "*** Got signal " << sig_str(signum) << " ***" << dendl;
./osd/OSD.cc:      derr << __func__ << " unable to start fuse: " << cpp_strerror(r) << dendl;
./osd/OSD.cc:    derr << "OSD:init: unable to mount object store" << dendl;
./osd/OSD.cc:    derr << "OSD::init() : couldn't read loadavgs\n" << dendl;
./osd/OSD.cc:      derr << cpp_strerror(r) << dendl;
./osd/OSD.cc:    derr << "OSD::init() : unable to read osd superblock" << dendl;
./osd/OSD.cc:    derr << "The disk uses features unsupported by the executable." << dendl;
./osd/OSD.cc:    derr << " ondisk features " << superblock.compat_features << dendl;
./osd/OSD.cc:    derr << " daemon features " << osd_compat << dendl;
./osd/OSD.cc:      derr << "it is still writeable, though. Missing features: " << diff << dendl;
./osd/OSD.cc:      derr << "Cannot write to disk! Missing features: " << diff << dendl;
./osd/OSD.cc:    derr << "OSD::init: unable to read current osdmap" << dendl;
./osd/OSD.cc:    derr << "unable to obtain rotating service keys; retrying" << dendl;
./osd/OSD.cc:        derr << __func__ << " wait_auth_rotating timed out" << dendl;
./osd/OSD.cc:    derr << "*** Immediate shutdown (osd_fast_shutdown=true) ***" << dendl;
./osd/OSD.cc:      derr << __func__ << " fail: '" << outs << "': " << cpp_strerror(r) << dendl;
./osd/OSD.cc:      derr << "statfs: " << cpp_strerror(r) << dendl;
./osd/OSD.cc:    derr << "failed to list pgs: " << cpp_strerror(-r) << dendl;
./osd/OSD.cc:    derr << "waiting for initial osdmap" << dendl;
./osd/OSD.cc:    derr << "osdmap says I am destroyed" << dendl;
./osd/OSD.cc:    derr << "osdmap NOUP flag is set, waiting for it to clear" << dendl;
./osd/OSD.cc:    derr << "osdmap fullness state needs update" << dendl;
./osd/OSD.cc:      derr << __func__ << " transaction size overflowed" << dendl;
./osd/OSD.cc:	derr << "ERROR: bad fsid?  i have " << get_osdmap()->get_fsid() << " and inc has " << inc.fsid << dendl;
./osd/OSD.cc:	derr << __func__ << " injecting map crc failure" << dendl;
./osd/OSD.cc:      derr << "map says i do not exist.  shutting down." << dendl;
./osd/OSD.cc:      derr << "map says i am stopped by admin. shutting down." << dendl;
./osd/OSD.cc:    derr << __func__ << " SORTBITWISE flag is not set" << dendl;
./osd/OSD.cc:      derr << __func__ << " unrecognized pg-less event " << evt->get_desc() << dendl;
./osd/OSD.cc:  derr << "log_to_monitors " << log_to_monitors << dendl;
./librbd/ImageState.cc:    lderr(cct) << "failed to open image: " << cpp_strerror(r) << dendl;
./librbd/ImageState.cc:    lderr(cct) << "failed to set snapshot: " << cpp_strerror(r) << dendl;
./librbd/internal.cc:    lderr(cct) << "failed to stat RBD directory: " << cpp_strerror(r) << dendl;
./librbd/internal.cc:      lderr(cct) << "unrecognized header format" << dendl;
./librbd/internal.cc:      lderr(cct) << "attempting to add v1 image to namespace" << dendl;
./librbd/internal.cc:      lderr(cct) << "create does not support 'flatten' image option" << dendl;
./librbd/internal.cc:      lderr(cct) << "rbd image " << image_name << " already exists" << dendl;
./librbd/internal.cc:        lderr(cct) << "Format 1 image creation unsupported. " << dendl;
./librbd/internal.cc:      lderr(cct) << "Forced V1 image creation. " << dendl;
./librbd/internal.cc:      lderr(cct) << "image to be cloned must be a snapshot" << dendl;
./librbd/internal.cc:      lderr(cct) << "clone does not support 'flatten' image option" << dendl;
./librbd/internal.cc:      lderr(cct) << "error opening source image: " << cpp_strerror(r) << dendl;
./librbd/internal.cc:	lderr(cct) << "exclusive-lock feature is not enabled" << dendl;
./librbd/internal.cc:      lderr(cct) << "failed to acquire exclusive lock" << dendl;
./librbd/internal.cc:	lderr(cct) << "not exclusive lock owner" << dendl;
./librbd/internal.cc:        lderr(cct) << "exclusive-lock feature is not enabled" << dendl;
./librbd/internal.cc:        lderr(cct) << "exclusive-lock feature is not enabled" << dendl;
./librbd/internal.cc:        lderr(cct) << "exclusive-lock feature is not enabled" << dendl;
./librbd/internal.cc:      lderr(cct) << "failed to break lock: " << cpp_strerror(r) << dendl;
./librbd/internal.cc:      lderr(cct) << "copy does not support 'flatten' image option" << dendl;
./librbd/internal.cc:      lderr(cct) << "librbd does not support requested features" << dendl;
./librbd/internal.cc:      lderr(cct) << "header creation failed" << dendl;
./librbd/internal.cc:      lderr(cct) << "failed to read newly created header" << dendl;
./librbd/internal.cc:      lderr(cct) << "failed to copy metadata: " << cpp_strerror(r) << dendl;
./librbd/crypto/BlockCrypto.cc:    lderr(m_cct) << "unable to get crypt context" << dendl;
./librbd/crypto/BlockCrypto.cc:          lderr(m_cct) << "unable to init cipher's IV" << dendl;
./librbd/crypto/BlockCrypto.cc:        lderr(m_cct) << "crypt update failed" << dendl;
./librbd/crypto/luks/LoadRequest.cc:    lderr(m_image_ctx->cct) << "unsupported cipher: " << cipher << dendl;
./librbd/crypto/luks/Header.cc:      lderr(m_cct) << "[libcryptsetup] " << msg << dendl;
./librbd/crypto/luks/Header.cc:    lderr(m_cct) << "crypt_init failed: " << cpp_strerror(r) << dendl;
./librbd/crypto/luks/Header.cc:    lderr(m_cct) << "error writing header: " << cpp_strerror(r) << dendl;
./librbd/crypto/luks/Header.cc:    lderr(m_cct) << "error reading header: " << cpp_strerror(r) << dendl;
./librbd/crypto/luks/Header.cc:    lderr(m_cct) << "crypt_format failed: " << cpp_strerror(r) << dendl;
./librbd/crypto/luks/Header.cc:    lderr(m_cct) << "crypt_load failed: " << cpp_strerror(r) << dendl;
./librbd/crypto/LoadRequest.cc:    lderr(m_image_ctx->cct) << "encryption already loaded" << dendl;
./librbd/crypto/openssl/DataCryptor.cc:    lderr(m_cct) << "missing cipher name" << dendl;
./librbd/crypto/openssl/DataCryptor.cc:    lderr(m_cct) << "missing key" << dendl;
./librbd/crypto/openssl/DataCryptor.cc:      lderr(m_cct) << "Invalid CipherMode:" << mode << dendl;
./librbd/crypto/openssl/DataCryptor.cc:    lderr(m_cct) << "EVP_CIPHER_CTX_new failed" << dendl;
./librbd/crypto/openssl/DataCryptor.cc:    lderr(m_cct) << "EVP_CipherInit_ex failed" << dendl;
./librbd/crypto/openssl/DataCryptor.cc:    lderr(m_cct) << "EVP_CipherInit_ex failed" << dendl;
./librbd/crypto/openssl/DataCryptor.cc:    lderr(m_cct) << "EVP_CipherUpdate failed. len=" << len << dendl;
./librbd/crypto/FormatRequest.cc:    lderr(m_image_ctx->cct) << "cannot use encryption with journal" << dendl;
./librbd/crypto/Utils.cc:      lderr(cct) << "unsupported key length: " << key_length << dendl;
./librbd/DeepCopyRequest.cc:    lderr(m_cct) << "missing data pool for source image" << dendl;
./librbd/DeepCopyRequest.cc:    lderr(m_cct) << "missing data pool for destination image" << dendl;
./librbd/DeepCopyRequest.cc:    lderr(m_cct) << "failed to copy image: " << cpp_strerror(r) << dendl;
./librbd/DeepCopyRequest.cc:    lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/DeepCopyRequest.cc:    lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/DeepCopyRequest.cc:    lderr(m_cct) << "failed to copy metadata: " << cpp_strerror(r) << dendl;
./librbd/DeepCopyRequest.cc:    lderr(m_cct) << "invalid start snap_id " << m_src_snap_id_start << dendl;
./librbd/DeepCopyRequest.cc:    lderr(m_cct) << "invalid end snap_id " << m_src_snap_id_end << dendl;
./librbd/migration/NativeFormat.cc:      lderr(cct) << "invalid pool name" << dendl;
./librbd/migration/NativeFormat.cc:    lderr(cct) << "invalid pool name" << dendl;
./librbd/migration/NativeFormat.cc:    lderr(cct) << "cannot specify both pool name and pool id" << dendl;
./librbd/migration/NativeFormat.cc:    lderr(cct) << "missing or invalid pool id" << dendl;
./librbd/migration/NativeFormat.cc:    lderr(cct) << "invalid pool namespace" << dendl;
./librbd/migration/NativeFormat.cc:    lderr(cct) << "missing or invalid image name" << dendl;
./librbd/migration/NativeFormat.cc:    lderr(cct) << "invalid image id" << dendl;
./librbd/migration/NativeFormat.cc:    lderr(cct) << "invalid snap name" << dendl;
./librbd/migration/NativeFormat.cc:    lderr(cct) << "cannot specify both snap name and snap id" << dendl;
./librbd/migration/NativeFormat.cc:    lderr(cct) << "invalid snap id" << dendl;
./librbd/migration/NativeFormat.cc:    lderr(cct) << "snapshot required for import" << dendl;
./librbd/migration/NativeFormat.cc:    lderr(cct) << "failed to open image: " << cpp_strerror(r) << dendl;
./librbd/migration/NativeFormat.cc:    lderr(cct) << "failed to locate snapshot " << m_snap_name << dendl;
./librbd/migration/HttpClient.cc:      lderr(cct) << "client shutdown during in-flight request" << dendl;
./librbd/migration/HttpClient.cc:        lderr(cct) << "timed-out while issuing request" << dendl;
./librbd/migration/HttpClient.cc:        lderr(cct) << "failed to issue request: " << ec.message() << dendl;
./librbd/migration/HttpClient.cc:      lderr(cct) << "failed to shutdown socket: " << ec.message() << dendl;
./librbd/migration/HttpClient.cc:      lderr(cct) << "client shutdown with in-flight request" << dendl;
./librbd/migration/HttpClient.cc:        lderr(cct) << "timed-out while issuing request" << dendl;
./librbd/migration/HttpClient.cc:        lderr(cct) << "failed to issue request: " << ec.message() << dendl;
./librbd/migration/HttpClient.cc:      lderr(cct) << "requested resource does not exist" << dendl;
./librbd/migration/HttpClient.cc:      lderr(cct) << "permission denied attempting to access resource" << dendl;
./librbd/migration/HttpClient.cc:      lderr(cct) << "failed to retrieve size: HTTP " << result << dendl;
./librbd/migration/HttpClient.cc:    lderr(m_cct) << "failed to retrieve size: " << cpp_strerror(r) << dendl;
./librbd/migration/HttpClient.cc:    lderr(m_cct) << "failed to retrieve size: missing content-length" << dendl;
./librbd/migration/HttpClient.cc:    lderr(m_cct) << "invalid content-length in response" << dendl;
./librbd/migration/S3Stream.cc:    lderr(m_cct) << "failed to locate '" << URL_KEY << "' key" << dendl;
./librbd/migration/S3Stream.cc:    lderr(m_cct) << "failed to locate '" << ACCESS_KEY << "' key" << dendl;
./librbd/migration/S3Stream.cc:    lderr(m_cct) << "failed to locate '" << SECRET_KEY << "' key" << dendl;
./librbd/migration/ImageDispatch.cc:  lderr(cct) << dendl;
./librbd/migration/ImageDispatch.cc:  lderr(cct) << dendl;
./librbd/migration/ImageDispatch.cc:  lderr(cct) << dendl;
./librbd/migration/ImageDispatch.cc:  lderr(cct) << dendl;
./librbd/migration/HttpStream.cc:    lderr(m_cct) << "failed to locate '" << URL_KEY << "' key" << dendl;
./librbd/migration/FileStream.cc:      lderr(cct) << "failed to seek file stream: " << cpp_strerror(r) << dendl;
./librbd/migration/FileStream.cc:    lderr(m_cct) << "failed to locate '" << FILE_PATH << "' key" << dendl;
./librbd/migration/QCOWFormat.cc:      lderr(cct) << "L1 index " << l1_table_index << " out-of-bounds" << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "invalid QCOW header magic" << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "QCOW is not supported" << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "failed to read QCOW header: " << cpp_strerror(r) << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "header is not QCOW" << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "invalid cluster bits: " << header.cluster_bits << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "invalid L2 bits: " << header.l2_bits << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "invalid or unsupported encryption method" << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "image size is not a multiple of block size" << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "image size too big: " << m_size << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "failed to read QCOW2 header: " << cpp_strerror(r) << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "header is not QCOW2" << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "invalid cluster bits: " << header.cluster_bits << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "invalid or unsupported encryption method" << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "image size is not a multiple of block size" << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "invalid or unsupported compression type" << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "external data file feature not supported" << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "extended L2 table feature not supported" << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "unknown incompatible feature enabled" << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "image size too big: " << m_size << dendl;
./librbd/migration/QCOWFormat.cc:    lderr(cct) << "failed to read L1 table: " << cpp_strerror(r) << dendl;
./librbd/migration/RawFormat.cc:    lderr(cct) << "invalid snapshots array" << dendl;
./librbd/migration/SourceSpecBuilder.cc:  lderr(cct) << "invalid source-spec JSON" << dendl;
./librbd/migration/SourceSpecBuilder.cc:    lderr(cct) << "failed to locate format type value" << dendl;
./librbd/migration/SourceSpecBuilder.cc:    lderr(cct) << "failed to locate snapshot type value" << dendl;
./librbd/migration/SourceSpecBuilder.cc:    lderr(cct) << "failed to locate stream object" << dendl;
./librbd/migration/SourceSpecBuilder.cc:    lderr(cct) << "failed to locate stream type value" << dendl;
./librbd/migration/RawSnapshot.cc:      lderr(cct) << "failed to open stream: " << cpp_strerror(r) << dendl;
./librbd/migration/RawSnapshot.cc:      lderr(cct) << "failed to open stream: " << cpp_strerror(r) << dendl;
./librbd/migration/RawSnapshot.cc:      lderr(cct) << "invalid snapshot name" << dendl;
./librbd/migration/Utils.cc:    lderr(cct) << "invalid url: '" << url << "'" << dendl;
./librbd/migration/Utils.cc:    lderr(cct) << "invalid url scheme: '" << url << "'" << dendl;
./librbd/migration/Utils.cc:      lderr(cct) << "invalid url port: '" << url << "'" << dendl;
./librbd/Operations.cc:        lderr(cct) << "update notification timed-out" << dendl;
./librbd/Operations.cc:      lderr(cct) << "failed to refresh image: " << cpp_strerror(r) << dendl;
./librbd/Operations.cc:      lderr(cct) << "image has no parent" << dendl;
./librbd/Operations.cc:    lderr(cct) << "image has no parent" << dendl;
./librbd/Operations.cc:    lderr(cct) << "snapshots cannot be flattened" << dendl;
./librbd/Operations.cc:    lderr(cct) << "image must support object-map feature" << dendl;
./librbd/Operations.cc:    lderr(cct) << "rbd image " << dstname << " already exists" << dendl;
./librbd/Operations.cc:    lderr(cct) << "New size not compatible with object map" << dendl;
./librbd/Operations.cc:        lderr(cct) << "No such snapshot found." << dendl;
./librbd/Operations.cc:    lderr(cct) << "No such snapshot found." << dendl;
./librbd/Operations.cc:    lderr(m_image_ctx.cct) << "No such snapshot found." << dendl;
./librbd/Operations.cc:    lderr(m_image_ctx.cct) << "snapshot is protected" << dendl;
./librbd/Operations.cc:    lderr(cct) << "image must support layering" << dendl;
./librbd/Operations.cc:    lderr(cct) << "old-format images do not support features" << dendl;
./librbd/Operations.cc:    lderr(cct) << "cannot update immutable features" << dendl;
./librbd/Operations.cc:    lderr(cct) << "update requires at least one feature" << dendl;
./librbd/Operations.cc:      lderr(cct) << "image has no migrating parent" << dendl;
./librbd/Operations.cc:    lderr(cct) << "image has no migrating parent" << dendl;
./librbd/Operations.cc:    lderr(cct) << "snapshots cannot be migrated" << dendl;
./librbd/api/Pool.cc:      lderr(m_cct) << "failed to stat image: " << cpp_strerror(r) << dendl;
./librbd/api/Pool.cc:      lderr(m_cct) << "snap context is invalid" << dendl;
./librbd/api/Migration.cc:      lderr(cct) << "failed to open image: " << cpp_strerror(r) << dendl;
./librbd/api/Migration.cc:    lderr(cct) << "failed to open image: " << cpp_strerror(r) << dendl;
./librbd/api/Migration.cc:    lderr(cct) << "failed listing watchers:" << cpp_strerror(r) << dendl;
./librbd/api/Migration.cc:    lderr(cct) << "image has watchers - not migrating" << dendl;
./librbd/api/Migration.cc:    lderr(cct) << "unsupported destination image format: " << format << dendl;
./librbd/api/Migration.cc:    lderr(cct) << "librbd does not support requested features" << dendl;
./librbd/api/Migration.cc:    lderr(cct) << "failed to open source image: " << cpp_strerror(r) << dendl;
./librbd/api/Migration.cc:      lderr(cct) << "failed to clean source spec" << dendl;
./librbd/api/Migration.cc:    lderr(m_cct) << "migration failed: " << cpp_strerror(r) << dendl;
./librbd/api/Migration.cc:      lderr(m_cct) << "failed listing watchers:" << cpp_strerror(r) << dendl;
./librbd/api/Migration.cc:      lderr(m_cct) << "image has watchers - cannot abort migration" << dendl;
./librbd/api/Migration.cc:    lderr(m_cct) << "failed listing snapshots: " << cpp_strerror(r) << dendl;
./librbd/api/Migration.cc:    lderr(m_cct) << "header creation failed: " << cpp_strerror(r) << dendl;
./librbd/api/Migration.cc:      lderr(m_cct) << "cannot obtain exclusive lock" << dendl;
./librbd/api/Migration.cc:    lderr(m_cct) << "failed to copy snapshots: " << cpp_strerror(r) << dendl;
./librbd/api/Migration.cc:      lderr(m_cct) << "failed to copy metadata: " << cpp_strerror(r) << dendl;
./librbd/api/Migration.cc:    lderr(m_cct) << "failed to get image group: " << cpp_strerror(r) << dendl;
./librbd/api/Migration.cc:    lderr(m_cct) << "failed to open child image: " << cpp_strerror(r) << dendl;
./librbd/api/Migration.cc:      lderr(m_cct) << "failed to re-attach parent: " << cpp_strerror(r) << dendl;
./librbd/api/Migration.cc:      lderr(m_cct) << "failed to re-attach child: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "invalid auth keyring JSON received" << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "failed to list mirror peers: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "multiple peers are not currently supported" << dendl;
./librbd/api/Mirror.cc:        lderr(cct) << "failed to update peer site name" << dendl;
./librbd/api/Mirror.cc:      lderr(ictx->cct) << "snapshot based mirroring is not enabled" << dendl;
./librbd/api/Mirror.cc:          lderr(cct) << "mirroring is not enabled for the parent" << dendl;
./librbd/api/Mirror.cc:      lderr(cct) << "cannot enable journaling: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "cannot enable mirroring: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "cannot disable mirroring: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "cannot disable mirroring: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:      lderr(cct) << "cannot disable journaling: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "failed to promote image" << dendl;
./librbd/api/Mirror.cc:        lderr(ictx->cct) << "refresh failed: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "failed to demote image" << dendl;
./librbd/api/Mirror.cc:        lderr(ictx->cct) << "refresh failed: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "image is primary, cannot resync to itself" << dendl;
./librbd/api/Mirror.cc:      lderr(cct) << "failed to request resync: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:      lderr(cct) << "failed to request resync: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "unknown mirror mode" << dendl;
./librbd/api/Mirror.cc:        lderr(ictx->cct) << "refresh failed: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "mirroring is not currently enabled" << dendl;
./librbd/api/Mirror.cc:      lderr(cct) << "failed to list peers: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:      lderr(cct) << "mirror peers still registered" << dendl;
./librbd/api/Mirror.cc:      lderr(cct) << "failed listing images: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:        lderr(cct) << "failed listing images: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "failed to set mirror mode: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "invalid mirror peer direction" << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "failed to decode base64" << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "invalid bootstrap token JSON received" << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "cannot import token for local cluster" << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "unexpected remote cluster fsid" << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "cannot import token for duplicate site name" << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "cannot add self as remote peer" << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "failed to list peers: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "cannot set self as remote peer" << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "invalid peer attributes JSON received" << dendl;
./librbd/api/Mirror.cc:    lderr(cct) << "failed to list mirror peers: " << cpp_strerror(r) << dendl;
./librbd/api/Mirror.cc:        lderr(ictx->cct) << "refresh failed: " << cpp_strerror(r) << dendl;
./librbd/api/Group.cc:      lderr(cct) << "Failed deleting image snapshot. Ret code: " << r << dendl;
./librbd/api/Group.cc:      lderr(cct) << "Failed rolling back group to snapshot. Ret code: " << r << dendl;
./librbd/api/Group.cc:    lderr(cct) << "error creating group header: " << cpp_strerror(r) << dendl;
./librbd/api/Group.cc:    lderr(cct) << "error getting id of group" << dendl;
./librbd/api/Group.cc:    lderr(cct) << "error listing group snapshots" << dendl;
./librbd/api/Group.cc:    lderr(cct) << "error listing group images" << dendl;
./librbd/api/Group.cc:      lderr(cct) << "error removing image from a group" << dendl;
./librbd/api/Group.cc:    lderr(cct) << "error removing header: " << cpp_strerror(-r) << dendl;
./librbd/api/Group.cc:    lderr(cct) << "error removing group from directory" << dendl;
./librbd/api/Group.cc:    lderr(cct) << "group and image cannot be in different namespaces" << dendl;
./librbd/api/Group.cc:    lderr(cct) << "group and image cannot be in different namespaces" << dendl;
./librbd/api/Group.cc:      lderr(cct) << "error getting id of group" << dendl;
./librbd/api/Group.cc:    lderr(cct) << "error renaming group from directory" << dendl;
./librbd/api/Group.cc:      lderr(cct) << "Failed cleaning up image snapshot. Ret code: " << r << dendl;
./librbd/api/Group.cc:    lderr(cct) << "error while cleaning up group snapshot" << dendl;
./librbd/api/Group.cc:    lderr(cct) << "error reading group id object: " << cpp_strerror(r) << dendl;
./librbd/api/Image.cc:    lderr(cct) << "error getting data pool ID: " << cpp_strerror(r) << dendl;
./librbd/api/Image.cc:      lderr(cct) << "error listing v1 images: " << cpp_strerror(r) << dendl;
./librbd/api/Image.cc:    lderr(cct) << "error listing v2 images: " << cpp_strerror(r) << dendl;
./librbd/api/Image.cc:    lderr(cct) << "error listing trash images: " << cpp_strerror(r) << dendl;
./librbd/api/Image.cc:    lderr(cct) << "error listing pools: " << cpp_strerror(r) << dendl;
./librbd/api/Image.cc:    lderr(cct) << "error retrieving children: " << cpp_strerror(r) << dendl;
./librbd/api/Image.cc:        lderr(cct) << "error listing v2 images: " << cpp_strerror(r) << dendl;
./librbd/api/Image.cc:      lderr(cct) << "cannot deep copy migrating image" << dendl;
./librbd/api/Image.cc:    lderr(cct) << "old format not supported for destination image" << dendl;
./librbd/api/Image.cc:    lderr(cct) << "librbd does not support requested features" << dendl;
./librbd/api/Image.cc:    lderr(cct) << "header creation failed" << dendl;
./librbd/api/Image.cc:    lderr(cct) << "failed to read newly created header" << dendl;
./librbd/api/Image.cc:    lderr(cct) << "failed to retrieve image id: " << cpp_strerror(r) << dendl;
./librbd/api/Image.cc:          lderr(cct) << "image has snapshots - not removing" << dendl;
./librbd/api/Image.cc:      lderr(cct) << "error opening image: " << cpp_strerror(r) << dendl;
./librbd/api/Image.cc:      lderr(cct) << "failed to close image: " << cpp_strerror(r) << dendl;
./librbd/api/Image.cc:    lderr(ictx->cct) << "cannot format a cloned image" << dendl;
./librbd/api/Namespace.cc:    lderr(cct) << "failed to add namespace: " << cpp_strerror(r) << dendl;
./librbd/api/Namespace.cc:    lderr(cct) << "failed to remove namespace: " << cpp_strerror(ret_val) << dendl;
./librbd/api/Namespace.cc:    lderr(cct) << "failed to remove namespace: " << cpp_strerror(r) << dendl;
./librbd/api/Namespace.cc:      lderr(cct) << "error listing namespaces: " << cpp_strerror(r) << dendl;
./librbd/api/Namespace.cc:    lderr(cct) << "error asserting namespace: " << cpp_strerror(r) << dendl;
./librbd/api/Io.cc:    lderr(cct) << "missing data pool" << dendl;
./librbd/api/Io.cc:    lderr(cct) << "invalid IO request: " << cpp_strerror(r) << dendl;
./librbd/api/Io.cc:    lderr(cct) << "invalid IO request: " << cpp_strerror(r) << dendl;
./librbd/api/Io.cc:    lderr(cct) << "invalid IO request: " << cpp_strerror(r) << dendl;
./librbd/api/Io.cc:    lderr(cct) << "invalid IO request: " << cpp_strerror(r) << dendl;
./librbd/api/Io.cc:    lderr(cct) << "invalid IO request: " << cpp_strerror(r) << dendl;
./librbd/api/Trash.cc:    lderr(cct) << "failed to retrieve features: " << cpp_strerror(r) << dendl;
./librbd/api/Trash.cc:    lderr(cct) << "failed to open image: " << cpp_strerror(r) << dendl;
./librbd/api/Trash.cc:        lderr(cct) << "cannot obtain exclusive lock - not removing" << dendl;
./librbd/api/Trash.cc:      lderr(cct) << "cannot move migrating image to trash" << dendl;
./librbd/api/Trash.cc:    lderr(cct) << "failed to retrieve image id: " << cpp_strerror(r) << dendl;
./librbd/api/Trash.cc:    lderr(cct) << "invalid image name/id" << dendl;
./librbd/api/Trash.cc:        lderr(cct) << "failed to query data pool: " << cpp_strerror(r) << dendl;
./librbd/api/Trash.cc:          lderr(cct) << "error accessing data pool" << dendl;
./librbd/api/Trash.cc:        lderr(cct) << "remove error: " << cpp_strerror(r) << dendl;
./librbd/api/Trash.cc:    lderr(cct) << "error: deferment time has not expired." << dendl;
./librbd/api/Trash.cc:    lderr(cct) << "error: image is pending restoration." << dendl;
./librbd/api/Snapshot.cc:      lderr(ictx->cct) << "failed to unprotect snapshot: " << snap_name << dendl;
./librbd/api/Snapshot.cc:      lderr(ictx->cct) << "snapshot is still protected after unprotection" << dendl;
./librbd/api/Utils.cc:      lderr(cct) << "unsupported encryption format: " << format << dendl;
./librbd/api/Utils.cc:    lderr(cct) << "expected opts_size: " << expected_opts_size << dendl;
./librbd/watcher/RewatchRequest.cc:    lderr(cct) << "client blocklisted" << dendl;
./librbd/watcher/RewatchRequest.cc:    lderr(cct) << "failed to unwatch: " << cpp_strerror(r) << dendl;
./librbd/PluginRegistry.cc:      lderr(cct) << "failed to load plugin: " << token << dendl;
./librbd/image_watcher/NotifyLockOwner.cc:        lderr(cct) << ": duplicate lock owners detected" << dendl;
./librbd/cache/ParentCacheObjectDispatch.cc:    lderr(cct) << "Parent cache register fails." << dendl;
./librbd/cache/ParentCacheObjectDispatch.cc:      lderr(cct) << "Parent cache fail to register client." << dendl;
./librbd/cache/ParentCacheObjectDispatch.cc:      lderr(cct) << "Parent cache fail to connect RO daeomn." << dendl;
./librbd/cache/ObjectCacherObjectDispatch.cc:      lderr(cct) << "blocklisted during flush (purging)" << dendl;
./librbd/cache/ObjectCacherObjectDispatch.cc:      lderr(cct) << "failed to invalidate cache: " << cpp_strerror(r) << dendl;
./librbd/cache/pwl/rwl/WriteLog.cc:      lderr(cct) << "num_small_writes needs to > 2" << dendl;
./librbd/cache/pwl/rwl/WriteLog.cc:      lderr(cct) << "failed to initialize pool (" << this->m_log_pool_name << ")" << dendl;
./librbd/cache/pwl/rwl/WriteLog.cc:      lderr(m_image_ctx.cct) << "failed to commit update of flushed sync point" << dendl;
./librbd/cache/pwl/AbstractWriteLog.cc:          lderr(m_image_ctx.cct) << "Sync point missing for entry=[" << *gen_write_entry << "]" << dendl;
./librbd/ManagedLock.cc:    lderr(m_cct) << "watcher not registered - delaying request" << dendl;
./librbd/journal/CreateRequest.cc:    lderr(m_cct) << "order must be in the range [12, 64]" << dendl;
./librbd/journal/CreateRequest.cc:    lderr(m_cct) << "failed to create journal: " << cpp_strerror(*result) << dendl;
./librbd/journal/CreateRequest.cc:    lderr(m_cct) << "failed to allocate tag: " << cpp_strerror(*result) << dendl;
./librbd/journal/CreateRequest.cc:    lderr(m_cct) << "failed to register client: " << cpp_strerror(*result) << dendl;
./librbd/journal/CreateRequest.cc:    lderr(m_cct) << "failed to shut down journaler: " << cpp_strerror(*result) << dendl;
./librbd/journal/StandardPolicy.cc:    lderr(m_image_ctx->cct) << "local image not promoted" << dendl;
./librbd/journal/OpenRequest.cc:    lderr(cct) << "failed to locate master image client" << dendl;
./librbd/journal/DemoteRequest.cc:    lderr(cct) << "failed to open journal: " << cpp_strerror(r) << dendl;
./librbd/journal/DemoteRequest.cc:    lderr(cct) << "image is not currently the primary" << dendl;
./librbd/journal/DemoteRequest.cc:    lderr(cct) << "failed to retrieve client: " << cpp_strerror(r) << dendl;
./librbd/journal/DemoteRequest.cc:    lderr(cct) << "failed to allocate tag: " << cpp_strerror(r) << dendl;
./librbd/journal/DemoteRequest.cc:    lderr(cct) << "failed to stop journal append: " << cpp_strerror(r) << dendl;
./librbd/journal/DemoteRequest.cc:    lderr(cct) << "failed to shut down journal: " << cpp_strerror(r) << dendl;
./librbd/journal/ResetRequest.cc:    lderr(m_cct) << "failed to init journaler: " << cpp_strerror(r) << dendl;
./librbd/journal/ResetRequest.cc:    lderr(m_cct) << "failed to remove journal: " << cpp_strerror(r) << dendl;
./librbd/journal/ResetRequest.cc:    lderr(m_cct) << "failed to create journal: " << cpp_strerror(r) << dendl;
./librbd/journal/PromoteRequest.cc:    lderr(cct) << "failed to open journal: " << cpp_strerror(r) << dendl;
./librbd/journal/PromoteRequest.cc:    lderr(cct) << "failed to allocate tag: " << cpp_strerror(r) << dendl;
./librbd/journal/PromoteRequest.cc:    lderr(cct) << "failed to stop journal append: " << cpp_strerror(r) << dendl;
./librbd/journal/PromoteRequest.cc:    lderr(cct) << "failed to shut down journal: " << cpp_strerror(r) << dendl;
./librbd/journal/RemoveRequest.cc:    lderr(m_cct) << "failed to stat journal header: " << cpp_strerror(*result) << dendl;
./librbd/journal/RemoveRequest.cc:    lderr(m_cct) << "failed to init journaler: " << cpp_strerror(*result) << dendl;
./librbd/journal/RemoveRequest.cc:    lderr(m_cct) << "failed to remove journal: " << cpp_strerror(*result) << dendl;
./librbd/journal/RemoveRequest.cc:    lderr(m_cct) << "failed to shut down journaler: " << cpp_strerror(*result) << dendl;
./librbd/journal/Replay.cc:      lderr(cct) << ": ExecuteOp::" << __func__ << ": r=" << r << dendl;
./librbd/journal/Replay.cc:      lderr(cct) << ": C_RefreshIfRequired::" << __func__ << ": r=" << r << dendl;
./librbd/journal/Replay.cc:    lderr(cct) << ": AIO modify op failed: " << cpp_strerror(r) << dendl;
./librbd/journal/Replay.cc:    lderr(cct) << ": AIO flush failed: " << cpp_strerror(r) << dendl;
./librbd/journal/Replay.cc:    lderr(cct) << ": duplicate op tid detected: " << op_tid << dendl;
./librbd/operation/ResizeRequest.cc:    lderr(cct) << "failed to block writes: " << cpp_strerror(*result) << dendl;
./librbd/operation/ResizeRequest.cc:    lderr(cct) << "failed to trim image: " << cpp_strerror(*result) << dendl;
./librbd/operation/ResizeRequest.cc:    lderr(cct) << "failed to flush cache: " << cpp_strerror(*result) << dendl;
./librbd/operation/SparsifyRequest.cc:      lderr(m_cct) << "missing data pool" << dendl;
./librbd/operation/SparsifyRequest.cc:      lderr(m_cct) << "failed to sparsify: " << cpp_strerror(r) << dendl;
./librbd/operation/SparsifyRequest.cc:      lderr(m_cct) << "object map is not initialized" << dendl;
./librbd/operation/SparsifyRequest.cc:      lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/operation/SparsifyRequest.cc:      lderr(m_cct) << "stat failed: " << cpp_strerror(r) << dendl;
./librbd/operation/SparsifyRequest.cc:        lderr(m_cct) << "failed to read object: " << cpp_strerror(r) << dendl;
./librbd/operation/SparsifyRequest.cc:      lderr(m_cct) << "failed to trim: " << cpp_strerror(r) << dendl;
./librbd/operation/SparsifyRequest.cc:    lderr(cct) << "encountered error: " << cpp_strerror(r) << dendl;
./librbd/operation/SparsifyRequest.cc:    lderr(cct) << "sparsify encountered an error: " << cpp_strerror(r) << dendl;
./librbd/operation/RenameRequest.cc:      lderr(cct) << "encountered error: " << cpp_strerror(r) << dendl;
./librbd/operation/RenameRequest.cc:      lderr(cct) << "could not read directory: " << cpp_strerror(r) << dendl;
./librbd/operation/SnapshotProtectRequest.cc:      lderr(cct) << "encountered error: " << cpp_strerror(r) << dendl;
./librbd/operation/SnapshotProtectRequest.cc:    lderr(cct) << "image must support layering" << dendl;
./librbd/operation/SnapshotCreateRequest.cc:    lderr(cct) << "missing data pool" << dendl;
./librbd/operation/SnapshotCreateRequest.cc:    lderr(cct) << "failed to block writes: " << cpp_strerror(*result) << dendl;
./librbd/operation/SnapshotRenameRequest.cc:      lderr(cct) << "encountered error: " << cpp_strerror(r) << dendl;
./librbd/operation/MigrateRequest.cc:      lderr(cct) << "failed to start async op: " << cpp_strerror(r) << dendl;
./librbd/operation/MigrateRequest.cc:    lderr(cct) << "encountered error: " << cpp_strerror(r) << dendl;
./librbd/operation/MigrateRequest.cc:    lderr(cct) << "failed to migrate objects: " << cpp_strerror(r) << dendl;
./librbd/operation/MetadataSetRequest.cc:    lderr(cct) << "encountered error: " << cpp_strerror(r) << dendl;
./librbd/operation/EnableFeaturesRequest.cc:    lderr(cct) << "encountered error: " << cpp_strerror(r) << dendl;
./librbd/operation/EnableFeaturesRequest.cc:    lderr(cct) << "failed to lock image: " << cpp_strerror(*result) << dendl;
./librbd/operation/EnableFeaturesRequest.cc:    lderr(cct) << "failed to block writes: " << cpp_strerror(*result) << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:    lderr(cct) << "failed to block writes: " << cpp_strerror(*result) << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:    lderr(cct) << "warning: object-map is invalid for snapshot" << dendl;
./librbd/operation/MetadataRemoveRequest.cc:    lderr(cct) << "encountered error: " << cpp_strerror(r) << dendl;
./librbd/operation/SnapshotLimitRequest.cc:    lderr(cct) << "encountered error: " << cpp_strerror(r) << dendl;
./librbd/operation/DisableFeaturesRequest.cc:    lderr(cct) << "encountered error: " << cpp_strerror(r) << dendl;
./librbd/operation/DisableFeaturesRequest.cc:    lderr(cct) << "failed to lock image: " << cpp_strerror(*result) << dendl;
./librbd/operation/DisableFeaturesRequest.cc:    lderr(cct) << "failed to block writes: " << cpp_strerror(*result) << dendl;
./librbd/operation/DisableFeaturesRequest.cc:    lderr(cct) << "failed to lock image: " << cpp_strerror(*result) << dendl;
./librbd/operation/DisableFeaturesRequest.cc:    lderr(cct) << "failed to acquire exclusive lock" << dendl;
./librbd/operation/DisableFeaturesRequest.cc:    lderr(cct) << "failed to remove object map: " << cpp_strerror(*result) << dendl;
./librbd/operation/FlattenRequest.cc:    lderr(cct) << "encountered error: " << cpp_strerror(r) << dendl;
./librbd/operation/FlattenRequest.cc:    lderr(cct) << "flatten encountered an error: " << cpp_strerror(r) << dendl;
./librbd/operation/FlattenRequest.cc:    lderr(cct) << "detach encountered an error: " << cpp_strerror(r) << dendl;
./librbd/operation/SnapshotUnprotectRequest.cc:      lderr(cct) << "encountered error: " << cpp_strerror(r) << dendl;
./librbd/operation/SnapshotUnprotectRequest.cc:    lderr(cct) << "image must support layering" << dendl;
./librbd/operation/SnapshotUnprotectRequest.cc:    lderr(cct) << "snapshot is already unprotected" << dendl;
./librbd/operation/ObjectMapIterate.cc:    lderr(cct) << "missing data pool" << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:      lderr(cct) << "snapshot doesn't exist" << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:    lderr(cct) << "encountered error: " << cpp_strerror(r) << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:        lderr(cct) << "failed to retrieve parent spec" << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:    lderr(cct) << "failed to release snap id: " << cpp_strerror(r) << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:    lderr(cct) << "failed to remove snapshot: " << cpp_strerror(r) << dendl;
./librbd/operation/TrimRequest.cc:    lderr(cct) << "trim encountered an error: " << cpp_strerror(r) << dendl;
./librbd/operation/TrimRequest.cc:    lderr(cct) << "invalid state: " << m_state << dendl;
./librbd/operation/TrimRequest.cc:    lderr(cct) << "missing data pool" << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:    lderr(cct) << "failed to set lock: " << cpp_strerror(r) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:    lderr(cct) << "failed to flush IO: " << cpp_strerror(r) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:    lderr(cct) << "failed to close journal: " << cpp_strerror(r) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:    lderr(cct) << "failed to close object map: " << cpp_strerror(r) << dendl;
./librbd/exclusive_lock/ImageDispatch.cc:      lderr(cct) << "op requires exclusive lock" << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:    lderr(cct) << "failed to refresh image: " << cpp_strerror(r) << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:    lderr(cct) << "failed to open journal: " << cpp_strerror(r) << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:    lderr(cct) << "failed to close journal: " << cpp_strerror(r) << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:    lderr(cct) << "failed to open object map: " << cpp_strerror(r) << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:    lderr(cct) << "failed to close object map: " << cpp_strerror(r) << dendl;
./librbd/managed_lock/BreakRequest.cc:    lderr(m_cct) << "failed to retrieve lockers: " << cpp_strerror(r) << dendl;
./librbd/managed_lock/BreakRequest.cc:    lderr(m_cct) << "attempting to self-blocklist" << dendl;
./librbd/managed_lock/BreakRequest.cc:    lderr(m_cct) << "failed to break lock: " << cpp_strerror(r) << dendl;
./librbd/managed_lock/GetLockerRequest.cc:    lderr(m_cct) << "failed to retrieve lockers: " << cpp_strerror(r) << dendl;
./librbd/managed_lock/ReleaseRequest.cc:    lderr(cct) << "failed to unlock: " << cpp_strerror(r) << dendl;
./librbd/managed_lock/ReacquireRequest.cc:    lderr(cct) << ": failed to update lock: " << cpp_strerror(r) << dendl;
./librbd/managed_lock/AcquireRequest.cc:    lderr(m_cct) << "failed to retrieve lockers: " << cpp_strerror(r) << dendl;
./librbd/managed_lock/AcquireRequest.cc:    lderr(m_cct) << "failed to lock: " << cpp_strerror(r) << dendl;
./librbd/managed_lock/AcquireRequest.cc:    lderr(m_cct) << "failed to break lock : " << cpp_strerror(r) << dendl;
./librbd/io/ObjectRequest.cc:    lderr(image_ctx->cct) << "invalid snap ids: " << m_snap_ids << dendl;
./librbd/io/ReadResult.cc:        lderr(cct) << "Merged extents length is less than expected" << dendl;
./librbd/io/ReadResult.cc:      lderr(cct) << "Merged extents length is greater than expected" << dendl;
./librbd/io/CopyupRequest.cc:    lderr(cct) << "error reading from parent: " << cpp_strerror(r) << dendl;
./librbd/io/AioCompletion.cc:        lderr(cct) << "completed invalid aio_type: " << aio_type << dendl;
./librbd/io/AioCompletion.cc:    lderr(cct) << cpp_strerror(r) << dendl;
./librbd/mirror/snapshot/RemoveImageStateRequest.cc:    lderr(cct) << "failed to decode image state object header" << dendl;
./librbd/mirror/snapshot/UnlinkPeerRequest.cc:    lderr(cct) << "failed to refresh image: " << cpp_strerror(r) << dendl;
./librbd/mirror/snapshot/UnlinkPeerRequest.cc:    lderr(cct) << "not mirror snapshot (snap_id=" << m_snap_id << ")" << dendl;
./librbd/mirror/snapshot/UnlinkPeerRequest.cc:    lderr(cct) << "failed to unlink peer: " << cpp_strerror(r) << dendl;
./librbd/mirror/snapshot/UnlinkPeerRequest.cc:    lderr(cct) << "failed to notify update: " << cpp_strerror(r) << dendl;
./librbd/mirror/snapshot/UnlinkPeerRequest.cc:    lderr(cct) << "failed to notify update: " << cpp_strerror(r) << dendl;
./librbd/mirror/snapshot/UnlinkPeerRequest.cc:    lderr(cct) << "failed to remove snapshot: " << cpp_strerror(r) << dendl;
./librbd/mirror/snapshot/CreateNonPrimaryRequest.cc:    lderr(cct) << "failed to refresh image: " << cpp_strerror(r) << dendl;
./librbd/mirror/snapshot/CreateNonPrimaryRequest.cc:    lderr(cct) << "snapshot based mirroring is not enabled" << dendl;
./librbd/mirror/snapshot/PromoteRequest.cc:    lderr(cct) << "cannot promote" << dendl;
./librbd/mirror/snapshot/PromoteRequest.cc:      lderr(cct) << "failed to acquire exclusive lock" << dendl;
./librbd/mirror/snapshot/PromoteRequest.cc:    lderr(cct) << "failed to rollback: " << cpp_strerror(r) << dendl;
./librbd/mirror/snapshot/CreatePrimaryRequest.cc:    lderr(cct) << "no mirror tx peers configured for the pool" << dendl;
./librbd/mirror/snapshot/CreatePrimaryRequest.cc:    lderr(cct) << "failed to refresh image: " << cpp_strerror(r) << dendl;
./librbd/mirror/snapshot/CreatePrimaryRequest.cc:    lderr(cct) << "failed to unlink peer: " << cpp_strerror(r) << dendl;
./librbd/mirror/snapshot/ImageMeta.cc:    lderr(m_image_ctx->cct) << "invalid image-meta JSON received" << dendl;
./librbd/mirror/snapshot/GetImageStateRequest.cc:      lderr(cct) << "failed to decode image state object header" << dendl;
./librbd/mirror/snapshot/GetImageStateRequest.cc:      lderr(cct) << "failed to decode image state" << dendl;
./librbd/mirror/snapshot/Utils.cc:          lderr(cct) << "cannot rollback" << dendl;
./librbd/mirror/DemoteRequest.cc:    lderr(cct) << "mirroring is not currently enabled" << dendl;
./librbd/mirror/DemoteRequest.cc:    lderr(cct) << "image is not primary" << dendl;
./librbd/mirror/DemoteRequest.cc:      lderr(cct) << "exclusive lock is not active" << dendl;
./librbd/mirror/DemoteRequest.cc:    lderr(cct) << "failed to lock image: " << cpp_strerror(r) << dendl;
./librbd/mirror/DemoteRequest.cc:    lderr(cct) << "failed to acquire exclusive lock" << dendl;
./librbd/mirror/DemoteRequest.cc:    lderr(cct) << "unknown image mirror mode: " << m_mirror_image.mode << dendl;
./librbd/mirror/DemoteRequest.cc:    lderr(cct) << "failed to demote image: " << cpp_strerror(r) << dendl;
./librbd/mirror/DisableRequest.cc:    lderr(cct) << "unknown image mirror mode: " << m_mirror_image.mode << dendl;
./librbd/mirror/DisableRequest.cc:    lderr(cct) << "failed to promote image: " << cpp_strerror(*result) << dendl;
./librbd/mirror/DisableRequest.cc:    lderr(cct) << "failed to refresh image: " << cpp_strerror(*result) << dendl;
./librbd/mirror/DisableRequest.cc:      lderr(cct) << "failed to decode client data" << dendl;
./librbd/mirror/PromoteRequest.cc:    lderr(cct) << "mirroring is not currently enabled" << dendl;
./librbd/mirror/PromoteRequest.cc:    lderr(cct) << "image is already primary" << dendl;
./librbd/mirror/PromoteRequest.cc:    lderr(cct) << "image is still primary within a remote cluster" << dendl;
./librbd/mirror/PromoteRequest.cc:    lderr(cct) << "unknown image mirror mode: " << m_mirror_image.mode << dendl;
./librbd/mirror/EnableRequest.cc:      lderr(m_cct) << "invalid current image mirror mode" << dendl;
./librbd/mirror/EnableRequest.cc:      lderr(m_cct) << "currently disabling" << dendl;
./librbd/mirror/EnableRequest.cc:    lderr(m_cct) << "last journal tag not owned by local cluster" << dendl;
./librbd/mirror/EnableRequest.cc:    lderr(m_cct) << "failed to open image: " << cpp_strerror(r) << dendl;
./librbd/mirror/EnableRequest.cc:    lderr(m_cct) << "failed to close image: " << cpp_strerror(r) << dendl;
./librbd/object_map/CreateRequest.cc:  lderr(cct) << "image size not compatible with object map" << dendl;
./librbd/object_map/Request.cc:    lderr(cct) << "invalid state: " << m_state << dendl;
./librbd/object_map/DiffRequest.cc:    lderr(cct) << "failed to load object map: " << oid << dendl;
./librbd/object_map/InvalidateRequest.cc:  lderr(cct) << this << " invalidating object map in-memory" << dendl;
./librbd/object_map/InvalidateRequest.cc:  lderr(cct) << this << " invalidating object map on-disk" << dendl;
./librbd/object_map/InvalidateRequest.cc:  lderr(cct) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/object_map/RefreshRequest.cc:    lderr(cct) << "object map corrupt on-disk: " << oid << dendl;
./librbd/object_map/RefreshRequest.cc:    lderr(cct) << "failed to load object map: " << oid << dendl;
./librbd/object_map/RefreshRequest.cc:  lderr(cct) << "object map too large: " << m_object_count << dendl;
./librbd/image/CreateRequest.cc:    lderr(cct) << "librbd does not support requested features." << dendl;
./librbd/image/CreateRequest.cc:    lderr(cct) << "cannot use internally controlled features" << dendl;
./librbd/image/CreateRequest.cc:    lderr(cct) << "cannot use fast diff without object map" << dendl;
./librbd/image/CreateRequest.cc:    lderr(cct) << "cannot use object map without exclusive lock" << dendl;
./librbd/image/CreateRequest.cc:    lderr(cct) << "cannot use journaling without exclusive lock" << dendl;
./librbd/image/CreateRequest.cc:    lderr(cct) << "stripe unit is not a factor of the object size" << dendl;
./librbd/image/CreateRequest.cc:    lderr(cct) << "stripe unit must be at least 512 bytes" << dendl;
./librbd/image/CreateRequest.cc:    lderr(cct) << "image size not compatible with object map" << dendl;
./librbd/image/CreateRequest.cc:    lderr(cct) << "order must be in the range [12, 25]" << dendl;
./librbd/image/CreateRequest.cc:      lderr(m_cct) << "data pool " << m_data_pool << " does not exist" << dendl;
./librbd/image/CreateRequest.cc:    lderr(m_cct) << "pool does not support RBD images" << dendl;
./librbd/image/CreateRequest.cc:    lderr(m_cct) << "failed to validate pool: " << cpp_strerror(r) << dendl;
./librbd/image/CreateRequest.cc:    lderr(m_cct) << "object prefix '" << oss.str() << "' too large" << dendl;
./librbd/image/CreateRequest.cc:    lderr(m_cct) << "error writing header: " << cpp_strerror(r) << dendl;
./librbd/image/CreateRequest.cc:      lderr(m_cct) << "Failed to retrieve mirror mode" << dendl;
./librbd/image/OpenRequest.cc:    lderr(cct) << "failed to find snapshot " << m_image_ctx->snap_name << dendl;
./librbd/image/OpenRequest.cc:    lderr(cct) << "failed to close image: " << cpp_strerror(*result) << dendl;
./librbd/image/PreRemoveRequest.cc:      lderr(cct) << "cannot obtain exclusive lock - not removing" << dendl;
./librbd/image/PreRemoveRequest.cc:    lderr(cct) << "image in migration state - not removing" << dendl;
./librbd/image/PreRemoveRequest.cc:    lderr(cct) << "error listing image watchers: " << cpp_strerror(r) << dendl;
./librbd/image/PreRemoveRequest.cc:    lderr(cct) << "image has watchers - not removing" << dendl;
./librbd/image/PreRemoveRequest.cc:    lderr(cct) << "image is in a group - not removing" << dendl;
./librbd/image/SetSnapRequest.cc:      lderr(cct) << "failed to retrieve snapshot parent info" << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "format 2 or later required for clone" << dendl;
./librbd/image/CloneRequest.cc:      lderr(m_cct) << "librbd does not support requested features" << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "failed to open parent image: " << cpp_strerror(r) << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "image to be cloned must be a snapshot" << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "parent image must be in new format" << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "parent image must support layering" << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "unable to locate parent's snapshot" << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "parent snapshot must be protected" << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "cloning image must support layering" << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "rbd image " << m_name << " already exists" << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "error creating child: " << cpp_strerror(r) << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "Error opening new image: " << cpp_strerror(r) << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "failed to attach parent: " << cpp_strerror(r) << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "failed to attach parent: " << cpp_strerror(r) << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "failed to copy metadata: " << cpp_strerror(r) << dendl;
./librbd/image/CloneRequest.cc:    lderr(m_cct) << "couldn't close image: " << cpp_strerror(r) << dendl;
./librbd/image/RemoveRequest.cc:      lderr(m_cct) << "error opening image: " << cpp_strerror(r) << dendl;
./librbd/image/RemoveRequest.cc:    lderr(m_cct) << "error removing header: " << cpp_strerror(r) << dendl;
./librbd/image/RemoveRequest.cc:    lderr(m_cct) << "error removing header: " << cpp_strerror(r) << dendl;
./librbd/image/CloseRequest.cc:    lderr(cct) << "failed to flush IO: " << cpp_strerror(r) << dendl;
./librbd/image/CloseRequest.cc:    lderr(cct) << "error closing parent image: " << cpp_strerror(r) << dendl;
./librbd/image/CloseRequest.cc:    lderr(cct) << "error flushing image watcher: " << cpp_strerror(r) << dendl;
./librbd/image/ValidatePoolRequest.cc:    lderr(m_cct) << "failed to read RBD info: " << cpp_strerror(r) << dendl;
./librbd/image/ValidatePoolRequest.cc:    lderr(m_cct) << "pool missing required overwrite support" << dendl;
./librbd/image/ValidatePoolRequest.cc:    lderr(m_cct) << "failed to write RBD info: " << cpp_strerror(r) << dendl;
./librbd/image/ValidatePoolRequest.cc:    lderr(m_cct) << "pool missing required overwrite support" << dendl;
./librbd/image/RefreshRequest.cc:      lderr(cct) << "image being migrated" << dendl;
./librbd/image/RefreshRequest.cc:    lderr(cct) << "v1 header too small" << dendl;
./librbd/image/RefreshRequest.cc:      lderr(cct) << "unrecognized v1 header" << dendl;
./librbd/image/RefreshRequest.cc:    lderr(cct) << "v1 image snap context is invalid" << dendl;
./librbd/image/RefreshRequest.cc:    lderr(cct) << "Image uses unsupported features: " << unsupported << dendl;
./librbd/image/RefreshRequest.cc:    lderr(cct) << "image snap context is invalid!" << dendl;
./librbd/image/AttachChildRequest.cc:      lderr(m_cct) << "couldn't add child: " << cpp_strerror(r) << dendl;
./librbd/image/AttachChildRequest.cc:    lderr(m_cct) << "validate protected failed" << dendl;
./librbd/image/AttachChildRequest.cc:    lderr(m_cct) << "couldn't remove child: " << cpp_strerror(r) << dendl;
./librbd/image/AttachChildRequest.cc:    lderr(m_cct) << "failed to enable clone v2: " << cpp_strerror(r) << dendl;
./librbd/trash/RemoveRequest.cc:    lderr(m_cct) << "error removing trash entry: " << cpp_strerror(r) << dendl;
./librbd/Watcher.cc:      lderr(m_cct) << "re-registering watch after error" << dendl;
./librbd/Watcher.cc:  lderr(m_cct) << "handle=" << handle << ": " << cpp_strerror(err) << dendl;
./librbd/Watcher.cc:      lderr(m_cct) << "client blocklisted" << dendl;
./librbd/Watcher.cc:      lderr(m_cct) << "failed to rewatch: " << cpp_strerror(r) << dendl;
./librbd/Watcher.cc:      lderr(m_cct) << "re-registering watch after error" << dendl;
./librbd/deep_copy/ImageCopyRequest.cc:    lderr(m_cct) << "failed to map snapshots within boundary" << dendl;
./librbd/deep_copy/ImageCopyRequest.cc:      lderr(m_cct) << "object copy failed: " << cpp_strerror(r) << dendl;
./librbd/deep_copy/SnapshotCreateRequest.cc:    lderr(m_cct) << "failed to set head: " << cpp_strerror(r) << dendl;
./librbd/deep_copy/SnapshotCreateRequest.cc:    lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/deep_copy/SnapshotCreateRequest.cc:    lderr(m_cct) << "failed to locate snap: " << m_snap_name << dendl;
./librbd/deep_copy/SnapshotCreateRequest.cc:    lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:    lderr(m_cct) << "source image parent spec mismatch" << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:    lderr(m_cct) << "destination image parent spec mismatch" << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:    lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:    lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:    lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:    lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:    lderr(m_cct) << "failed to set head: " << cpp_strerror(r) << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:      lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:    lderr(m_cct) << "failed to list snaps: " << cpp_strerror(r) << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:    lderr(m_cct) << "object map is not initialized" << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:    lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:    lderr(m_cct) << "failed to update object map: " << cpp_strerror(r) << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:    lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/deep_copy/MetadataCopyRequest.cc:    lderr(m_cct) << "failed to retrieve metadata: " << cpp_strerror(r) << dendl;
./librbd/deep_copy/MetadataCopyRequest.cc:    lderr(m_cct) << "failed to set metadata: " << cpp_strerror(r) << dendl;
./librbd/deep_copy/SetHeadRequest.cc:    lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/deep_copy/SetHeadRequest.cc:    lderr(m_cct) << "failed to update image size: " << cpp_strerror(r) << dendl;
./librbd/deep_copy/SetHeadRequest.cc:    lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/deep_copy/SetHeadRequest.cc:    lderr(m_cct) << "failed to remove parent: " << cpp_strerror(r) << dendl;
./librbd/deep_copy/SetHeadRequest.cc:    lderr(m_cct) << "lost exclusive lock" << dendl;
./librbd/deep_copy/SetHeadRequest.cc:    lderr(m_cct) << "failed to attach parent: " << cpp_strerror(r) << dendl;
./client/Inode.cc:	lderr(client->cct) << "put_cap_ref " << ccap_string(c) << " went negative on " << *this << dendl;
./client/Client.cc:      lderr(cct) << "Invalid metadata keyval pair: '" << i << "'" << dendl;
./client/Client.cc:      lderr(cct) << "mds." << from << " rejected us (" << error_str << ")" << dendl;
./client/Client.cc:    lderr(cct) << "I was blocklisted at osd epoch " << epoch << dendl;
./client/Client.cc:	lderr(cct) << __func__ << " removing unsafe request " << req->get_tid() << dendl;
./client/Client.cc:      lderr(cct) << "failed to invalidate cache for " << *in << dendl;
./client/Client.cc:      lderr(cct) << __func__ << " still has dirty|flushing caps on " << *in << dendl;
./client/Client.cc:	  lderr(cct) << __func__ << " still has dirty data on " << *in << dendl;
./client/Client.cc:      lderr(cct) << "failed to remount for kernel dentry trimming; quitting!" << dendl;
./client/Client.cc:      lderr(cct) << "FSMap: " << *fsmap << dendl;
./client/Client.cc:      lderr(cct) << __func__ << ": no MDS daemons found" << dendl;
./client/Client.cc:      lderr(cct) << "FSMap: " << *fsmap << dendl;
./client/Client.cc:      lderr(cct) << __func__ << ": no MDS daemons found by name `" << mds_spec << "'" << dendl;
./client/Client.cc:      lderr(cct) << "FSMap: " << *fsmap << dendl;
./client/Client.cc:    lderr(cct) << "Failed to learn FSMap version: " << ec << dendl;
./client/Client.cc:    lderr(cct) << "authentication failed: " << cpp_strerror(r) << dendl;
./client/Client.cc:    lderr(cct) << "mdsmap subscription failed: " << cpp_strerror(r) << dendl;
./client/Client.cc:    lderr(cct) << "mdsmap subscription failed: " << cpp_strerror(r) << dendl;
./client/fuse_ll.cc:    derr << "pthread_key_create failed." << dendl;
./client/fuse_ll.cc:  derr << "init, newargv = " << newargv << " newargc=" << newargc << dendl;
./client/fuse_ll.cc:    derr << "fuse_parse_cmdline failed." << dendl;
./client/fuse_ll.cc:  derr << "init, args.argv = " << args.argv << " args.argc=" << args.argc << dendl;
./client/fuse_ll.cc:    derr << "fuse_parse_conn_info_opts failed" << dendl;
./client/fuse_ll.cc:    derr << "fuse_session_new failed" << dendl;
./client/fuse_ll.cc:    derr << "fuse_mount(mountpoint=" << mountpoint << ") failed." << dendl;
./client/fuse_ll.cc:    derr << "fuse_lowlevel_new failed" << dendl;
./client/fuse_ll.cc:    derr << "fuse_set_signal_handlers failed" << dendl;
./client/fuse_ll.cc:    derr << "fuse_session_mount failed" << dendl;
./libcephsqlite.cc:      lderr(cct) << "cannot initialize RADOS: " << cpp_strerror(rc) << dendl;
./libcephsqlite.cc:      lderr(cct) << "cannot connect: " << cpp_strerror(rc) << dendl;
./libcephsqlite.cc:    lderr(cct) << "API violation: must have sqlite3 init libcephsqlite" << dendl;
./libcephsqlite.cc:    lderr(cct) << "API violation: must have sqlite3 init libcephsqlite" << dendl;
./objclass/class_api.cc:    derr << "cannot get random bytes: " << ret << dendl;
./objclass/class_api.cc:    derr << "ceph_armor failed" << dendl;
./kv/MemDB.cc:	derr << __func__ << " mkdir failed: " << ec.message() << dendl;
./kv/LevelDBStore.cc:    derr << "Compacting leveldb store..." << dendl;
./kv/LevelDBStore.cc:    derr << "Finished compacting leveldb store" << dendl;
./kv/RocksDBStore.cc:        derr << status.ToString() << dendl;
./kv/RocksDBStore.cc:    derr << "unrecognized rocksdb_cache_type '" << cache_type << "'" << dendl;
./kv/RocksDBStore.cc:      derr << __func__ << " create_shards failed error=" << r << dendl;
./kv/RocksDBStore.cc:      derr << __func__ << " cannot write to " << sharding_def_file << dendl;
./kv/RocksDBStore.cc:      derr << __func__ << " cannot read from " << sharding_def_file << dendl;
./kv/RocksDBStore.cc:      derr << __func__ << " error = '" << status.getState() << "'" << dendl;
./kv/RocksDBStore.cc:	derr << __func__ << " error = '" << status.getState() << "'" << dendl;
./kv/RocksDBStore.cc:	  derr << __func__ << " invalid size: '" << it->second << "'" << dendl;
./kv/RocksDBStore.cc:	  derr << __func__ << " invalid high_pri (float): '" << it->second << "'" << dendl;
./kv/RocksDBStore.cc:	derr << __func__ << " error = '" << status.getState() << "'" << dendl;
./kv/RocksDBStore.cc:      derr << status.ToString() << dendl;
./kv/RocksDBStore.cc:	derr << __func__ << " missing column families: " << missing_cfs_shard << dendl;
./kv/RocksDBStore.cc:	derr << status.ToString() << dendl;
./kv/RocksDBStore.cc:	derr << status.ToString() << dendl;
./kv/RocksDBStore.cc:    derr << "Compacting rocksdb store..." << dendl;
./kv/RocksDBStore.cc:    derr << "Finished compacting rocksdb store" << dendl;
./kv/RocksDBStore.cc:      derr << __func__ << " cannot write to " << sharding_def_file << dendl;
./kv/RocksDBStore.cc:      derr << __func__ << " cannot write to " << sharding_recreate << dendl;
./kv/RocksDBStore.cc:      derr << __func__ << " cannot finalize repair" << dendl;
./kv/RocksDBStore.cc:      derr << __func__ << " cannot write to " << sharding_def_file << dendl;
./kv/RocksDBStore.cc:    derr << "Unable to list column families: " << status.ToString() << dendl;
./kv/RocksDBStore.cc:      derr << __func__ << " failure parsing column options: " << options << dendl;
./kv/RocksDBStore.cc:    derr << status.ToString() << dendl;
./kv/RocksDBStore.cc:      derr << __func__ << " failure parsing column options: " << options << dendl;
./kv/RocksDBStore.cc:	derr << "missing handle for column " << col.first << " shard " << i << dendl;
./kv/RocksDBStore.cc:      derr << __func__ << " Failed to drop column: "  << name << dendl;
./kv/RocksDBStore.cc:      derr << "Error processing column " << name << dendl;
./kv/RocksDBStore.cc:    derr << __func__ << " cannot write to " << sharding_def_file << dendl;
./rgw/rgw_rest_realm.cc:    lderr(cct) << "failed to decode period" << dendl;
./rgw/rgw_rest_realm.cc:      lderr(cct) << "master zone failed to commit period" << dendl;
./rgw/rgw_rest_realm.cc:    lderr(cct) << "failed to store period " << period.get_id() << dendl;
./rgw/rgw_rest_realm.cc:    lderr(cct) << "failed to set latest epoch" << dendl;
./rgw/rgw_rest_realm.cc:      lderr(cct) << "failed to update realm's current period" << dendl;
./rgw/rgw_rest_realm.cc:    lderr(store->ctx()) << "failed to list realms" << dendl;
./rgw/rgw_orphan.cc:    lderr(store->ctx()) << "ERROR: could not decode buffer" << dendl;
./rgw/rgw_orphan.cc:        lderr(store->ctx()) << "ERROR: could not decode buffer" << dendl;
./rgw/rgw_orphan.cc:    lderr(store->ctx()) << "ERROR: " << __func__ << "(" << oid << ") returned ret=" << ret << dendl;
./rgw/rgw_orphan.cc:    lderr(store->ctx()) << "ERROR: failed to read state ret=" << r << dendl;
./rgw/rgw_orphan.cc:      lderr(store->ctx()) << "ERROR: failed to write state ret=" << r << dendl;
./rgw/rgw_orphan.cc:      lderr(store->ctx()) << "ERROR: job not found" << dendl;
./rgw/rgw_orphan.cc:    lderr(store->ctx()) << __func__ << ": rgw_init_ioctx() returned ret=" << ret << dendl;
./rgw/rgw_orphan.cc:    lderr(store->ctx()) << "ERROR: can't get key: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_orphan.cc:      lderr(store->ctx()) << "ERROR: lists_keys_next(): " << cpp_strerror(-ret) << dendl;
./rgw/rgw_orphan.cc:          lderr(store->ctx()) << __func__ << ": ERROR: log_oids() returned ret=" << ret << dendl;
./rgw/rgw_orphan.cc:    lderr(store->ctx()) << __func__ << ": ERROR: log_oids() returned ret=" << ret << dendl;
./rgw/rgw_orphan.cc:      lderr(store->ctx()) << "ERROR: stat_async() returned error: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_orphan.cc:    lderr(store->ctx()) << "ERROR: handle_stat_response() returned error: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_orphan.cc:        lderr(store->ctx()) << "ERROR: stat_async() returned error: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_orphan.cc:            lderr(store->ctx()) << "ERROR: stat_async() returned error: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_orphan.cc:        lderr(store->ctx()) << "ERROR: stat_async() returned error: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_orphan.cc:        lderr(store->ctx()) << __func__ << ": ERROR: read_entries() oid=" << oid << " returned ret=" << ret << dendl;
./rgw/rgw_orphan.cc:    lderr(store->ctx()) << __func__ << ": rgw_init_ioctx() returned ret=" << ret << dendl;
./rgw/rgw_orphan.cc:          lderr(store->ctx()) << "ERROR: ioctx.stat(" << key << ") returned ret=" << r << dendl;
./rgw/rgw_orphan.cc:        lderr(store->ctx()) << __func__ << ": ERROR: failed to save state, ret=" << r << dendl;
./rgw/rgw_orphan.cc:        lderr(store->ctx()) << __func__ << ": ERROR: build_all_objs_index returned ret=" << r << dendl;
./rgw/rgw_orphan.cc:        lderr(store->ctx()) << __func__ << ": ERROR: failed to save state, ret=" << r << dendl;
./rgw/rgw_orphan.cc:        lderr(store->ctx()) << __func__ << ": ERROR: build_all_objs_index returned ret=" << r << dendl;
./rgw/rgw_orphan.cc:        lderr(store->ctx()) << __func__ << ": ERROR: failed to save state, ret=" << r << dendl;
./rgw/rgw_orphan.cc:        lderr(store->ctx()) << __func__ << ": ERROR: build_all_objs_index returned ret=" << r << dendl;
./rgw/rgw_orphan.cc:        lderr(store->ctx()) << __func__ << ": ERROR: failed to save state, ret=" << r << dendl;
./rgw/rgw_orphan.cc:        lderr(store->ctx()) << __func__ << ": ERROR: build_all_objs_index returned ret=" << r << dendl;
./rgw/rgw_orphan.cc:    lderr(store->ctx()) << "ERROR: can't get key: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_orphan.cc:      lderr(store->ctx()) << "ERROR: lists_keys_next(): " << cpp_strerror(-ret) << dendl;
./rgw/rgw_orphan.cc:          lderr(store->ctx()) << __func__ << ": ERROR: log_oids() returned ret=" << ret << dendl;
./rgw/rgw_orphan.cc:    lderr(store->ctx()) << __func__ << ": ERROR: log_oids() returned ret=" << ret << dendl;
./rgw/rgw_http_client_curl.cc:  derr << "WARNING: libcurl doesn't support curl_multi_wait()" << dendl;
./rgw/rgw_http_client_curl.cc:  derr << "WARNING: cross zone / region transfer performance may be affected" << dendl;
./rgw/rgw_json_enc.cc:    derr << "old format " << dendl;
./rgw/rgw_cr_tools.cc:    lderr(cct) << "ERROR: failed to get object: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_cr_tools.cc:    lderr(cct) << "ERROR: lifecycle object is not initialized!" << dendl;
./rgw/rgw_cr_tools.cc:    lderr(cct) << "ERROR: failed to set lifecycle on bucke: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_admin.cc:    lderr(store->ctx()) << "ERROR: failed to stat object, returned error: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_admin.cc:        derr << "ERROR: could not find remote sync shard status for shard_id=" << shard_id << dendl;
./rgw/rgw_admin.cc:      derr << "ERROR: failed to fetch master next positions (" << cpp_strerror(-ret) << ")" << dendl;
./rgw/rgw_admin.cc:      derr << "ERROR: could not find remote sync shard status for shard_id=" << shard_id << dendl;
./rgw/rgw_admin.cc:      derr << "ERROR: failed to fetch next positions (" << cpp_strerror(-ret) << ")" << dendl;
./rgw/rgw_admin.cc:    lderr(store->ctx()) << __func__ << "(): missing source bucket" << dendl;
./rgw/rgw_admin.cc:    lderr(store->ctx()) << "failed to read source bucket info: " << cpp_strerror(r) << dendl;
./rgw/rgw_admin.cc:    lderr(store->ctx()) << "failed to read bucket sync status: " << cpp_strerror(r) << dendl;
./rgw/rgw_admin.cc:    lderr(store->ctx()) << "failed to read remote log: " << cpp_strerror(r) << dendl;
./rgw/rgw_admin.cc:    lderr(store->ctx()) << "ERROR: failed to get policy handler for bucket (" << info.bucket << "): r=" << r << ": " << cpp_strerror(-r) << dendl;
./rgw/rgw_admin.cc:    lderr(store->ctx()) << "ERROR: failed to get policy handler for bucket (" << info.bucket << "): r=" << r << ": " << cpp_strerror(-r) << dendl;
./rgw/rgw_admin.cc:      lderr(store->ctx()) << "No connection to zone " << z->second.name << dendl;
./rgw/rgw_admin.cc:      lderr(cct) << "ERROR: failed to init sync module instance, ret=" << ret << dendl;
./rgw/rgw_admin.cc:      lderr(store->ctx()) << "bucket sync checkpoint failed: " << cpp_strerror(ret) << dendl;
./rgw/rgw_rest.cc:        lderr(s->cct) << "Error reading IAM User Policy: " << e.what() << dendl;
./rgw/services/svc_notify.cc:    lderr(cct) << "ERROR: failed to initialize watch: " << cpp_strerror(-ret) << dendl;
./rgw/services/svc_bi_rados.cc:      lderr(cct) << "ERROR: " << __func__ << ": cls_rgw_get_bucket_resharding() returned ret=" << ret << dendl;
./rgw/services/svc_bi_rados.cc:      lderr(cct) << "ERROR: failed writing bilog (bucket=" << info.bucket << "); ret=" << ret << dendl;
./rgw/services/svc_zone.cc:    lderr(cct) << "failed reading zone info: ret "<< ret << " " << cpp_strerror(-ret) << dendl;
./rgw/services/svc_zone.cc:      lderr(cct) << "Cannot find zone id=" << zone_params->get_id() << " (name=" << zone_params->get_name() << ")" << dendl;
./rgw/services/svc_zone.cc:    lderr(cct) << "Cannot find zone id=" << zone_params->get_id() << " (name=" << zone_params->get_name() << ")" << dendl;
./rgw/services/svc_zone.cc:      lderr(cct) << "ERROR: could not initialize zone policy handler for zone=" << ziter.second.name << dendl;
./rgw/services/svc_zone.cc:    lderr(cct) << "ERROR: tier type not found: " << zone_public_config->tier_type << dendl;
./rgw/services/svc_sync_modules.cc:    lderr(cct) << "ERROR: failed to start sync module instance, ret=" << ret << dendl;
./rgw/services/svc_config_key_rados.cc:  lderr(ctx()) << __func__ << "(): WARNING: " << s << dendl;
./rgw/librgw.cc:      derr << "Initialization timeout, failed to initialize" << dendl;
./rgw/librgw.cc:      derr << "Couldn't init storage provider (RADOS)" << dendl;
./rgw/librgw.cc:      derr << "ERROR: failed initializing frontend" << dendl;
./rgw/librgw.cc:      derr << "ERROR: failed to register to service map: " << cpp_strerror(-r) << dendl;
./rgw/librgw.cc:    derr << "shutting down" << dendl;
./rgw/rgw_asio_frontend.cc:      lderr(ctx()) << "Got invalid scheduler type for beast, defaulting to throttler" << dendl;
./rgw/rgw_asio_frontend.cc:      lderr(ctx()) << "failed to parse port=" << i->second << dendl;
./rgw/rgw_asio_frontend.cc:      lderr(ctx()) << "failed to parse endpoint=" << i->second << dendl;
./rgw/rgw_asio_frontend.cc:      lderr(ctx()) << "failed to open socket: " << ec.message() << dendl;
./rgw/rgw_asio_frontend.cc:    lderr(ctx()) << "Unable to listen at any endpoints" << dendl;
./rgw/rgw_asio_frontend.cc:    lderr(ctx()) << "bad " << type << " config value" << dendl;
./rgw/rgw_asio_frontend.cc:    lderr(ctx()) << type << " was not found: " << name << dendl;
./rgw/rgw_asio_frontend.cc:    lderr(ctx()) << "no ssl_certificate configured for ssl_private_key" << dendl;
./rgw/rgw_asio_frontend.cc:      lderr(ctx()) << "no ssl_certificate configured for ssl_port" << dendl;
./rgw/rgw_asio_frontend.cc:      lderr(ctx()) << "failed to parse ssl_port=" << i->second << dendl;
./rgw/rgw_asio_frontend.cc:      lderr(ctx()) << "no ssl_certificate configured for ssl_endpoint" << dendl;
./rgw/rgw_asio_frontend.cc:      lderr(ctx()) << "failed to parse ssl_endpoint=" << i->second << dendl;
./rgw/rgw_crypt.cc:lderr(cct) << "ERROR: can't get nfc instance, error = " << status << dendl;
./rgw/rgw_crypt.cc:	lderr(s->cct) << "ERROR: can't add default value to context" << dendl;
./rgw/rgw_crypt.cc:    lderr(cct) << __func__ << " cannot load crypto accelerator of type " << crypto_accel_type << dendl;
./rgw/rgw_civetweb.cc:      lderr(cct) << "client supplied malformatted headers" << dendl;
./rgw/rgw_civetweb.cc:    lderr(cct) << "init_env: bug: invalid port number" << dendl;
./rgw/rgw_realm_watcher.cc:    lderr(cct) << "Failed to decode realm notifications." << dendl;
./rgw/rgw_realm_watcher.cc:  lderr(cct) << "RGWRealmWatcher::handle_error oid=" << watch_oid << " err=" << err << dendl;
./rgw/rgw_rest_log.cc:      lderr(s->cct) << "ERROR: rgw_bucket_sync_status() on pipe=" << pipe << " returned ret=" << op_ret << dendl;
./rgw/rgw_rest_log.cc:    lderr(s->cct) << "could not get bucket sync policy handler (r=" << op_ret << ")" << dendl;
./rgw/rgw_rest_log.cc:      lderr(s->cct) << "ERROR: rgw_bucket_sync_status() on pipe=" << pipe << " returned ret=" << r << dendl;
./rgw/rgw_rest_log.cc:        lderr(s->cct) << "ERROR: different number of shards for sync status of buckets syncing from the same source: status.size()= " << status.size() << " current_status.size()=" << current_status.size() << dendl;
./rgw/rgw_bucket.cc:              lderr(store->ctx()) << "ERROR: could not drain handles as aio completion returned with " << ret << dendl;
./rgw/rgw_bucket.cc:            lderr(store->ctx()) << "ERROR: delete obj aio failed with " << ret << dendl;
./rgw/rgw_bucket.cc:          lderr(store->ctx()) << "ERROR: delete obj aio failed with " << ret << dendl;
./rgw/rgw_bucket.cc:          lderr(store->ctx()) << "ERROR: could not drain handles as aio completion returned with " << ret << dendl;
./rgw/rgw_bucket.cc:    lderr(store->ctx()) << "ERROR: could not drain handles as aio completion returned with " << ret << dendl;
./rgw/rgw_bucket.cc:    lderr(store->ctx()) << "ERROR: could not remove bucket " << bucket << dendl;
./rgw/rgw_bucket.cc:      lderr(store->ctx()) << "ERROR failed to list objects in the bucket" << dendl;
./rgw/rgw_bucket.cc:    lderr(store->ctx()) << "failed to initialize bucket" << dendl;
./rgw/rgw_bucket.cc:      lderr(svc.bucket->ctx()) << "could not unlink bucket=" << entry << " owner=" << be.owner << dendl;
./rgw/rgw_bucket.cc:      lderr(svc.bucket->ctx()) << "could not delete bucket=" << entry << dendl;
./rgw/rgw_bucket.cc:        lderr(cct) << "could not unlink bucket=" << entry << " owner=" << be.owner << dendl;
./rgw/rgw_bucket.cc:        lderr(cct) << "could not delete bucket=" << entry << dendl;
./rgw/rgw_reshard.cc:      derr << "ERROR: reshard rados operation failed: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_reshard.cc:      derr << "ERROR: failed to store entries in target bucket shard (bs=" << bs.bucket << "/" << bs.shard_id << ") error=" << cpp_strerror(-ret) << dendl;
./rgw/rgw_reshard.cc:        derr << "ERROR: target_shards[" << shard->get_num_shard() << "].flush() returned error: " << cpp_strerror(-r) << dendl;
./rgw/rgw_reshard.cc:        derr << "ERROR: target_shards[" << shard->get_num_shard() << "].wait_all_aio() returned error: " << cpp_strerror(-r) << dendl;
./rgw/rgw_reshard.cc:	derr << "ERROR: bi_list(): " << cpp_strerror(-ret) << dendl;
./rgw/rgw_reshard.cc:	  lderr(store->ctx()) << "ERROR: get_target_shard_id() returned ret=" << ret << dendl;
./rgw/rgw_reshard.cc:	    lderr(store->ctx()) << "Error renewing bucket lock: " << ret << dendl;
./rgw/rgw_reshard.cc:    lderr(store->ctx()) << "ERROR: failed to reshard" << dendl;
./rgw/rgw_reshard.cc:    lderr(store->ctx()) << "ERROR: failed to add entry to reshard log, oid=" << logshard_oid << " tenant=" << entry.tenant << " bucket=" << entry.bucket_name << dendl;
./rgw/rgw_reshard.cc:    lderr(store->ctx()) << "ERROR: failed to remove entry from reshard log, oid=" << logshard_oid << " tenant=" << entry.tenant << " bucket=" << entry.bucket_name << dendl;
./rgw/rgw_reshard.cc:    lderr(store->ctx()) << "ERROR: failed to clear bucket resharding, bucket_instance_oid=" << bucket_instance_oid << dendl;
./rgw/rgw_period_puller.cc:    lderr(conn->get_ctx()) << "request failed: " << cpp_strerror(-r) << dendl;
./rgw/rgw_period_puller.cc:      lderr(cct) << "failed to pull period " << period_id << dendl;
./rgw/rgw_period_puller.cc:      lderr(cct) << "failed to store period " << period_id << dendl;
./rgw/rgw_kmip_client.cc:    lderr(cct) << "kmip process failed, " << ret << dendl;
./rgw/rgw_kmip_client.cc:    lderr(cct) << "kmip send failed, " << r << dendl;
./rgw/rgw_period_history.cc:      lderr(cct) << "reached a period with an empty predecessor id" << dendl;
./rgw/rgw_sal_rados.cc:    lderr(store->ctx()) << "ERROR: unable to remove notifications from bucket. ret=" << ps_ret << dendl;
./rgw/rgw_obj_manifest.cc:    derr << "ERROR: manifest->get_rule() could not find rule" << dendl;
./rgw/rgw_kmip_client_impl.cc:  lderr(cct) << es << dendl;
./rgw/rgw_kmip_client_impl.cc:    lderr(cct) << "BIO_new_ssl_connect failed" << dendl;
./rgw/rgw_kmip_client_impl.cc:    lderr(cct) << "kmip worker already started" << dendl;
./rgw/rgw_kmip_client_impl.cc:    lderr(cct) << "Missing operation logic op=" << element.operation << dendl;
./rgw/rgw_kmip_client_impl.cc:    lderr(cct) << "Problem sending request to " << what << " " << i << " context error message " << h->kmip_ctx->error_message << dendl;
./rgw/rgw_kmip_client_impl.cc:    lderr(cct) << "Failed to decode " << what << " " << i << " context error message " << h->kmip_ctx->error_message << dendl;
./rgw/rgw_kmip_client_impl.cc:    lderr(cct) << "Failed; weird response count doing " << what << " " << resp_m->batch_count << dendl;
./rgw/rgw_kmip_client_impl.cc:    lderr(cct) << "Failed; result status not success " << rs << dendl;
./rgw/rgw_kmip_client_impl.cc:    lderr(cct) << "Failed; response operation mismatch, got " << req->operation << " expected " << rbi->operation << dendl;
./rgw/rgw_kmip_client_impl.cc:	lderr(cct) << "get: expected symmetric key got " << pld->object_type << dendl;
./rgw/rgw_kmip_client_impl.cc:	lderr(cct) << "get: expected raw key fromat got  " << kp->key_format_type << dendl;
./rgw/rgw_kmip_client_impl.cc:    lderr(cct) << "Missing response logic op=" << element.operation << dendl;
./rgw/rgw_metadata.cc:    lderr(cct) << "failed to decode log entry: " << entry.section << ":" << entry.name<< " ts=" << entry.timestamp << dendl;
./rgw/rgw_period_pusher.cc:    lderr(cct) << "failed to load period for realm " << realm_id << dendl;
./rgw/rgw_period_pusher.cc:    lderr(cct) << "Failed to decode the period: " << e.what() << dendl;
./rgw/rgw_period_pusher.cc:    lderr(cct) << "The new period does not contain my zonegroup!" << dendl;
./rgw/rgw_trim_bilog.cc:        lderr(store->ctx()) << "no handler for notify type " << type << dendl;
./rgw/rgw_trim_bilog.cc:      lderr(store->ctx()) << "Failed to decode notification: " << e.what() << dendl;
./rgw/rgw_compression.cc:    lderr(cct) << "Cannot load compressor of type " << cs_info->compression_type << dendl;
./rgw/rgw_compression.cc:    lderr(cct) << "Cannot load compressor of type " << cs_info->compression_type << dendl;
./rgw/rgw_compression.cc:      lderr(cct) << "Decompression failed with exit code " << cr << dendl;
./rgw/rgw_compression.cc:        lderr(cct) << "handle_data failed with exit code " << r << dendl;
./rgw/rgw_compression.cc:      lderr(cct) << "handle_data failed with exit code " << r << dendl;
./rgw/rgw_coroutine.cc:  lderr(cct) << "ERROR: failed operation: " << op->error_str() << dendl;
./rgw/rgw_coroutine.cc:    lderr(cct) << "ERROR: fail to register admin socket command (r=" << r << ")" << dendl;
./rgw/rgw_etag_verifier.cc:    lderr(cct) << "ERROR: manifest->get_rule() could not find rule" << dendl;
./rgw/rgw_realm_reloader.cc:    lderr(cct) << "ERROR: failed to register to service map: " << cpp_strerror(-r) << dendl;
./rgw/rgw_op.cc:      lderr(s->cct) << "Error reading IAM User Policy: " << e.what() << dendl;
./rgw/rgw_cr_rados.cc:    lderr(store->ctx()) << "ERROR: failed to get ref for (" << obj << ") ret=" << r << dendl;
./rgw/rgw_cr_rados.cc:    lderr(store->ctx()) << "ERROR: failed to get ref for (" << obj << ") ret=" << r << dendl;
./rgw/rgw_cr_rados.cc:    lderr(store->ctx()) << "ERROR: failed to get ref for (" << obj << ") ret=" << r << dendl;
./rgw/rgw_cr_rados.cc:    lderr(store->ctx()) << "ERROR: failed to get ref for (" << obj << ") ret=" << r << dendl;
./rgw/rgw_cr_rados.cc:    lderr(store->ctx()) << "ERROR: failed to get ref for (" << obj << ") ret=" << r << dendl;
./rgw/rgw_cr_rados.cc:    lderr(store->ctx()) << "ERROR: failed to get ref for (" << obj << ") ret=" << r << dendl;
./rgw/rgw_cr_rados.cc:    lderr(cct) << "ERROR: failed to open pool (" << obj.pool.name << ") ret=" << r << dendl;
./rgw/rgw_cr_rados.cc:    lderr(store->ctx()) << "ERROR: failed to get ref for (" << obj << ") ret=" << r << dendl;
./rgw/rgw_datalog.cc:      lderr(cct) << "ERROR: svc.cls->timelog.add() returned " << ret << dendl;
./rgw/rgw_sync.cc:    lderr(store->ctx()) << "no REST connection to master zone" << dendl;
./rgw/rgw_sync.cc:    lderr(store->ctx()) << "ERROR: failed to open log pool (" << store->svc()->zone->get_zone_params().log_pool << " ret=" << r << dendl;
./rgw/rgw_sync.cc:    lderr(store->ctx()) << "ERROR: failed to init remote log, r=" << r << dendl;
./rgw/rgw_sync.cc:    lderr(store->ctx()) << "ERROR: failed to read sync status, r=" << r << dendl;
./rgw/rgw_sync.cc:    lderr(store->ctx()) << "ERROR: fail to fetch master log info (r=" << r << ")" << dendl;
./rgw/rgw_sync.cc:      lderr(store->ctx()) << "ERROR: fail to fetch master log info (r=" << r << ")" << dendl;
./rgw/rgw_sync.cc:    lderr(store->ctx()) << "ERROR: can't sync, mismatch between num shards, master num_shards=" << mdlog_info.num_shards << " local num_shards=" << num_shards << dendl;
./rgw/rgw_data_sync.cc:      lderr(cct) << "ERROR: RGWRunBucketSourcesSyncCR::handle_complete_stack(): stack_id=" << stack_id << " not found! Likely a bug" << dendl;
./rgw/rgw_data_sync.cc:    lderr(conn->get_ctx()) << "failed to fetch remote log markers: " << cpp_strerror(r) << dendl;
./rgw/rgw_data_sync.cc:    lderr(conn->get_ctx()) << "failed to decode remote log markers" << dendl;
./rgw/rgw_loadgen_process.cc:    derr << "ERROR: bucket creation failed" << dendl;
./rgw/rgw_loadgen_process.cc:    derr << "ERROR: bucket creation failed" << dendl;
./rgw/rgw_rados.cc:      lderr(store->ctx()) << "ERROR: failed writing data log" << dendl;
./rgw/rgw_rados.cc:    lderr(cct) << "ERROR: rgw_rados_operate(oid=" << oid << ") returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:    lderr(cct) << "ERROR: returned object size (" << size << ") > HEAD_SIZE (" << HEAD_SIZE << ")" << dendl;
./rgw/rgw_rados.cc:    lderr(cct) << "ERROR: returned object size (" << size << ") != data.length() (" << data.length() << ")" << dendl;
./rgw/rgw_rados.cc:      lderr(cct) << "ERROR: failed to remove original bad object" << dendl;
./rgw/rgw_rados.cc:  lderr(cct) << "ERROR: failed to copy " << src_oid << " -> " << dst_oid << dendl;
./rgw/rgw_rados.cc:          lderr(cct) << "ERROR: copy_rados_obj() on oid=" << oid << " returned r=" << r << dendl;
./rgw/rgw_rados.cc:      lderr(store->ctx()) << "ERROR: failed writing data log" << dendl;
./rgw/rgw_rados.cc:    lderr(store->ctx()) << "ERROR: failed writing data log" << dendl;
./rgw/rgw_rados.cc:    lderr(store->ctx()) << "ERROR: failed writing data log" << dendl;
./rgw/rgw_rados.cc:    lderr(store->ctx()) << "ERROR: failed writing data log" << dendl;
./rgw/rgw_rados.cc:    lderr(cct) << "ERROR: failed to get obj ref with ret=" << ret << dendl;
./rgw/rgw_rados.cc:    lderr(cct) << "ERROR: AioOperate failed with ret=" << ret << dendl;
./rgw/rgw_rados.cc:    lderr(cct) << "ERROR: failed to get obj ref with ret=" << ret << dendl;
./rgw/rgw_rados.cc:      lderr(cct) << "ERROR: failed to prepare index op with ret=" << ret << dendl;
./rgw/rgw_rados.cc:    lderr(cct) << "ERROR: AioOperate failed with ret=" << ret << dendl;
./rgw/rgw_rados.cc:      lderr(cct) << "ERROR: failed to delete obj index with ret=" << ret << dendl;
./rgw/rgw_kms.cc:      lderr(cct) << "ERROR: vault kv secrets engine takes no parameters (ignoring them)" << dendl;
./rgw/rgw_sync_trace.cc:      lderr(cct) << "ERROR: fail to register admin socket command (r=" << r << ")" << dendl;
./rgw/rgw_main.cc:    derr << "safe_read_exact returned with error" << dendl;
./rgw/rgw_main.cc:    derr << "Initialization timeout, failed to initialize" << dendl;
./rgw/rgw_main.cc:    derr << "ERROR: unable to initialize rgw tools" << dendl;
./rgw/rgw_main.cc:    derr << "Couldn't init storage provider (RADOS)" << dendl;
./rgw/rgw_main.cc:    derr << "ERROR: failed starting rgw perf" << dendl;
./rgw/rgw_main.cc:    derr << "ERROR: unable to initialize signal fds" << dendl;
./rgw/rgw_main.cc:      derr << "ERROR: failed initializing frontend" << dendl;
./rgw/rgw_main.cc:      derr << "ERROR: failed run" << dendl;
./rgw/rgw_main.cc:    derr << "ERROR: failed to register to service map: " << cpp_strerror(-r) << dendl;
./rgw/rgw_main.cc:  derr << "shutting down" << dendl;
./ceph_mds.cc:      derr << "Error: can't understand argument: " << *i << "\n" << dendl;
./ceph_mds.cc:    derr << "must specify '-i name' with the ceph-mds instance name" << dendl;
./compressor/Compressor.cc:    lderr(cct) << __func__ << " cannot load compressor of type " << type << dendl;
./compressor/Compressor.cc:    lderr(cct) << __func__ << " factory return error " << err << dendl;
./compressor/Compressor.cc:    lderr(cct) << __func__ << " invalid algorithm value:" << alg << dendl;
./ceph_mon.cc:  derr << __func__ << " unable to find a monmap" << dendl;
./ceph_mon.cc:      derr << "stat(" << mon_data << ") " << cpp_strerror(errno) << dendl;
./ceph_mon.cc:    derr << "opendir(" << mon_data << ") " << cpp_strerror(errno) << dendl;
./ceph_mon.cc:    derr << "readdir(" << mon_data << ") " << cpp_strerror(errno) << dendl;
./ceph_mon.cc:	derr << argv[0] << ": error reading " << monmap_fn << ": " << error << dendl;
./ceph_mon.cc:	derr << argv[0] << ": error decoding monmap " << monmap_fn << ": " << e.what() << dendl;
./ceph_mon.cc:        derr << oss.str() << dendl;
./ceph_mon.cc:	derr << argv[0] << ": warning: no initial monitors; must use admin socket to feed hints" << dendl;
./ceph_mon.cc:      derr << argv[0] << ": generated monmap has no fsid; use '--fsid <uuid>'" << dendl;
./ceph_mon.cc:      derr << oss.str() << dendl;
./ceph_mon.cc:      derr << argv[0] << ": error creating monfs: " << cpp_strerror(r) << dendl;
./ceph_mon.cc:        derr << err_msg << dendl;
./ceph_mon.cc:          derr << err_msg << dendl;
./ceph_mon.cc:	derr << err.str() << dendl;
./ceph_mon.cc:      derr << oss.str() << dendl;
./ceph_mon.cc:    derr << "unable to read magic from mon data" << dendl;
./ceph_mon.cc:    derr << "mon fs magic '" << magic << "' != current '" << CEPH_MON_ONDISK_MAGIC << "'" << dendl;
./ceph_mon.cc:    derr << "error checking features: " << cpp_strerror(err) << dendl;
./ceph_mon.cc:        derr << "can't decode monmap: " << e.what() << dendl;
./ceph_mon.cc:      derr << "unable to obtain a monmap: " << cpp_strerror(err) << dendl;
./ceph_mon.cc:	derr << "error writing monmap to " << extract_monmap << ": " << cpp_strerror(r) << dendl;
./ceph_mon.cc:      derr << "wrote monmap to " << extract_monmap << dendl;
./ceph_mon.cc:        derr << oss.str() << dendl;
./ceph_mon.cc:    derr << "unable to create mgr_msgr" << dendl;
./ceph_mon.cc:    derr << "flagging a forced sync ..." << dendl;
./ceph_mon.cc:    derr << "failed to initialize" << dendl;
./ceph_mon.cc:    derr << "compacting monitor store ..." << dendl;
./ceph_mon.cc:    derr << "done compacting" << dendl;
./ceph_mon.cc:    derr << "unable to bind monitor to " << bind_addrs << dendl;
./common/fd.cc:    lderr(cct) << "dump_open_fds unable to open " << fn << dendl;
./common/fd.cc:      lderr(cct) << "dump_open_fds unable to readlink " << path << ": " << cpp_strerror(r) << dendl;
./common/fd.cc:    lderr(cct) << "dump_open_fds " << de->d_name << " -> " << target << dendl;
./common/fd.cc:  lderr(cct) << "dump_open_fds dumped " << n << " open files" << dendl;
./common/pick_address.cc:      lderr(cct) << "interface names specified but not network names" << dendl;
./common/pick_address.cc:      lderr(cct) << "no interfaces matching " << ifs << dendl;
./common/pick_address.cc:      lderr(cct) << "unable to parse network: " << s << dendl;
./common/pick_address.cc:    lderr(cct) << "unable to convert chosen address to string: " << gai_strerror(err) << dendl;
./common/pick_address.cc:    lderr(cct) << "unable to fetch interfaces and addresses: " << err << dendl;
./common/pick_address.cc:        lderr(cct) << "Public network was set, but cluster network was not set " << dendl;
./common/pick_address.cc:        lderr(cct) << "    Using public network also for cluster network" << dendl;
./common/pick_address.cc:    lderr(cct) << "unable to convert chosen address to string: " << gai_strerror(err) << dendl;
./common/pick_address.cc:      lderr(cct) << "Falling back to public interface" << dendl;
./common/pick_address.cc:    lderr(cct) << "unable to fetch interfaces and addresses: " << err << dendl;
./common/pick_address.cc:    lderr(cct) << "unable to fetch interfaces and addresses: " << cpp_strerror(errno) << dendl;
./common/OutputDataSocket.cc:    lderr(m_cct) << "OutputDataSocketConfigObs::init: error: " << err << dendl;
./common/OutputDataSocket.cc:    lderr(m_cct) << "OutputDataSocketConfigObs::init: failed: " << err << dendl;
./common/random_string.cc:    lderr(cct) << "ceph_armor failed" << dendl;
./common/common_init.cc:  lderr(cct) << "Errors while parsing config file!" << dendl;
./common/common_init.cc:  lderr(cct) << parse_error << dendl;
./common/common_init.cc:      lderr(cct) << "Invalid octal string: " << err << dendl;
./common/PluginRegistry.cc:    lderr(cct) << __func__ << " code_version == NULL" << dlerror() << dendl;
./common/util.cc:    lderr(cct) << "os_release_parse - failed to open /etc/os-release: " << cpp_strerror(ret) << dendl;
./common/util.cc:    lderr(cct) << "distro_detect - /etc/os-release is required" << dendl;
./common/util.cc:      lderr(cct) << "distro_detect - can't detect " << rk << dendl;
./common/cmdparse.cc:  lderr(cct) << errstr.str() << dendl;
./common/cmdparse.cc:  lderr(cct) << oss.str() << dendl;
./common/win32/service.cc:    derr << "Shutdown service hook failed. Error code: " << err << dendl;
./common/win32/service.cc:      derr << "Reverting to original service state." << dendl;
./common/win32/service.cc:    derr << "Service stop hook failed. Error code: " << err << dendl;
./common/admin_socket.cc:      lderr(m_cct) << "AdminSocket: error reading request too long" << dendl;
./common/admin_socket.cc:    lderr(m_cct) << "AdminSocketConfigObs::init: error: " << err << dendl;
./common/admin_socket.cc:    lderr(m_cct) << "AdminSocketConfigObs::init: failed: " << err << dendl;
./common/admin_socket.cc:    lderr(m_cct) << "AdminSocket::shutdown: error: " << err << dendl;
./common/dns_resolve.cc:    lderr(cct) << "ERROR: failed to call res_ninit()" << dendl;
./common/dns_resolve.cc:    lderr(cct) << "res_query() failed" << dendl;
./common/dns_resolve.cc:    lderr(cct) << "ERROR: dn_expand() failed" << dendl;
./common/dns_resolve.cc:    lderr(cct) << "ERROR: bad reply" << dendl;
./common/dns_resolve.cc:    lderr(cct) << "ERROR: bad reply" << dendl;
./common/dns_resolve.cc:    lderr(cct) << "res_query() failed" << dendl;
./common/dns_resolve.cc:      lderr(cct) << "error while parsing DNS record" << dendl;
./common/dns_resolve.cc:    lderr(cct) << "failed for service " << query_str << dendl;
./common/dns_resolve.cc:      lderr(cct) << "Error while parsing DNS record" << dendl;
./common/ceph_context.cc:            lderr(cct) << "WARNING: all dangerous and experimental features are enabled." << dendl;
./common/ceph_context.cc:  lderr(this) << message.str() << dendl;
./common/LogClient.cc:    lderr(cct) << __func__ << " error parsing 'clog_to_monitors'" << dendl;
./common/LogClient.cc:    lderr(cct) << __func__ << " error parsing 'clog_to_syslog'" << dendl;
./common/LogClient.cc:    lderr(cct) << __func__ << " error parsing 'clog_to_syslog_facility'" << dendl;
./common/LogClient.cc:    lderr(cct) << __func__ << " error parsing 'clog_to_syslog_level'" << dendl;
./common/LogClient.cc:    lderr(cct) << __func__ << " error parsing 'clog_to_graylog'" << dendl;
./common/LogClient.cc:    lderr(cct) << __func__ << " error parsing 'clog_to_graylog_host'" << dendl;
./common/LogClient.cc:    lderr(cct) << __func__ << " error parsing 'clog_to_graylog_port'" << dendl;
./dokan/dbg.cc:    derr << "DokanOpenRequestorToken failed. Error: " << err << dendl;
./dokan/dbg.cc:    derr << "GetTokenInformation failed. Error: " << err << dendl;
./dokan/dbg.cc:    derr << "LookupAccountSid failed. Error: " << err << dendl;
./dokan/ceph_dokan.cc:  derr << __func__ << ": unknown error while opening: " << path << dendl;
./dokan/ceph_dokan.cc:    derr << __func__ << ": missing context: " << path << dendl;
./dokan/ceph_dokan.cc:    derr << __func__ << ": missing context: " << get_path(FileName) << dendl;
./dokan/ceph_dokan.cc:    derr << __func__ << ": missing context: " << get_path(FileName) << dendl;
./dokan/ceph_dokan.cc:    derr << __func__ << ": missing context: " << get_path(FileName) << dendl;
./dokan/ceph_dokan.cc:    derr << "ceph_statfs failed. Error: " << ret << dendl;
./dokan/ceph_dokan.cc:    derr << "Couldn't perform clean unmount. Error: " << ret << dendl;
./dokan/ceph_dokan.cc:    derr << "Not enough memory" << dendl;
./dokan/ceph_dokan.cc:    derr << "ceph_mount failed. Error: " << r << dendl;
./dokan/ceph_dokan.cc:    derr << "Received generic dokan error." << dendl;
./dokan/ceph_dokan.cc:    derr << "Invalid drive letter or mountpoint." << dendl;
./dokan/ceph_dokan.cc:    derr << "Can't initialize Dokan driver." << dendl;
./dokan/ceph_dokan.cc:    derr << "Dokan failed to start" << dendl;
./dokan/ceph_dokan.cc:    derr << "Dokan mount error." << dendl;
./dokan/ceph_dokan.cc:    derr << "Invalid mountpoint." << dendl;
./dokan/ceph_dokan.cc:    derr << "Unknown Dokan error: " << status << dendl;
./mgr/BaseMgrModule.cc:    derr << __func__ << " arg not a dict" << dendl;
./mgr/BaseMgrModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrModule.cc:    derr << "no module '" << other_module << "'" << dendl;
./mgr/BaseMgrModule.cc:    derr << ss.str() << dendl;
./mgr/BaseMgrModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrModule.cc:    derr << __func__ << " arg not a dict" << dendl;
./mgr/BaseMgrModule.cc:      derr << __func__ << " dict item " << i << " not a size 2 tuple" << dendl;
./mgr/BaseMgrModule.cc:        derr << __func__ << " " << query_param_name << " not a list" << dendl;
./mgr/BaseMgrModule.cc:        derr << __func__ << " " << query_param_name << " not a list" << dendl;
./mgr/BaseMgrModule.cc:      derr << __func__ << " unknown query param: " << query_param_name << dendl;
./mgr/BaseMgrModule.cc:    derr << __func__ << " invalid query" << dendl;
./mgr/BaseMgrModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrModule.cc:    derr << __func__ << " arg not a dict" << dendl;
./mgr/BaseMgrModule.cc:      derr << __func__ << " dict item " << i << " not a size 2 tuple" << dendl;
./mgr/BaseMgrModule.cc:        derr << __func__ << " " << query_param_name << " not a list" << dendl;
./mgr/BaseMgrModule.cc:        derr << __func__ << " " << query_param_name << " not a list" << dendl;
./mgr/BaseMgrModule.cc:      derr << __func__ << " unknown query param: " << query_param_name << dendl;
./mgr/BaseMgrModule.cc:    derr << __func__ << " invalid query" << dendl;
./mgr/BaseMgrModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrModule.cc:    derr << __func__ << " arg not a dict" << dendl;
./mgr/BaseMgrModule.cc:      derr << __func__ << " dict item " << i << " not a size 2 tuple" << dendl;
./mgr/ActivePyModules.cc:    derr << "Requested missing service " << svc_type << "." << svc_id << dendl;
./mgr/ActivePyModules.cc:    derr << "Requested missing service " << svc_type << "." << svc_id << dendl;
./mgr/ActivePyModules.cc:    derr << "Python module requested unknown data '" << what << "'" << dendl;
./mgr/ActivePyModules.cc:        derr << "Module '" << module_name << "' is not available" << dendl;
./mgr/ActivePyModules.cc:      derr << __func__ << " invalid mask for key " << key << dendl;
./mgr/ActivePyModules.cc:    derr << "Failed to import python module:" << dendl;
./mgr/ActivePyModules.cc:    derr << handle_pyerror() << dendl;
./mgr/ActivePyModules.cc:    derr << "Failed to get python type:" << dendl;
./mgr/ActivePyModules.cc:    derr << handle_pyerror() << dendl;
./mgr/ActivePyModules.cc:    derr << "Failed to construct python OSDMap:" << dendl;
./mgr/ActivePyModules.cc:    derr << handle_pyerror() << dendl;
./mgr/ActivePyModule.cc:    derr << "Failed to construct class in '" << get_name() << "'" << dendl;
./mgr/ActivePyModule.cc:    derr << handle_pyerror() << dendl;
./mgr/ActivePyModule.cc:    derr << get_name() << ".notify:" << dendl;
./mgr/ActivePyModule.cc:    derr << handle_pyerror() << dendl;
./mgr/ActivePyModule.cc:    derr << get_name() << ".notify_clog:" << dendl;
./mgr/ActivePyModule.cc:    derr << handle_pyerror() << dendl;
./mgr/Mgr.cc:  derr << " *** Got signal " << sig_str(signum) << " ***" << dendl;
./mgr/Mgr.cc:    derr << "Initialize server fail: " << cpp_strerror(r) << dendl;
./mgr/Mgr.cc:      derr << "could not open sqlite3: " << rc << dendl;
./mgr/Mgr.cc:      derr << "could not set libcephsqlite cct: " << rc << dendl;
./mgr/BaseMgrStandbyModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrStandbyModule.cc:    derr << "Invalid args!" << dendl;
./mgr/BaseMgrStandbyModule.cc:    derr << "Invalid args!" << dendl;
./mgr/PyOSDMap.cc:    derr << "Wrong type in osdmap_apply_incremental!" << dendl;
./mgr/PyOSDMap.cc:    derr << __func__ << " pool_list not a list" << dendl;
./mgr/PyOSDMap.cc:      derr << __func__ << " " << pool_name << " not a string" << dendl;
./mgr/PyOSDMap.cc:    derr << "Destroying improperly initialized BasePyOSDMap " << self << dendl;
./mgr/PyOSDMap.cc:    derr << "Destroying improperly initialized BasePyOSDMap " << self << dendl;
./mgr/PyOSDMap.cc:      derr << __func__ << " item " << j << " not a tuple" << dendl;
./mgr/PyOSDMap.cc:      derr << __func__ << " item " << j << " not a size 2 tuple" << dendl;
./mgr/MgrStandby.cc:    derr << "Authentication failed, did you specify a mgr ID with a valid keyring?" << dendl;
./mgr/MgrStandby.cc:    derr << "I was active but no longer am" << dendl;
./mgr/MgrClient.cc:    lderr(cct) << "dropping unexpected configure message" << dendl;
./mgr/PyModuleRunner.cc:    derr << get_name() << ".serve:" << dendl;
./mgr/PyModuleRunner.cc:    derr << handle_pyerror() << dendl;
./mgr/PyModuleRunner.cc:    derr << "Failed to invoke shutdown() on " << get_name() << dendl;
./mgr/PyModuleRunner.cc:    derr << handle_pyerror() << dendl;
./mgr/StandbyPyModules.cc:    derr << "Failed to construct class in '" << get_name() << "'" << dendl;
./mgr/StandbyPyModules.cc:    derr << handle_pyerror() << dendl;
./mgr/DaemonServer.cc:    derr << "unable to bind mgr to " << addrs << dendl;
./mgr/DaemonServer.cc:        derr << "got status from non-daemon " << key << dendl;
./mgr/DaemonServer.cc:      derr << __func__ << " " << cpp_strerror(r) << " " << rs << dendl;
./mgr/DaemonServer.cc:          derr << "missing key " << key << dendl;
./mgr/PyModule.cc:      derr << "Failed to create python sub-interpreter for '" << module_name << '"' << dendl;
./mgr/PyModule.cc:      derr << "Class not found in module '" << module_name << "'" << dendl;
./mgr/PyModule.cc:      derr << "Exception calling can_run on " << get_name() << dendl;
./mgr/PyModule.cc:      derr << handle_pyerror() << dendl;
./mgr/PyModule.cc:    derr << handle_pyerror() << dendl;
./mgr/PyModule.cc:    derr << handle_pyerror() << dendl;
./mgr/PyModule.cc:    derr << "Module not found: 'mgr_module'" << dendl;
./mgr/PyModule.cc:    derr << handle_pyerror() << dendl;
./mgr/PyModule.cc:    derr << "Unable to import MgrModule from mgr_module" << dendl;
./mgr/PyModule.cc:    derr << handle_pyerror() << dendl;
./mgr/PyModule.cc:    derr << "Module not found: '" << module_name << "'" << dendl;
./mgr/PyModule.cc:    derr << handle_pyerror() << dendl;
./blk/kernel/KernelDevice.cc:    derr << __func__ << " open got: " << cpp_strerror(r) << dendl;
./blk/kernel/KernelDevice.cc:    derr << __func__ << " posix_fadvise got: " << cpp_strerror(r) << dendl;
./blk/kernel/KernelDevice.cc:    derr << __func__ << " fstat got " << cpp_strerror(r) << dendl;
./blk/kernel/KernelDevice.cc:    derr << __func__ << " injecting crash. first we sleep..." << dendl;
./blk/kernel/KernelDevice.cc:    derr << __func__ << " and now we die" << dendl;
./blk/kernel/KernelDevice.cc:    derr << __func__ << " fdatasync got: " << cpp_strerror(r) << dendl;
./blk/kernel/KernelDevice.cc:	derr << __func__ << " io_setup(2) failed: " << cpp_strerror(r) << dendl;
./blk/kernel/KernelDevice.cc:      derr << __func__ << " got " << cpp_strerror(r) << dendl;
./blk/kernel/KernelDevice.cc:    derr << __func__ << " retries " << retries << dendl;
./blk/kernel/KernelDevice.cc:    derr << " aio submit got " << cpp_strerror(r) << dendl;
./blk/kernel/KernelDevice.cc:      derr << __func__ << " pwritev error: " << cpp_strerror(r) << dendl;
./blk/kernel/KernelDevice.cc:      derr << __func__ << " sync_file_range error: " << cpp_strerror(r) << dendl;
./blk/zoned/HMSMRDevice.cc:    derr << __func__ << " flock failed on " << path << dendl;
./blk/zoned/HMSMRDevice.cc:    derr << __func__ << " open got: " << cpp_strerror(r) << dendl;
./blk/zoned/HMSMRDevice.cc:    derr << __func__ << " failed to set HM-SMR parameters" << dendl;
./blk/zoned/HMSMRDevice.cc:    derr << __func__ << " posix_fadvise got: " << cpp_strerror(r) << dendl;
./blk/zoned/HMSMRDevice.cc:    derr << __func__ << " fstat got " << cpp_strerror(r) << dendl;
./blk/zoned/HMSMRDevice.cc:    derr << __func__ << " injecting crash. first we sleep..." << dendl;
./blk/zoned/HMSMRDevice.cc:    derr << __func__ << " and now we die" << dendl;
./blk/zoned/HMSMRDevice.cc:    derr << __func__ << " fdatasync got: " << cpp_strerror(r) << dendl;
./blk/zoned/HMSMRDevice.cc:	derr << __func__ << " io_setup(2) failed: " << cpp_strerror(r) << dendl;
./blk/zoned/HMSMRDevice.cc:      derr << __func__ << " got " << cpp_strerror(r) << dendl;
./blk/zoned/HMSMRDevice.cc:    derr << __func__ << " retries " << retries << dendl;
./blk/zoned/HMSMRDevice.cc:    derr << " aio submit got " << cpp_strerror(r) << dendl;
./blk/zoned/HMSMRDevice.cc:    derr << __func__ << " pwritev error: " << cpp_strerror(r) << dendl;
./blk/zoned/HMSMRDevice.cc:      derr << __func__ << " sync_file_range error: " << cpp_strerror(r) << dendl;
./blk/pmem/PMEMDevice.cc:    derr << __func__ << " open got: " << cpp_strerror(r) << dendl;
./blk/pmem/PMEMDevice.cc:    derr << __func__ << " fstat got " << cpp_strerror(r) << dendl;
./blk/pmem/PMEMDevice.cc:    derr << __func__ << " pmem_map_file failed: " << pmem_errormsg() << dendl;
./blk/spdk/NVMEDevice.cc:        derr << __func__ << " failed to create memory pool for nvme data buffer" << dendl;
./blk/spdk/NVMEDevice.cc:            derr << __func__ << " failed to do write command: " << cpp_strerror(r) << dendl;
./blk/spdk/NVMEDevice.cc:            derr << __func__ << " failed to read: " << cpp_strerror(r) << dendl;
./blk/spdk/NVMEDevice.cc:            derr << __func__ << " failed to flush: " << cpp_strerror(r) << dendl;
./blk/spdk/NVMEDevice.cc:      derr << __func__ << " failed to get namespace at 1" << dendl;
./blk/spdk/NVMEDevice.cc:    derr << __func__ << " invalid transport address: " << trid.traddr << dendl;
./blk/spdk/NVMEDevice.cc:              derr << __func__ << " device probe nvme failed" << dendl;
./blk/spdk/NVMEDevice.cc:    derr << __func__ << " unable to open " << p << dendl;
./blk/spdk/NVMEDevice.cc:    derr << __func__ << " failed to get nvme device with transport address " << trid.traddr << dendl;
./journal/Journaler.cc:    lderr(m_cct) << "order must be in the range [12, 26]" << dendl;
./journal/JournalMetadata.cc:      lderr(m_cct) << "failed to locate client: " << m_client_id << dendl;
./journal/JournalMetadata.cc:    lderr(m_cct) << "journal watch error: client blocklisted" << dendl;
./journal/JournalMetadata.cc:    lderr(m_cct) << "journal watch error: " << cpp_strerror(err) << dendl;
./journal/JournalPlayer.cc:    lderr(m_cct) << "missing prior journal entry: " << *entry << dendl;
./journal/JournalPlayer.cc:      lderr(m_cct) << "UNEXPECTED STATE (" << m_state << ")" << dendl;
./ceph_osd.cc:	  derr << "failed to decode LogEntry at offset " << pos << dendl;
./ceph_osd.cc:	derr << pos << ":\t" << e << dendl;
./ceph_osd.cc:      derr << "unable to open " << dump_pg_log << ": " << error << dendl;
./ceph_osd.cc:    derr << "must specify '-i #' where # is the osd number" << dendl;
./ceph_osd.cc:    derr << "must specify '--osd-data=foo' data path" << dendl;
./ceph_osd.cc:	  derr << "missing 'type' file and unable to infer osd type" << dendl;
./ceph_osd.cc:    derr << "unable to create object store" << dendl;
./ceph_osd.cc:      derr << "already have key in keyring " << keyring_path << dendl;
./ceph_osd.cc:	derr << "created new key in keyring " << keyring_path << dendl;
./ceph_osd.cc:      derr << "must specify cluster fsid" << dendl;
./ceph_osd.cc:    derr << "OSD id " << w << " != my id " << whoami << dendl;
./ceph_osd.cc:      derr << err.str() << dendl;
./ceph_osd.cc:    derr << "Failed to pick public address." << dendl;
./ceph_osd.cc:    derr << "Failed to pick cluster address." << dendl;
./global/signal_handler.cc:              derr << message.str() << dendl;
./global/global_init.cc:    derr << "deliberately leaking some memory" << dendl;
./global/global_init.cc:    derr << ss.str() << dendl;
./libradosstriper/RadosStriperImpl.cc:      lderr(data->m_striper->cct()) << XATTR_SIZE << " : " << err << dendl;
./libradosstriper/RadosStriperImpl.cc:        lderr(cct()) << XATTR_SIZE << " : " << err << dendl;
./libradosstriper/RadosStriperImpl.cc:      lderr(cct()) << key << " : " << err << dendl;
./libradosstriper/RadosStriperImpl.cc:      lderr(cct()) << key << " : " << err << dendl;
./tools/rbd_nbd/rbd-nbd.cc:        derr << "failed to poll nbd: " << cpp_strerror(r) << dendl;
./tools/rbd_nbd/rbd-nbd.cc:	derr << "invalid nbd request header" << dendl;
./tools/rbd_nbd/rbd-nbd.cc:	  derr << *pctx << ": invalid request command" << dendl;
./tools/rbd_nbd/rbd-nbd.cc:      derr << "flush failed: " << cpp_strerror(r) << dendl;
./tools/rbd_nbd/rbd-nbd.cc:            derr << "resize failed: " << cpp_strerror(errno) << dendl;
./tools/rbd_nbd/rbd-nbd.cc:          derr << "invalidate rbd cache failed" << dendl;
./tools/rbd_nbd/rbd-nbd.cc:  derr << "*** Got signal " << sig_str(signum) << " ***" << dendl;
./tools/ceph-client-debug.cc:    derr << "Invalid inode: " << inode_str << dendl;
./tools/ceph-client-debug.cc:    derr << "Error initializing libcephfs: " << cpp_strerror(r) << dendl;
./tools/ceph-client-debug.cc:    derr << "Error mounting: " << cpp_strerror(r) << dendl;
./tools/ceph-client-debug.cc:    derr << "Error mounting: " << cpp_strerror(r) << dendl;
./tools/immutable_object_cache/CacheServer.cc:    lderr(cct) << "failed to open domain socket: " << ec.message() << dendl;
./tools/immutable_object_cache/CacheServer.cc:    lderr(cct) << "async accept fails : " << error.message() << dendl;
./tools/immutable_object_cache/CacheController.cc:    lderr(m_cct) << "init error\n" << dendl;
./tools/immutable_object_cache/CacheController.cc:    lderr(m_cct) << "init error\n" << dendl;
./tools/immutable_object_cache/CacheController.cc:      lderr(m_cct) << "stop error\n" << dendl;
./tools/immutable_object_cache/CacheController.cc:    lderr(m_cct) << "stop error\n" << dendl;
./tools/immutable_object_cache/CacheController.cc:      lderr(m_cct) << "'immutable_object_cache_sock' path not set" << dendl;
./tools/immutable_object_cache/CacheController.cc:    lderr(m_cct) << "Exception: " << e.what() << dendl;
./tools/immutable_object_cache/ObjectCacheStore.cc:    lderr(m_cct) << "Invalid water mark provided, set it to default." << dendl;
./tools/immutable_object_cache/ObjectCacheStore.cc:    lderr(m_cct) << "fail to init Ceph context" << dendl;
./tools/immutable_object_cache/ObjectCacheStore.cc:    lderr(m_cct) << "fail to connect to cluster" << dendl;
./tools/immutable_object_cache/ObjectCacheStore.cc:        lderr(m_cct) << "fail to create ioctx" << dendl;
./tools/immutable_object_cache/ObjectCacheStore.cc:    lderr(m_cct) << "fail to read from rados" << dendl;
./tools/immutable_object_cache/ObjectCacheStore.cc:      lderr(m_cct) << "fail to write cache file" << dendl;
./tools/immutable_object_cache/ObjectCacheStore.cc:      lderr(m_cct) << "fail to write cache file" << dendl;
./tools/immutable_object_cache/ObjectCacheStore.cc:          lderr(m_cct) << "fail to start promote" << dendl;
./tools/immutable_object_cache/ObjectCacheStore.cc:      lderr(m_cct) << "unrecognized object cache status" << dendl;
./tools/immutable_object_cache/ObjectCacheStore.cc:    lderr(m_cct) << "failed to read from rados" << dendl;
./tools/immutable_object_cache/ObjectCacheStore.cc:    lderr(m_cct) << "unknow throttle type." << dendl;
./tools/cephfs_mirror/MirrorWatcher.cc:    derr << ": mirroring object deleted" << dendl;
./tools/cephfs_mirror/MirrorWatcher.cc:    derr << ": rewatch error: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:      derr << ": invalid config-key JSON" << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:      derr << ": unexpected JSON received" << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:    derr << ": error mounting remote filesystem=" << remote_filesystem << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:    derr << ": failed to allocate memory" << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:          derr << ": failed to read remote directory=" << entry.epath << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:          derr << ": failed to close remote directory=" << entry.epath << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:        derr << ": failed to close remote directory=" << entry.epath << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:          derr << ": failed to local read directory=" << entry.epath << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:          derr << ": failed to close local directory=" << entry.epath << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:        derr << ": failed to close local directory=" << entry.epath << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:    derr << ": failed to cleanup remote directory=" << dir_path << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:    derr << ": failed to build local snap map" << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:    derr << ": failed to build remote snap map" << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:    derr << ": failed to propgate deleted snapshots" << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:    derr << ": failed to propgate renamed snapshots" << dendl;
./tools/cephfs_mirror/PeerReplayer.cc:    derr << ": failed to sync snapshots for dir_path=" << dir_path << dendl;
./tools/cephfs_mirror/watcher/RewatchRequest.cc:    derr << ": client blocklisted" << dendl;
./tools/cephfs_mirror/watcher/RewatchRequest.cc:    derr << ": failed to unwatch: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/watcher/RewatchRequest.cc:    derr << ": failed to watch object: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Mirror.cc:    derr << ": failed to init mon client: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Mirror.cc:    derr << ": failed to authenticate to monitor: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Mirror.cc:    derr << ": could not initialize rados handler" << dendl;
./tools/cephfs_mirror/Mirror.cc:    derr << ": error connecting to local cluster" << dendl;
./tools/cephfs_mirror/Mirror.cc:    derr << ": error registering service daemon: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/InstanceWatcher.cc:    derr << ": failed to decode notify json: " << e.what() << dendl;
./tools/cephfs_mirror/InstanceWatcher.cc:    derr << ": unknown mode" << dendl;
./tools/cephfs_mirror/InstanceWatcher.cc:    derr << ": mirroring object deleted" << dendl;
./tools/cephfs_mirror/InstanceWatcher.cc:    derr << ": rewatch error: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/ClusterWatcher.cc:    derr << ": failed subscribing to FSMap" << dendl;
./tools/cephfs_mirror/Watcher.cc:      derr << ": failed to register watch: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Watcher.cc:      derr << ": re-registering after watch error" << dendl;
./tools/cephfs_mirror/Watcher.cc:  derr << ": handle=" << handle << ": " << cpp_strerror(err) << dendl;
./tools/cephfs_mirror/Watcher.cc:      derr << ": client blocklisted" << dendl;
./tools/cephfs_mirror/Watcher.cc:      derr << ": failed to rewatch: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Watcher.cc:      derr << ": re-registering watch after error" << dendl;
./tools/cephfs_mirror/Utils.cc:    derr << ": error initializing cluster handle for " << cluster_name << dendl;
./tools/cephfs_mirror/Utils.cc:    derr << ": could not read ceph conf: " << ": " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Utils.cc:    derr << ": could not parse environment: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Utils.cc:      derr << "failed to set mon_host config: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Utils.cc:      derr << "failed to set key config: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Utils.cc:    derr << ": mount error: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Utils.cc:    derr << ": mount error: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Utils.cc:    derr << ": mount error: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Utils.cc:    derr << ": mount error: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Utils.cc:    derr << ": mount error: " << cpp_strerror(r) << dendl;
./tools/cephfs_mirror/Utils.cc:    derr << ": mount error: " << cpp_strerror(r) << dendl;
./tools/rbd_ggate/main.cc:  derr << "*** Got signal " << sig_str(signum) << " ***" << dendl;
./tools/rbd_ggate/Server.cc:        derr << "recv: " << cpp_strerror(r) << dendl;
./tools/rbd_ggate/Server.cc:      derr << ctx.get() << ": send: " << cpp_strerror(r) << dendl;
./tools/rbd_ggate/Watcher.cc:        derr << "resize failed: " << cpp_strerror(r) << dendl;
./tools/rbd_ggate/Watcher.cc:        derr << "invalidate rbd cache failed: " << cpp_strerror(r) << dendl;
./tools/rbd_wnbd/wnbd_handler.cc:    derr << "Failed to retrieve WNBD userspace stats. Error: " << err << dendl;
./tools/rbd_wnbd/wnbd_handler.cc:      derr << "Could not create event. Error: " << err << dendl;
./tools/rbd_wnbd/wnbd_handler.cc:    derr << "Could not reset event. Error: " << err << dendl;
./tools/rbd_wnbd/wnbd_handler.cc:      derr << "Could not start WNBD dispatcher. Error: " << err << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:        derr << "Could not allocate " << buff_sz << " bytes." << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:    derr << "Could not query registry key: " << SERVICE_REG_KEY << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:    derr << "Could not enumerate registry. Error: " << err << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:    derr << "CreateNamedPipe failed: " << win32_strerror(err) << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:    derr << "CreateEvent failed: " << win32_strerror(err) << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:    derr << "ConnectNamedPipe failed: " << win32_strerror(err) << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:    derr << "CreateProcess failed: " << win32_strerror(err) << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:      derr << "Timed out waiting for child process connection." << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:      derr << "Failed waiting for child process. Status: " << status << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:      derr << "Timed out waiting for child process message." << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:      derr << "Failed waiting for child process. Status: " << status << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:      derr << "Daemon failed with: " << cpp_strerror(exit_code) << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:      derr << "Could not start RBD daemon." << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:    derr << "Could not fetch all mappings. Error: " << r << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:    derr << "Could not fetch all mappings. Error: " << r << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:        derr << "CreatePipe failed: " << win32_strerror(err) << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:          derr << "Pipe connection failed: " << win32_strerror(err) << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:        derr << "Could not start pipe server: " << win32_strerror(err) << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:          derr << "Couldn't remap all images. Cleaning up." << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:      derr << "Missing image name." << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:      derr << "Could not open parent pipe: " << win32_strerror(err) << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:    derr << "rbd-wnbd: invalid spec '" << imgpath << "'" << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:    derr << "rbd-wnbd: invalid output format: " << format << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:    derr << "Could not get disk list: " << error << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:    derr << "rbd-wnbd: invalid output format: " << format << dendl;
./tools/rbd_wnbd/rbd_wnbd.cc:  derr << "Could not find the specified disk." << dendl;
./tools/cephfs/MDSUtility.cc:    derr << "Authentication failed, did you specify an MDS ID with a valid keyring?" << dendl;
./tools/cephfs/Resetter.cc:        derr << "Error writing journal pointer:  " << cpp_strerror(rt) << dendl;
./tools/cephfs/Resetter.cc:    derr << "Error writing journal header: " << cpp_strerror(r) << dendl;
./tools/cephfs/Resetter.cc:      derr << "Error writing EResetJournal: " << cpp_strerror(r) << dendl;
./tools/cephfs/PgFiles.cc:    derr << "Failed to open path: " << cpp_strerror(r) << dendl;
./tools/cephfs/PgFiles.cc:    derr << "Error closing path " << path << ": " << cpp_strerror(r) << dendl;
./tools/cephfs/PgFiles.cc:    derr << "Failed to mount: " << cpp_strerror(r) << dendl;
./tools/cephfs/PgFiles.cc:    derr << "Failed to unmount: " << cpp_strerror(r) << dendl;
./tools/cephfs/JournalTool.cc:    derr << "missing mandatory \"--rank\" argument" << dendl;
./tools/cephfs/JournalTool.cc:    derr << "journal type is not correct." << dendl;
./tools/cephfs/JournalTool.cc:    derr << "Couldn't determine MDS rank." << dendl;
./tools/cephfs/JournalTool.cc:    derr << "Missing mode [journal|header|event]" << dendl;
./tools/cephfs/JournalTool.cc:    derr << "RADOS unavailable, cannot scan filesystem journal" << dendl;
./tools/cephfs/JournalTool.cc:    derr << "couldn't connect to cluster: " << cpp_strerror(r) << dendl;
./tools/cephfs/JournalTool.cc:    derr << "Pool " << pool_id << " named in MDS map not found in RADOS!" << dendl;
./tools/cephfs/JournalTool.cc:      derr << "operation not allowed for all ranks" << dendl;
./tools/cephfs/JournalTool.cc:    derr << "Missing journal command, please see help" << dendl;
./tools/cephfs/JournalTool.cc:      derr << "Missing path" << dendl;
./tools/cephfs/JournalTool.cc:    derr << "Bad journal command '" << command << "'" << dendl;
./tools/cephfs/JournalTool.cc:    derr << "Header could not be read!" << dendl;
./tools/cephfs/JournalTool.cc:    derr << "Missing header command, must be [get|set]" << dendl;
./tools/cephfs/JournalTool.cc:      derr << "'set' requires two arguments <trimmed_pos|expire_pos|write_pos> <value>" << dendl;
./tools/cephfs/JournalTool.cc:      derr << "Invalid value '" << value_str << "': " << parse_err << dendl;
./tools/cephfs/JournalTool.cc:      derr << "Invalid field '" << field_name << "'" << dendl;
./tools/cephfs/JournalTool.cc:    derr << "Bad header command '" << command << "'" << dendl;
./tools/cephfs/JournalTool.cc:    derr << "Missing event command, please see help" << dendl;
./tools/cephfs/JournalTool.cc:    derr << "Unknown argument '" << command << "'" << dendl;
./tools/cephfs/JournalTool.cc:      derr << "journaler for " << type << " can't do \"recover_dentries\"." << dendl;
./tools/cephfs/JournalTool.cc:    derr << "Incomplete command line" << dendl;
./tools/cephfs/JournalTool.cc:      derr << "Failed to scan journal (" << cpp_strerror(r) << ")" << dendl;
./tools/cephfs/JournalTool.cc:      derr << "Failed to scan journal (" << cpp_strerror(r) << ")" << dendl;
./tools/cephfs/JournalTool.cc:      derr << "Failed to scan journal (" << cpp_strerror(r) << ")" << dendl;
./tools/cephfs/JournalTool.cc:      derr << "Unable to scan journal, assuming badly damaged" << dendl;
./tools/cephfs/JournalTool.cc:      derr << "Journal not readable, attempt object-by-object dump with `rados`" << dendl;
./tools/cephfs/JournalTool.cc:      derr << "dumper::init failed: " << cpp_strerror(r) << dendl;
./tools/cephfs/JournalTool.cc:    derr << "resetter::init failed: " << cpp_strerror(r) << dendl;
./tools/cephfs/JournalTool.cc:    derr << "Erase region " << length << " too short" << dendl;
./tools/cephfs/DataScan.cc:      derr << "Unexpected --output-dir: output already selected!" << dendl;
./tools/cephfs/DataScan.cc:    derr << "RADOS unavailable" << dendl;
./tools/cephfs/DataScan.cc:    derr << "Error writing '" << oid.name << "': " << cpp_strerror(r) << dendl;
./tools/cephfs/DataScan.cc:      derr << "Unexpected error listing objects: " << cpp_strerror(r) << dendl;
./tools/cephfs/DataScan.cc:    derr << "Unexpected --output-dir option for scan_links" << dendl;
./tools/cephfs/DataScan.cc:	derr << "Error getting omap from '" << oid << "': " << cpp_strerror(r) << dendl;
./tools/cephfs/DataScan.cc:      derr << "Error removing duplicated dentries from " << p.first << dendl;
./tools/cephfs/DataScan.cc:      derr << "Unexpected error reading backtrace: " << cpp_strerror(parent_r) << dendl;
./tools/cephfs/DataScan.cc:      derr << "Corrupt fnode on " << oid << dendl;
./tools/cephfs/DataScan.cc:      derr << "lost+found exists but is not a directory!" << dendl;
./tools/cephfs/Dumper.cc:    derr << "error on recovery: " << cpp_strerror(r) << dendl;
./tools/cephfs/Dumper.cc:      derr << "Error " << r << " (" << cpp_strerror(r) << ") writing journal file header" << dendl;
./tools/cephfs/Dumper.cc:      derr << "Error " << r << " (" << cpp_strerror(r) << ") seeking to 0x" << std::hex << start << std::dec << dendl;
./tools/cephfs/Dumper.cc:        derr << "Error " << r << " (" << cpp_strerror(r) << ") writing journal file" << dendl;
./tools/cephfs/Dumper.cc:      derr << "Error " << r << " (" << cpp_strerror(r) << ") closing journal file" << dendl;
./tools/cephfs/Dumper.cc:    derr << "unable to open " << dump_file << ": " << cpp_strerror(err) << dendl;
./tools/cephfs/Dumper.cc:    derr << "recover_journal failed, try to get header from dump file " << dendl;
./tools/cephfs/Dumper.cc:    derr << "couldn't open " << dump_file << ": " << cpp_strerror(r) << dendl;
./tools/cephfs/Dumper.cc:	derr  << "Invalid fsid" << dendl;
./tools/cephfs/Dumper.cc:	derr << "Imported journal fsid does not match online cluster fsid" << dendl;
./tools/cephfs/Dumper.cc:	derr << "Use --force to skip fsid check" << dendl;
./tools/cephfs/Dumper.cc:      derr  << "Invalid header, no fsid embeded" << dendl;
./tools/cephfs/Dumper.cc:    derr << "Failed to write header: " << cpp_strerror(r) << dendl;
./tools/cephfs/Dumper.cc:      derr << "Failed to write header: " << cpp_strerror(r) << dendl;
./tools/cephfs/JournalFilter.cc:        derr << "Invalid range '" << arg_str << "'" << dendl;
./tools/cephfs/JournalFilter.cc:          derr << "Invalid lower bound '" << range_start_str << "': " << parse_err << dendl;
./tools/cephfs/JournalFilter.cc:          derr << "Invalid upper bound '" << range_end_str << "': " << parse_err << dendl;
./tools/cephfs/JournalFilter.cc:	derr << "Invalid filter arguments: purge_queue doesn't take \"--path\"." << dendl;
./tools/cephfs/JournalFilter.cc:        derr << "Invalid inode '" << arg_str << "': " << parse_err << dendl;
./tools/cephfs/JournalFilter.cc:	 derr << "Invalid event type '" << arg_str << "'" << dendl;
./tools/cephfs/JournalFilter.cc:	derr << "Invalid filter arguments: purge_queue doesn't take \"--frag\"." << dendl;
./tools/cephfs/JournalFilter.cc:        derr << "Invalid inode '" << inode_str << "': " << parse_err << dendl;
./tools/cephfs/JournalFilter.cc:        derr << "Invalid frag '" << frag_str << "': " << parse_err << dendl;
./tools/cephfs/JournalFilter.cc:	derr << "Invalid filter arguments: purge_queue doesn't take \"--dname\"." << dendl;
./tools/cephfs/JournalFilter.cc:	derr << "Invalid filter arguments: purge_queue doesn't take \"--client\"." << dendl;
./tools/cephfs/JournalFilter.cc:        derr << "Invalid client number " << arg_str << dendl;
./tools/cephfs/MetaTool.cc:    derr << "!!!! erro !!!!" << dendl;
./tools/cephfs/JournalScanner.cc:    derr << "Pointer " << pointer_oid << " is absent" << dendl;
./tools/cephfs/JournalScanner.cc:    derr << "Pointer " << pointer_oid << " is unreadable" << dendl;
./tools/cephfs/JournalScanner.cc:      derr << "Pointer " << pointer_oid << " is corrupt: " << e.what() << dendl;
./tools/cephfs/JournalScanner.cc:    derr << "Header " << header_name << " is unreadable" << dendl;
./tools/cephfs/JournalScanner.cc:    derr << "Header is corrupt (" << e.what() << ")" << dendl;
./tools/cephfs/JournalScanner.cc:    derr << "Header is corrupt (bad magic)" << dendl;
./tools/cephfs/JournalScanner.cc:    derr << "Header is invalid (inconsistent offsets)" << dendl;
./tools/cephfs/JournalScanner.cc:        derr << "Missing object " << oid << dendl;
./tools/cephfs/TableTool.cc:        derr << "table " << object_name << " is corrupt" << dendl;
./tools/cephfs/TableTool.cc:      derr << "table " << object_name << " is corrupt" << dendl;
./tools/cephfs/TableTool.cc:        derr << "error reading values: " << cpp_strerror(r) << dendl;
./tools/cephfs/TableTool.cc:        derr << "table " << object_name << " is corrupt" << dendl;
./tools/cephfs/TableTool.cc:    derr << "RADOS unavailable, cannot scan filesystem journal" << dendl;
./tools/cephfs/TableTool.cc:    derr << "couldn't connect to cluster: " << cpp_strerror(r) << dendl;
./tools/cephfs/TableTool.cc:    derr << "Bad rank selection: " << role_str << "'" << dendl;
./tools/cephfs/TableTool.cc:      derr << "Bad ino '" << ino_str << "'" << dendl;
./tools/rbd_mirror/NamespaceReplayer.cc:    derr << "error stopping instance replayer: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/NamespaceReplayer.cc:    derr << "failed to init image map: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/NamespaceReplayer.cc:    derr << "failed to retrieve local images: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/NamespaceReplayer.cc:    derr << "failed to retrieve remote images: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/NamespaceReplayer.cc:    derr << "failed to init image deleter: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/NamespaceReplayer.cc:    derr << "failed to shut down image map: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_map/LoadRequest.cc:    derr << ": failed to get image map: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_map/UpdateRequest.cc:    derr << ": failed to update image map: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/ImageDeleter.cc:    derr << "blocklisted while deleting local image" << dendl;
./tools/rbd_mirror/LeaderWatcher.cc:    derr << "error shutting down leader lock: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/LeaderWatcher.cc:      derr << "error acquiring leader lock: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/LeaderWatcher.cc:    derr << "error breaking leader lock: " << cpp_strerror(r)  << dendl;
./tools/rbd_mirror/LeaderWatcher.cc:    derr << "error retrieving leader locker: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/LeaderWatcher.cc:      derr << "error acquiring lock: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/LeaderWatcher.cc:    derr << "error releasing lock: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/LeaderWatcher.cc:    derr << "error initializing instances: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/LeaderWatcher.cc:    derr << "error notifying listener: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/LeaderWatcher.cc:    derr << "error decoding image notification: " << err.what() << dendl;
./tools/rbd_mirror/MirrorStatusWatcher.cc:        derr << "error removing down statuses: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/Instances.cc:    derr << "error retrieving instances: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/ImageMap.cc:    derr << "failed to remove global_image_id=" << global_image_id << dendl;
./tools/rbd_mirror/Mirror.cc:    derr << "could not initialize rados handle" << dendl;
./tools/rbd_mirror/Mirror.cc:    derr << "error connecting to local cluster" << dendl;
./tools/rbd_mirror/Mirror.cc:    derr << "error registering service daemon: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/Mirror.cc:          derr << "restarting blocklisted pool replayer for " << peer << dendl;
./tools/rbd_mirror/Mirror.cc:          derr << "restarting failed pool replayer for " << peer << dendl;
./tools/rbd_mirror/ImageReplayer.cc:      derr << "already running" << dendl;
./tools/rbd_mirror/ImageReplayer.cc:    derr << "error starting replay: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/ImageReplayer.cc:          derr << "start failed: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/ImageReplayer.cc:    derr << "error registering admin socket commands" << dendl;
./tools/rbd_mirror/image_replayer/GetMirrorImageIdRequest.cc:      derr << "failed to retrieve image id: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/snapshot/Replayer.cc:    derr << "failed to retrieve mirror peer uuid from remote pool" << dendl;
./tools/rbd_mirror/image_replayer/snapshot/Replayer.cc:    derr << "replay not running" << dendl;
./tools/rbd_mirror/image_replayer/snapshot/Replayer.cc:    derr << "remote image does not contain mirror snapshots" << dendl;
./tools/rbd_mirror/image_replayer/snapshot/Replayer.cc:    derr << "failed to load local image-meta: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/snapshot/Replayer.cc:    derr << "failed to refresh local image: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/snapshot/Replayer.cc:    derr << "failed to refresh remote image: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/snapshot/Replayer.cc:          derr << "incomplete local non-primary snapshot" << dendl;
./tools/rbd_mirror/image_replayer/snapshot/Replayer.cc:        derr << "incomplete local primary snapshot" << dendl;
./tools/rbd_mirror/image_replayer/snapshot/Replayer.cc:      derr << "unknown local mirror snapshot state" << dendl;
./tools/rbd_mirror/image_replayer/snapshot/Replayer.cc:      derr << "unknown remote mirror snapshot state" << dendl;
./tools/rbd_mirror/image_replayer/snapshot/Replayer.cc:    derr << "failed to request image-sync: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/snapshot/Replayer.cc:    derr << "failed to notify local image update: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/snapshot/CreateLocalImageRequest.cc:      derr << "failed to create local image: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/snapshot/PrepareReplayRequest.cc:    derr << "failed to load local image-meta: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/snapshot/ApplyImageStateRequest.cc:    derr << "failed to update image features: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/snapshot/ApplyImageStateRequest.cc:    derr << "failed to update image metadata: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/PrepareRemoteImageRequest.cc:    derr << "failed to retrieve client: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/CreateImageRequest.cc:    derr << "failed to create local image: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/CreateImageRequest.cc:      derr << "remote image parent spec mismatch" << dendl;
./tools/rbd_mirror/image_replayer/PrepareLocalImageRequest.cc:    derr << "failed to retrieve image name: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:    derr << "replay not running" << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:    derr << "failed to initialize remote journal: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:    derr << "local image journal closed" << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:    derr << "error shutting down journal replay: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:    derr << "error closing local iamge: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:    derr << "failed to retrieve client: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:    derr << "error flushing local replay: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:    derr << "replay encountered an error: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:    derr << "local image journal closed" << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:    derr << "replay flush encountered an error: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:    derr << "failed to allocate journal tag: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:    derr << "failed to decode journal event" << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:      derr << "failed to preprocess journal event" << dendl;
./tools/rbd_mirror/image_replayer/journal/Replayer.cc:    derr << "failed to commit journal event: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/CreateLocalImageRequest.cc:      derr << "failed to create local image: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/PrepareReplayRequest.cc:    derr << "local image does not support journaling" << dendl;
./tools/rbd_mirror/image_replayer/journal/PrepareReplayRequest.cc:    derr << "failed to check if a resync was requested" << dendl;
./tools/rbd_mirror/image_replayer/journal/PrepareReplayRequest.cc:    derr << "failed to update client: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/PrepareReplayRequest.cc:    derr << "failed to retrieve remote client: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/PrepareReplayRequest.cc:    derr << "unknown remote client registration" << dendl;
./tools/rbd_mirror/image_replayer/journal/PrepareReplayRequest.cc:    derr << "failed to retrieve remote tags: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/journal/PrepareReplayRequest.cc:    derr << "split-brain detected -- skipping image replay" << dendl;
./tools/rbd_mirror/image_replayer/BootstrapRequest.cc:    derr << "error retrieving remote image id" << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/BootstrapRequest.cc:    derr << "failed to open remote image: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/BootstrapRequest.cc:    derr << "failed to open local image: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/BootstrapRequest.cc:      derr << "failed to prepare local replay: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/BootstrapRequest.cc:      derr << "failed to create local image: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/BootstrapRequest.cc:      derr << "failed to sync remote image: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_replayer/OpenLocalImageRequest.cc:      derr << ": image does not support exclusive lock" << dendl;
./tools/rbd_mirror/image_replayer/OpenLocalImageRequest.cc:      derr << ": image is not locked" << dendl;
./tools/rbd_mirror/image_replayer/Utils.cc:    derr << "failed to decode client meta data: " << err.what() << dendl;
./tools/rbd_mirror/image_replayer/Utils.cc:    derr << "unknown peer registration" << dendl;
./tools/rbd_mirror/RemotePoolPoller.cc:    derr << "failed to ping remote mirror peer: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/RemotePoolPoller.cc:    derr << "failed to retrieve mirror peers: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_sync/SyncPointCreateRequest.cc:    derr << ": remote image refresh failed: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_sync/SyncPointCreateRequest.cc:    derr << ": failed to create snapshot: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_sync/SyncPointPruneRequest.cc:    derr << ": remote image refresh failed: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/InstanceWatcher.cc:    derr << "error registering instance: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/InstanceWatcher.cc:      derr << "error acquiring instance lock: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/InstanceWatcher.cc:    derr << "error releasing instance lock: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/InstanceWatcher.cc:    derr << "error unregistering instance: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/InstanceWatcher.cc:      derr << "error retrieving instance locker: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/InstanceWatcher.cc:      derr << "error breaking instance lock: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/InstanceWatcher.cc:    derr << "error decoding image notification: " << err.what() << dendl;
./tools/rbd_mirror/ImageSync.cc:      derr << ": failed to locate snapshot: " << sync_point.snap_name << dendl;
./tools/rbd_mirror/ImageSync.cc:    derr << ": failed to copy image: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/ClusterWatcher.cc:    derr << "error waiting for OSD map: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/ClusterWatcher.cc:    derr << "error listing pools: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/ClusterWatcher.cc:      derr << "Error retrieving base tier for pool " << pool_name << dendl;
./tools/rbd_mirror/ClusterWatcher.cc:      derr << "Error accessing pool " << pool_name << cpp_strerror(r) << dendl;
./tools/rbd_mirror/pool_watcher/RefreshImagesRequest.cc:    derr << "failed to list mirrored images: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/PoolReplayer.cc:    derr << "error initializing leader watcher: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/PoolReplayer.cc:    derr << "error initializing cluster handle for " << description << dendl;
./tools/rbd_mirror/PoolReplayer.cc:    derr << "failed to list namespaces: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/PoolReplayer.cc:  derr << "remote pool metadata updated unexpectedly" << dendl;
./tools/rbd_mirror/image_deleter/SnapshotPurgeRequest.cc:    derr << "failed to acquire exclusive lock: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/SnapshotPurgeRequest.cc:    derr << "failed to get snap namespace: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/SnapshotPurgeRequest.cc:    derr << "failed to get snap name: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/SnapshotPurgeRequest.cc:    derr << "lost exclusive lock" << dendl;
./tools/rbd_mirror/image_deleter/SnapshotPurgeRequest.cc:    derr << "failed to unprotect snapshot: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/SnapshotPurgeRequest.cc:    derr << "lost exclusive lock" << dendl;
./tools/rbd_mirror/image_deleter/SnapshotPurgeRequest.cc:    derr << "failed to remove snapshot: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/SnapshotPurgeRequest.cc:    derr << "failed to close: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/TrashMoveRequest.cc:    derr << "failed to open image: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/TrashMoveRequest.cc:    derr << "cannot move v1 image to trash" << dendl;
./tools/rbd_mirror/image_deleter/TrashMoveRequest.cc:    derr << "failed to reset journal: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/TrashMoveRequest.cc:      derr << "exclusive lock feature not enabled" << dendl;
./tools/rbd_mirror/image_deleter/TrashMoveRequest.cc:    derr << "failed to acquire exclusive lock: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/TrashMoveRequest.cc:    derr << "failed to move image to trash: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/TrashMoveRequest.cc:    derr << "failed to close image: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/TrashMoveRequest.cc:    derr << "failed to notify trash watchers: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/TrashRemoveRequest.cc:    derr << "failed to purge image snapshots: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/TrashRemoveRequest.cc:    derr << "failed to notify trash watchers: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/TrashWatcher.cc:    derr << "failed to create trash object: " << cpp_strerror(r) << dendl;
./tools/rbd_mirror/image_deleter/TrashWatcher.cc:    derr << "failed to retrieve trash directory: " << cpp_strerror(r) << dendl;
./mon/OSDMonitor.cc:    derr << __func__ << " not using pcm and rocksdb" << dendl;
./mon/OSDMonitor.cc:      derr << __func__ << " mon_debug_no_require_quincy and pacific=true" << dendl;
./mon/OSDMonitor.cc:      derr << __func__ << " mon_debug_no_require_quincy=true" << dendl;
./mon/OSDMonitor.cc:    derr << __func__ << " not using rocksdb" << dendl;
./mon/OSDMonitor.cc:	  derr << __func__ << " invalid purged_snaps key '" << k << "'" << dendl;
./mon/OSDMonitor.cc:    derr << __func__ << " unable to read osdmap version manifest" << dendl;
./mon/OSDMonitor.cc:    derr << __func__ << " pool for " << m->pgid << " dne" << dendl;
./mon/OSDMonitor.cc:    derr << " OSD trying to merge wrong pgid " << m->pgid << dendl;
./mon/OSDMonitor.cc:    derr << __func__ << " injecting pg merge pg_num bounce" << dendl;
./mon/OSDMonitor.cc:      derr << __func__ << " unable to parse key '" << it->key() << "'" << dendl;
./mon/OSDMonitor.cc:    derr << __func__ << " no session" << dendl;
./mon/OSDMonitor.cc:    derr << __func__ << " invalid k '" << gotk << "'" << dendl;
./mon/OSDMonitor.cc:    derr << __func__ << " no session" << dendl;
./mon/OSDMonitor.cc:    derr << "definitely_dead " << (int)definitely_dead << dendl;
./mon/MgrStatMonitor.cc:    derr << "Unhandled message type " << m->get_type() << dendl;
./mon/MgrStatMonitor.cc:    derr << "Unhandled message type " << m->get_type() << dendl;
./mon/MgrMonitor.cc:        derr << "Failed to load mgr commands: " << cpp_strerror(r) << dendl;
./mon/MgrMonitor.cc:      derr << "Unhandled message type " << m->get_type() << dendl;
./mon/MgrMonitor.cc:      derr << "Unhandled message type " << m->get_type() << dendl;
./mon/ElectionLogic.cc:    lderr(cct) << "I got a propose from my own rank, hopefully this is startup weirdness,dropping" << dendl;
./mon/LogMonitor.cc:      derr << "full " << full_tail << dendl;
./mon/LogMonitor.cc:    derr << __func__ << " error parsing 'mon_cluster_log_to_syslog'" << dendl;
./mon/LogMonitor.cc:    derr << __func__ << " error parsing 'mon_cluster_log_file'" << dendl;
./mon/HealthMonitor.cc:    derr << "Unhandled message type " << m->get_type() << dendl;
./mon/MonClient.cc:    lderr(cct) << __func__ << " cannot identify monitors to contact" << dendl;
./mon/MonClient.cc:    lderr(cct) << __func__ << " failed to get config" << dendl;
./mon/MonClient.cc:      lderr(cct) << "keyring not found" << dendl;
./mon/MonClient.cc:    lderr(cct) << __func__ << " NOTE: no keyring found; disabled cephx authentication" << dendl;
./mon/MonClient.cc:    lderr(cct) << __func__ << " but no auth handler is set up" << dendl;
./mon/MonClient.cc:    lderr(cct) << __func__ << " no authorizer?" << dendl;
./mon/MonClient.cc:    lderr(cct) << __func__ << " handle_response returned " << r << dendl;
./mon/MDSMonitor.cc:	derr << "Missing health data for MDS " << gid << dendl;
./mon/Paxos.cc:      derr << "lease_expire from " << lease->get_source_inst() << " is " << diff << " seconds in the past; mons are probably laggy (or possibly clocks are too skewed)" << dendl;
./mon/ConfigMonitor.cc:      derr << __func__ << " invalid mask for key " << key << dendl;
./mon/ConfigMonitor.cc:	derr << __func__ << " failure decoding changeset " << v << dendl;
./mon/Monitor.cc:	derr << "get_device_id failed on " << devname << ": " << err << dendl;
./mon/Monitor.cc:  derr << "*** Got Signal " << sig_str(signum) << " ***" << dendl;
./mon/Monitor.cc:    generic_derr << "ERROR: on disk data includes unsupported features: " << diff << dendl;
./mon/Monitor.cc:    derr << "option sanitization failed!" << dendl;
./mon/Monitor.cc:      derr << "commit suicide!" << dendl;
./mon/Monitor.cc:	derr << "unable to load initial keyring " << g_conf()->keyring << dendl;
./mon/Monitor.cc:      derr << "current monmap has " << err.str() << " stopping." << dendl;
./mon/Monitor.cc:    derr << "invalid map type " << m->what << dendl;
./mon/Monitor.cc:    derr << "error: unable to parse uuid" << dendl;
./mon/Monitor.cc:      derr << "error decoding provided osdmap: " << e.what() << dendl;
./mon/Monitor.cc:	derr << "unable to load initial keyring " << g_conf()->keyring << dendl;
./mon/Monitor.cc:    derr << __func__ << " no authorizer?" << dendl;
./os/FuseStore.cc:    derr << __func__ << " failed to parse args" << dendl;
./os/FuseStore.cc:    derr << __func__ << " fuse_new failed" << dendl;
./os/FuseStore.cc:    derr << __func__ << " fuse_mount failed" << dendl;
./os/FuseStore.cc:    derr << __func__ << " fuse_mount failed" << dendl;
./os/FuseStore.cc:    derr << __func__ << " fuse_new failed" << dendl;
./os/FuseStore.cc:    derr << __func__ << " got " << cpp_strerror(r) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": failed to open base dir " << basedir << ": " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": failed to open " << fsid_fn << ": " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:      derr << __FUNC__ << ": on-disk fsid " << old_fsid << " != provided " << fsid << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": deprecated btrfs support is not enabled" << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": failed to create current/ " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:	  derr << __FUNC__ << ": failed to create snap_1: " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": failed to create " << cct->_conf->filestore_omap_backend << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": failed to open " << omap_fsid_fn << ": " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": open error: " << cpp_strerror(err) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": read error: " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:    derr <<__FUNC__ << ": deprecated btrfs support is not enabled" << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": detect_features error: " << cpp_strerror(r) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": unable to create " << fn << ": " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": failed to open " << drop_caches_file << ": " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": failed to write to " << drop_caches_file << ": " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:      derr << "The store_version file doesn't exist." << dendl;
./os/filestore/FileStore.cc:    derr << "ObjectStore is old at version " << version << ".  Please upgrade to firefly v0.80.x, convert your store, and then upgrade."  << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": error reading " << current_op_seq_fn << ": " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": lock_fsid failed" << dendl;
./os/filestore/FileStore.cc:      derr << __FUNC__ << ": error in _list_snaps: "<< cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:    derr << "rollback to cluster snapshot '" << m_osd_rollback_to_cluster_snap << "': not found" << dendl;
./os/filestore/FileStore.cc:	    derr << "ERROR: " << nosnapfn << " exists, not rolling back to avoid losing new data" << dendl;
./os/filestore/FileStore.cc:	    derr << "Force rollback to old snapshotted version with 'osd use stale snap = true'" << dendl;
./os/filestore/FileStore.cc:	    derr << "config option for --osd-use-stale-snap startup argument." << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": error opening: " << current_fn << ": " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": read_op_seq failed" << dendl;
./os/filestore/FileStore.cc:    derr << "mount initial op seq is 0; something is wrong" << dendl;
./os/filestore/FileStore.cc:      derr << __FUNC__ << ": failed to create current/nosnap" << dendl;
./os/filestore/FileStore.cc:      derr << __FUNC__ << ": Error creating " << superblock.omap_backend << dendl;
./os/filestore/FileStore.cc:      derr << __FUNC__ << ": Error initializing omap_store: " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:      derr << __FUNC__ << ": Error initializing DBObjectMap: " << ret << dendl;
./os/filestore/FileStore.cc:      derr << err2.str() << dendl;
./os/filestore/FileStore.cc:      derr << "Error " << ret << " while listing collections" << dendl;
./os/filestore/FileStore.cc:      derr << __FUNC__ << ": failed to open journal " << journalpath << ": " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:      derr << err2.str() << dendl;
./os/filestore/FileStore.cc:      derr << "error converting store" << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": omap sync error " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": sync_filesystem error " << cpp_strerror(ret) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": " << cid << " error " << cpp_strerror(err) << dendl;
./os/filestore/FileStore.cc:    derr << __func__ << " fsync failed: " << cpp_strerror(errno) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": " << cid << " error " << cpp_strerror(err) << dendl;
./os/filestore/FileStore.cc:    derr << __func__ << " fsync failed: " << cpp_strerror(errno) << dendl;
./os/filestore/FileStore.cc:    derr << "fsetxattr " << REPLAY_GUARD_XATTR << " got " << cpp_strerror(r) << dendl;
./os/filestore/FileStore.cc:    derr << __func__ << " fsync failed: " << cpp_strerror(errno) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": " << cid << " error " << cpp_strerror(err) << dendl;
./os/filestore/FileStore.cc:    derr << "fsetxattr " << REPLAY_GUARD_XATTR << " got " << cpp_strerror(r) << dendl;
./os/filestore/FileStore.cc:    derr << __func__ << " fsync failed: " << cpp_strerror(errno) << dendl;
./os/filestore/FileStore.cc:      derr << "bad op " << op->op << dendl;
./os/filestore/FileStore.cc:      derr << __FUNC__ << ": fstat error at " << to << " " << cpp_strerror(r) << dendl;
./os/filestore/FileStore.cc:        derr << __FUNC__ << ": ftruncate error at " << dstoff+len << " " << cpp_strerror(r) << dendl;
./os/filestore/FileStore.cc:      derr << " pipe " << " got " << cpp_strerror(e) << dendl;
./os/filestore/FileStore.cc:      derr << "lseek64 to " << srcoff << " got " << cpp_strerror(r) << dendl;
./os/filestore/FileStore.cc:      derr << "lseek64 to " << dstoff << " got " << cpp_strerror(r) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": short source tolerated because we are replaying" << dendl;
./os/filestore/FileStore.cc:	derr << errstream.str() << dendl;
./os/filestore/FileStore.cc:	  derr << "Error during write_op_seq: " << cpp_strerror(err) << dendl;
./os/filestore/FileStore.cc:	    derr << "snap create '" << s << "' got error " << err << dendl;
./os/filestore/FileStore.cc:	    derr << "ioctl WAIT_SYNC got " << cpp_strerror(err) << dendl;
./os/filestore/FileStore.cc:	  derr << "object_map sync got " << cpp_strerror(err) << dendl;
./os/filestore/FileStore.cc:	  derr << "syncfs got " << cpp_strerror(err) << dendl;
./os/filestore/FileStore.cc:	  derr << "Error during write_op_seq: " << cpp_strerror(err) << dendl;
./os/filestore/FileStore.cc:	  derr << "Error during fsync of op_seq: " << cpp_strerror(err) << dendl;
./os/filestore/FileStore.cc:	    derr << "unable to destroy snap '" << s << "' got " << cpp_strerror(err) << dendl;
./os/filestore/FileStore.cc:    derr << __FUNC__ << ": " << name << " failed: " << cpp_strerror(r) << dendl;
./os/filestore/FileStore.cc:      derr << __FUNC__ << ": chain_setxattr returned " << r << dendl;
./os/filestore/FileStore.cc:    derr << "tried opening directory " << fn << ": " << cpp_strerror(-r) << dendl;
./os/filestore/FileStore.cc:	derr << __func__ << " path length overrun: " << n << dendl;
./os/filestore/FileStore.cc:	derr << "stat on " << filename << ": " << cpp_strerror(-r) << dendl;
./os/filestore/FileStore.cc:      derr << "ignoring invalid collection '" << de->d_name << "'" << dendl;
./os/filestore/FileStore.cc:    derr << "trying readdir " << fn << ": " << cpp_strerror(r) << dendl;
./os/filestore/FileStore.cc:      derr << __FUNC__ << ": KILLING" << dendl;
./os/filestore/BtrfsFileStoreBackend.cc:	derr << "btrfs SNAP_DESTROY ioctl not supported; you need a kernel newer than 2.6.32" << dendl;
./os/filestore/FileJournal.cc:    derr << "FileJournal::_open: unable to fstat journal: " << cpp_strerror(ret) << dendl;
./os/filestore/FileJournal.cc:	  derr << "FileJournal::_open: unable to setup io_context " << cpp_strerror(-ret) << dendl;
./os/filestore/FileJournal.cc:    derr << "FileJournal::_open_file : zeroing journal" << dendl;
./os/filestore/FileJournal.cc:    derr << "read_header error decoding journal header" << dendl;
./os/filestore/FileJournal.cc:    derr << "read_header appears to have gibberish flags; assuming 0" << dendl;
./os/filestore/FileJournal.cc:    derr << "FileJournal::write_bl : lseek64 failed " << cpp_strerror(ret) << dendl;
./os/filestore/FileJournal.cc:    derr << "FileJournal::write_bl : write_fd failed: " << cpp_strerror(ret) << dendl;
./os/filestore/FileJournal.cc:      derr << __func__ << " fsync/fdatasync failed: " << cpp_strerror(errno) << dendl;
./os/filestore/FileJournal.cc:	derr << "FileJournal::do_aio_write: write_aio_bl(header) failed" << dendl;
./os/filestore/FileJournal.cc:      derr << "io_getevents got " << cpp_strerror(r) << dendl;
./os/filestore/FileJournal.cc:    derr << "do_read_entry(" << pos << "): " << ss.str() << dendl;
./os/filestore/LFNIndex.cc:    derr << __func__ << " fsync failed: " << cpp_strerror(errno) << dendl;
./os/filestore/WBThrottle.cc:      lderr(cct) << "WBThrottle fsync failed: " << cpp_strerror(errno) << dendl;
./os/filestore/GenericFileStoreBackend.cc:    derr << "detect_features: unable to create " << fn << ": " << cpp_strerror(fd) << dendl;
./os/filestore/GenericFileStoreBackend.cc:      derr << "detect_features: failed to lseek " << fn << ": " << cpp_strerror(r) << dendl;
./os/filestore/GenericFileStoreBackend.cc:      derr << "detect_features: failed to write to " << fn << ": " << cpp_strerror(r) << dendl;
./os/filestore/GenericFileStoreBackend.cc:        derr << "detect_features: failed to lseek " << fn << ": " << cpp_strerror(-errno) << dendl;
./os/filestore/GenericFileStoreBackend.cc:    derr << __func__ << " got " << cpp_strerror(r) << dendl;
./os/filestore/GenericFileStoreBackend.cc:    derr << __func__ << " got " << cpp_strerror(r) << dendl;
./os/filestore/HashIndex.cc:    derr << __func__ << " error reading settings: " << cpp_strerror(r) << dendl;
./os/filestore/DBObjectMap.cc:      derr << "unexpected null at " << (int)(s-in.c_str()) << dendl;
./os/filestore/DBObjectMap.cc:    derr << "unexpected null at " << (int)(s-in.c_str()) << dendl;
./os/filestore/DBObjectMap.cc:      derr << "hash value is not 8 chars" << dendl;
./os/filestore/DBObjectMap.cc:    derr << "missing final . and shard id at " << (int)(s-in.c_str()) << dendl;
./os/filestore/DBObjectMap.cc:	derr << __func__ << " bad key '" << iter->key() << "'" << dendl;
./os/filestore/DBObjectMap.cc:    derr << ss.str() << dendl;
./os/memstore/MemStore.cc:  derr << path << dendl;
./os/memstore/MemStore.cc:      derr << "bad op " << op->op << dendl;
./os/bluestore/BlueStore.cc:      derr << "  r " << r << dendl;
./os/bluestore/BlueStore.cc:      derr << "key " << pretty_binary_string(*key) << dendl;
./os/bluestore/BlueStore.cc:      derr << "oid " << oid << dendl;
./os/bluestore/BlueStore.cc:      derr << "  t " << t << dendl;
./os/bluestore/BlueStore.cc:        derr << __func__ << " " << *i << dendl;
./os/bluestore/BlueStore.cc:	    derr << __func__ << "  encode_some needs reshard" << dendl;
./os/bluestore/BlueStore.cc:  /*derr << __func__ << bl << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " freelist init failed: " << cpp_strerror(r) << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " " << cpp_strerror(err) << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " failed: " << cpp_strerror(ret) << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " unparsable uuid " << fsid_str << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " fsid truncate failed: " << cpp_strerror(r) << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " fsid write failed: " << cpp_strerror(r) << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " fsid fsync failed: " << cpp_strerror(r) << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " failed bluefs mount: " << cpp_strerror(r) << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " unable to read 'bluefs' meta" << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " expected bluestore, but type is " << type << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " unable to read 'kv_backend' meta" << dendl;
./os/bluestore/BlueStore.cc:      derr << " backend must be rocksdb to use bluefs" << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " error creating db" << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " failed to prepare db environment: " << err.str() << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " erroring opening db: " << err.str() << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " unrecognized collection " << it->key() << dendl;
./os/bluestore/BlueStore.cc:        derr << __func__ << " unrecognized collection " << it->key() << dendl;
./os/bluestore/BlueStore.cc:          derr << __func__ << " fsck found " << r << " errors" << dendl;
./os/bluestore/BlueStore.cc:	derr << __func__ << " expected bluestore, but type is " << type << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " error writing fsid: " << cpp_strerror(r) << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " fsck found " << rc << " errors" << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " failed, " << cpp_strerror(r) << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " bluefs isn't configured, can't add new device " << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " failed, " << cpp_strerror(r) << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " bluefs isn't configured, can't add new device " << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " failed during BlueFS migration, " << cpp_strerror(r) << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " bluefs isn't configured, can't add new device " << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " failed during BlueFS migration, " << cpp_strerror(r) << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " fsck found " << rc << " errors" << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " fsck found " << rc << " errors" << dendl;
./os/bluestore/BlueStore.cc:      derr << "more error lines skipped..." << dendl; \
./os/bluestore/BlueStore.cc:      derr << " got " << r << " " << cpp_strerror(r) << dendl;
./os/bluestore/BlueStore.cc:        derr << "fsck error: missing " << *sbi.sb << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " " << c->cid << " " << oid << " INJECT EIO" << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " " << c->cid << " " << oid << " INJECT EIO" << dendl;
./os/bluestore/BlueStore.cc:        derr << __func__ << " bdev-read failed: " << cpp_strerror(r) << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " injecting bluestore checksum verifcation error" << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " failed with exit code: " << cpp_strerror(r) << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " can't load decompressor " << alg_name << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " decompression failed with exit code " << r << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " " << c->cid << " " << oid << " INJECT EIO" << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " " << c->cid << " " << oid << " INJECT EIO" << dendl;
./os/bluestore/BlueStore.cc:    derr << __func__ << " " << c->cid << " " << oid << " INJECT EIO" << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " unable to read nid_max" << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " unable to read blobid_max" << dendl;
./os/bluestore/BlueStore.cc:	derr << __func__ << " unable to read ondisk_format" << dendl;
./os/bluestore/BlueStore.cc:	  derr << __func__ << " unable to read compat_ondisk_format" << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " unable to read min_alloc_size" << dendl;
./os/bluestore/BlueStore.cc:	  derr << __func__ << " failed to read min_min_alloc_size" << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " bad op " << op->op << dendl;
./os/bluestore/BlueStore.cc:        derr << msg << dendl;
./os/bluestore/BlueStore.cc:      derr << __func__ << " stray shared blobs on " << p.first << dendl;
./os/bluestore/BlueFS.cc:    derr << __func__ << " failed to open super: " << cpp_strerror(r) << dendl;
./os/bluestore/BlueFS.cc:    derr << __func__ << " failed to replay log: " << cpp_strerror(r) << dendl;
./os/bluestore/BlueFS.cc:      derr << __func__ << " memorized layout doesn't fit current one" << dendl;
./os/bluestore/BlueFS.cc:    derr << __func__ << " failed to open super: " << cpp_strerror(r) << dendl;
./os/bluestore/BlueFS.cc:    derr << __func__ << " failed to replay log: " << cpp_strerror(r) << dendl;
./os/bluestore/BitmapFreelistManager.cc:    derr << __func__ << " missing size meta in DB" << dendl;
./os/bluestore/BitmapFreelistManager.cc:      derr << __func__ << " unrecognized meta " << k << dendl;
./os/kstore/KStore.cc:      derr << "  r " << r << dendl;
./os/kstore/KStore.cc:      derr << "key " << pretty_binary_string(*key) << dendl;
./os/kstore/KStore.cc:      derr << "oid " << oid << dendl;
./os/kstore/KStore.cc:      derr << "  t " << t << dendl;
./os/kstore/KStore.cc:    derr << __func__ << " " << cpp_strerror(err) << dendl;
./os/kstore/KStore.cc:    derr << __func__ << " failed: " << cpp_strerror(ret) << dendl;
./os/kstore/KStore.cc:    derr << __func__ << " unparsable uuid " << fsid_str << dendl;
./os/kstore/KStore.cc:    derr << __func__ << " fsid truncate failed: " << cpp_strerror(r) << dendl;
./os/kstore/KStore.cc:    derr << __func__ << " fsid write failed: " << cpp_strerror(r) << dendl;
./os/kstore/KStore.cc:    derr << __func__ << " fsid fsync failed: " << cpp_strerror(r) << dendl;
./os/kstore/KStore.cc:      derr << __func__ << " uanble to read 'kv_backend' meta" << dendl;
./os/kstore/KStore.cc:    derr << __func__ << " error creating db" << dendl;
./os/kstore/KStore.cc:    derr << __func__ << " erroring opening db: " << err.str() << dendl;
./os/kstore/KStore.cc:      derr << __func__ << " unrecognized collection " << it->key() << dendl;
./os/kstore/KStore.cc:    derr << __func__ << " error writing fsid: " << cpp_strerror(r) << dendl;
./os/kstore/KStore.cc:      derr << "bad op " << op->op << dendl;
./msg/async/PosixStack.cc:    lderr(cct) << __func__ << " unable to listen on " << sa << ": " << cpp_strerror(r) << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " " << e.what() << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " failed to decrypt frame payload" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " decode banner payload len failed " << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " decode banner payload failed " << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in hello exchange state!" << dendl;
./msg/async/ProtocolV2.cc:      lderr(cct) << __func__ << " not in ready state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in ready state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in ready state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in ready state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in auth connect state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in auth connect state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in auth connect state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in session connect state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in session reconnect state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in session reconnect state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in session reconnect state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in session (re)connect state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in session reconnect state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in session connect state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in auth accept state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in auth accept more state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in session accept state!" << dendl;
./msg/async/ProtocolV2.cc:    lderr(cct) << __func__ << " not in session accept state!" << dendl;
./msg/async/net_handler.cc:    lderr(cct) << __func__ << " couldn't create socket " << cpp_strerror(r) << dendl;
./msg/async/net_handler.cc:    lderr(cct) << __func__ << " fcntl(F_GETFL) failed: " << cpp_strerror(r) << dendl;
./msg/async/net_handler.cc:    lderr(cct) << __func__ << " fcntl(F_SETFL,O_NONBLOCK): " << cpp_strerror(r) << dendl;
./msg/async/ProtocolV1.cc:    lderr(cct) << __func__ << " decode peer addr failed " << dendl;
./msg/async/ProtocolV1.cc:    lderr(cct) << __func__ << " decode peer_addr failed " << dendl;
./msg/async/dpdk/DPDK.cc:    lderr(cct) << __func__ << " can't start port " << _port_idx << dendl;
./msg/async/dpdk/DPDK.cc:    lderr(cct) << __func__ << " port link up failed " << _port_idx << dendl;
./msg/async/dpdk/DPDK.cc:      lderr(cct) << __func__ << " Failed to create mempool for rx" << dendl;
./msg/async/dpdk/DPDK.cc:      lderr(cct) << __func__ << " cannot initialize rx queue" << dendl;
./msg/async/dpdk/DPDK.cc:        lderr(cct) << __func__ << " done port " << _port_idx << " link down" << dendl;
./msg/async/dpdk/DPDK.cc:    lderr(cct) << __func__ << " cannot initialize mbuf pools" << dendl;
./msg/async/dpdk/DPDK.cc:      lderr(cct) << __func__ << " Failed to create mempool for Tx" << dendl;
./msg/async/dpdk/DPDK.cc:      lderr(cct) << __func__ << " cannot initialize tx queue" << dendl;
./msg/async/dpdk/DPDKStack.cc:      lderr(cct) << __func__ << " init_port_fini failed " << dendl;
./msg/async/dpdk/DPDKStack.cc:  //   lderr(cct) << __func__ << " no matched address for " << sa << dendl;
./msg/async/dpdk/DPDKStack.cc:    lderr(cct) << __func__ << " init dpdk rte failed, r=" << r << dendl;
./msg/async/dpdk/DPDKStack.cc:      lderr(cct) << __func__ << " remote launch failed, r=" << r << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:      lderr(cct) << __func__ << " queue pair create failed" << dendl;
./msg/async/rdma/RDMAServerSocketImpl.cc:    lderr(cct) << __func__ << " unable to listen on " << sa << ": " << cpp_strerror(errno) << dendl;
./msg/async/rdma/RDMAServerSocketImpl.cc:    lderr(cct) << __func__ << " server->qp is null" << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__  << " query port failed  " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:      lderr(cct) << __func__  << " query gid of port " << port_num << " index " << gid_idx << " failed  " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:      lderr(cct) << __func__  << " query gid attributes of port " << port_num << " index " << gid_idx << " failed  " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__ << " Requested local GID was not found in GID table" << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__  << " query gid failed  " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__ << " failed to query rdma device. " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__ << " failed to query rdma device. " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__ << "  port not found" << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__ << " invalid queue pair type" << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:      lderr(cct) << __func__ << " failed to transition to ERROR state: " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__ << " failed to transition to RTS state: " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__ << " failed to transition to RTR state: " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:      lderr(cct) << __func__ << " failed to create queue pair" << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:      lderr(cct) << __func__ << " send got bad length (" << r << ") " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__ << " failed to send a beacon: " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:      lderr(cct) << __func__ << " failed to destroy cc: " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:      lderr(cct) << __func__ << " failed to destroy cq: " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__ << " ibv_req_notify_cq failed: " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__ << " failed to notify cq: " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__ << " failed to allocate infiniband protection domain: " << cpp_strerror(errno) << dendl;
./msg/async/rdma/Infiniband.cc:       lderr(cct) << __func__ << " failed to export RDMA_HUGEPAGES_SAFE. On RDMA must be exported before using huge pages. Application aborts." << dendl;
./msg/async/rdma/Infiniband.cc:      lderr(cct) << __func__ << " failed to call ibv_for_init(). On RDMA must be called before fork. Application aborts." << dendl;
./msg/async/rdma/Infiniband.cc:    lderr(cct) << __func__ << " Out of max memory region size " << dendl;
./msg/async/rdma/RDMAIWARPServerSocketImpl.cc:      lderr(cct) << __func__ << " failed to switch event channel to non-block, close event channel " << dendl;
./msg/async/rdma/RDMAIWARPConnectedSocketImpl.cc:    lderr(cct) << __func__ << " failed to resolve addr" << dendl;
./msg/async/rdma/RDMAIWARPConnectedSocketImpl.cc:        lderr(cct) << __func__ << " failed to resolve rdma addr" << dendl;
./msg/async/rdma/RDMAIWARPConnectedSocketImpl.cc:        lderr(cct) << __func__ << " failed to alloc resource while resolving the route" << dendl;
./msg/async/rdma/RDMAIWARPConnectedSocketImpl.cc:        lderr(cct) << __func__ << " failed to connect remote rdma port" << dendl;
./msg/async/rdma/RDMAIWARPConnectedSocketImpl.cc:      lderr(cct) << __func__ << " rdma connection rejected" << dendl;
./msg/async/rdma/RDMAStack.cc:            lderr(cct) << __func__ << " poll failed " << r << dendl;
./msg/async/rdma/RDMAStack.cc:    lderr(cct) << __func__ << " QP [" << qpn << "] is not registered." << dendl;
./msg/async/rdma/RDMAStack.cc:    lderr(cct) << __func__ << " QP [" << qpn << "] is not registered." << dendl;
./msg/async/EventEpoll.cc:    lderr(cct) << __func__ << " unable to malloc memory. " << dendl;
./msg/async/AsyncMessenger.cc:	    lderr(msgr->cct) << "Proccessor accept has encountered enough error numbers, just do ceph_abort()." << dendl;
./msg/async/AsyncMessenger.cc:	    lderr(msgr->cct) << "Proccessor accept has encountered enough error numbers, just do ceph_abort()." << dendl;
./msg/async/AsyncMessenger.cc:      lderr(cct) << __func__ << " postponed bind failed" << dendl;
./msg/async/Event.cc:    lderr(cct) << __func__ << " failed to create event driver " << dendl;
./msg/async/Event.cc:    lderr(cct) << __func__ << " failed to init event driver." << dendl;
./msg/async/Event.cc:    lderr(cct) << __func__ << " can't create notify pipe: " << cpp_strerror(e) << dendl;
./msg/async/Event.cc:      lderr(cct) << __func__ << " event count is exceed." << dendl;
./msg/Messenger.cc:  lderr(cct) << "unrecognized ms_type '" << type << "'" << dendl;
./erasure-code/jerasure/jerasure_init.cc:      derr << "failed to galois_init_default_field(" << words[i] << ")" << dendl;
./erasure-code/shec/ErasureCodeShec.cc:	derr << "could not convert k=" << value_k << "to int" << dendl;
./erasure-code/shec/ErasureCodeShec.cc:	derr << "could not convert m=" << value_m << "to int" << dendl;
./erasure-code/shec/ErasureCodeShec.cc:	derr << "could not convert c=" << value_c << "to int" << dendl;
./erasure-code/shec/ErasureCodeShec.cc:      derr << "could not convert w=" << value_w << "to int" << dendl;
./mds/MDSDaemon.cc:    derr << "ERROR: failed to init monc: " << cpp_strerror(-r) << dendl;
./mds/MDSDaemon.cc:    derr << "ERROR: failed to authenticate: " << cpp_strerror(-r) << dendl;
./mds/MDSDaemon.cc:      derr << "unable to obtain rotating service keys; retrying" << dendl;
./mds/MDSDaemon.cc:  derr << "*** got signal " << sig_str(signum) << " ***" << dendl;
./mds/MDSRank.cc:    derr << "we have been blocklisted (fenced), respawning..." << dendl;
./mds/MDSRank.cc:    derr << "unhandled write error " << cpp_strerror(err) << ", suicide..." << dendl;
./mds/MDSRank.cc:    derr << "unhandled write error " << cpp_strerror(err) << ", force readonly..." << dendl;
./mds/MDSRank.cc:    derr << "unhandled write error " << cpp_strerror(err) << ", ignore..." << dendl;
./mds/MDSRank.cc:      derr << "unrecognized message " << *m << dendl;
./mds/MDSRank.cc:    derr << "bad MDS target " << target << dendl;
./mds/MDSRank.cc:    derr << "Bath path '" << path << "'" << dendl;
./mds/MDSRank.cc:    derr << "bad export_dir path dirfrag frag_t() or dir not auth" << dendl;
./mds/MDSRank.cc:      derr << ": failed to update service daemon status: " << cpp_strerror(r) << dendl;
./mds/JournalPointer.cc:    derr << "Error writing pointer object '" << object_id << "': " << cpp_strerror(write_result) << dendl;
./mds/Locker.cc:    derr << "locker unknown message " << m->get_type() << dendl;
./mds/MDSPinger.cc:    derr << ": rank=" << rank << " was never sent ping request." << dendl;
./mds/Server.cc:    derr << "server unknown message " << m->get_type() << dendl;
./mds/Server.cc:  derr << ": unhandled validation for: " << xattr_name << dendl;
./mds/Server.cc:    derr << "mirror info parse error" << dendl;
./mds/Server.cc:    derr << "inconsistent mirror info state (" << v1 << "," << v2 << ")" << dendl;
./mds/MDLog.cc:      derr << "we have been blocklisted (fenced), respawning..." << dendl;
./mds/MDLog.cc:      derr << "unhandled error " << cpp_strerror(r) << ", shutting down..." << dendl;
./mds/MDLog.cc:    derr << "Blocklisted during JournalPointer read!  Respawning..." << dendl;
./mds/MDLog.cc:      derr << "Blocklisted during journal recovery!  Respawning..." << dendl;
./mds/MDLog.cc:      derr << "Failed to erase journal " << jp.back << ": " << cpp_strerror(erase_result) << dendl;
./mds/MDLog.cc:    derr << "Blocklisted during journal recovery!  Respawning..." << dendl;
./mds/PurgeQueue.cc:      derr << "Error " << r << " loading Journaler" << dendl;
./mds/PurgeQueue.cc:      derr << "Error " << r << " recovering write_pos" << dendl;
./mds/PurgeQueue.cc:      derr << "Error " << r << " recovering write_pos" << dendl;
./mds/PurgeQueue.cc:    derr << " r = " << r << dendl;
./mds/PurgeQueue.cc:      derr << "Invalid purge op: " << op.type << dendl;
./mds/SessionMap.cc:      derr << "Corrupt entity name '" << i->first << "' in sessionmap" << dendl;
./mds/SessionMap.cc:    derr << "_load_finish got " << cpp_strerror(operation_r) << dendl;
./mds/SessionMap.cc:      derr << __func__ << ": header error: " << cpp_strerror(header_r) << dendl;
./mds/SessionMap.cc:    derr << "_load_finish got " << cpp_strerror(r) << dendl;
./mds/OpenFileTable.cc:    derr << __func__ << " got " << cpp_strerror(r) << dendl;
./mds/OpenFileTable.cc:    derr << __func__ << " got " << cpp_strerror(op_r) << dendl;
./mds/OpenFileTable.cc:    derr << __func__ << ": corrupted header/values: " << e.what() << dendl;
./mds/OpenFileTable.cc:	derr << __func__ << ": corrupted journal: " << e.what() << dendl;
./mds/MDSTable.cc:    derr << "load_2 could not read table: " << r << dendl;
./mds/StrayManager.cc:      derr << "Rogue reference after purge to " << *dn << dendl;
./mds/Migrator.cc:    derr << "migrator unknown message " << m->get_type() << dendl;
./mds/DamageTable.cc:    derr << "Invalid type " << type << dendl;
./mds/Beacon.cc:        derr << "Client ID without session: " << client.v << dendl;
./mds/CInode.cc:    derr << "No data while reading inode " << ino() << dendl;
./mds/CInode.cc:    derr << "Corrupt inode " << ino() << ": " << err.what() << dendl;
./mds/MDSContext.cc:    derr << "MDSIOContextBase: blocklisted!  Restarting..." << dendl;
./mds/MDCache.cc:    derr << "cache unknown message " << m->get_type() << dendl;
./mds/MDCache.cc:      derr << "cache usage exceeds dump threshold" << dendl;
./mds/MDCache.cc:      derr << "failed to open " << path << ": " << cpp_strerror(errno) << dendl;
./mds/SnapServer.cc:    derr << " updating last_snap " << last_snap << " -> " << last << dendl;
./mds/SnapServer.cc:    derr << " updating snaps {" << snaps << "} -> {" << _snaps << "}" << dendl;
./ceph_fuse.cc:    derr << "fuse_parse_cmdline failed." << dendl;
./ceph_fuse.cc:       derr << "fuse_parse_cmdline failed." << dendl;
./librados/librados_c.cc:      lderr(client->cct) << warnings.str() << dendl;
./librados/RadosClient.cc:    lderr(cct) << "unable to parse address " << client_address << dendl;
./crush/CrushWrapper.cc:              lderr(cct) << __func__ << " osd " << osd << " not in bucket " << root_bucket << dendl;
./crush/CrushLocation.cc:    lderr(cct) << "error: failed to join: " << hook.err() << dendl;
./test/osd/test_ec_transaction.cc:  generic_derr << "to_read " << plan.to_read << dendl;
./test/osd/test_ec_transaction.cc:  generic_derr << "will_write " << plan.will_write << dendl;
./test/osd/test_ec_transaction.cc:  generic_derr << "to_read " << plan.to_read << dendl;
./test/osd/test_ec_transaction.cc:  generic_derr << "will_write " << plan.will_write << dendl;
./test/osd/test_ec_transaction.cc:  generic_derr << "to_read " << plan.to_read << dendl;
./test/osd/test_ec_transaction.cc:  generic_derr << "will_write " << plan.will_write << dendl;
./test/librbd/test_mock_Journal.cc:    derr << "SHUT DOWN REPLAY START" << dendl;
./test/librbd/test_mock_Journal.cc:        derr << "FLUSH START" << dendl;
./test/librbd/test_mock_Journal.cc:        derr << "FLUSH FINISH" << dendl;
./test/librbd/test_mock_Journal.cc:    derr << "SHUT DOWN REPLAY FINISH" << dendl;
./test/objectstore_bench.cc:        derr << "error parsing size: " << err << dendl;
./test/objectstore_bench.cc:        derr << "error parsing block-size: " << err << dendl;
./test/objectstore_bench.cc:      derr << "Error: can't understand argument: " << *i << "\n" << dendl;
./test/objectstore_bench.cc:      derr << "Failed to create data directory, ret = " << r << dendl;
./test/objectstore_bench.cc:       derr << "Data directory '"<<g_conf()->osd_data<<"' isn't empty, please clean it first."<< dendl;
./test/objectstore_bench.cc:      derr << "Failed to create journal directory, ret = " << r << dendl;
./test/objectstore_bench.cc:    derr << "bad objectstore type " << g_conf()->osd_objectstore << dendl;
./test/objectstore_bench.cc:    derr << "mkfs failed" << dendl;
./test/objectstore_bench.cc:    derr << "mount failed" << dendl;
./test/msgr/test_msgr.cc:    lderr(g_ceph_context) << __func__ << " start set up " << GetParam() << dendl;
./test/msgr/test_msgr.cc:    lderr(g_ceph_context) << __func__ << " " << con << dendl;
./test/msgr/test_msgr.cc:    lderr(g_ceph_context) << __func__ << " conn: " << m->get_connection() << " session " << s << " count: " << s->count << dendl;
./test/msgr/test_msgr.cc:    lderr(g_ceph_context) << __func__ << " " << con << dendl;
./test/msgr/test_msgr.cc:    lderr(g_ceph_context) << __func__ << " " << con << dendl;
./test/msgr/test_msgr.cc:    lderr(g_ceph_context) << __func__ << " conn: " << m->get_connection() << " session " << s << " count: " << s->count << dendl;
./test/msgr/test_msgr.cc:      lderr(g_ceph_context) << __func__ << " conn=" << m->get_connection() << pl << dendl;
./test/msgr/test_msgr.cc:	lderr(g_ceph_context) << __func__ << " conn=" << m->get_connection() << pl << dendl;
./test/msgr/test_msgr.cc:    lderr(g_ceph_context) << __func__ << " conn=" << m->get_connection() << " reply m=" << m << " i=" << pl.seq << dendl;
./test/msgr/test_msgr.cc:    lderr(g_ceph_context) << __func__ << " conn=" << con.get() << " send m=" << m << " i=" << pl.seq << dendl;
./test/msgr/test_msgr.cc:        lderr(g_ceph_context) << __func__ << " " << p.first << " wait " << p.second.size() << dendl;
./test/msgr/test_msgr.cc:    if (!(i % 10)) lderr(g_ceph_context) << "seeding connection " << i << dendl;
./test/msgr/test_msgr.cc:      lderr(g_ceph_context) << "Op " << i << ": " << dendl;
./test/msgr/test_msgr.cc:    if (!(i % 10)) lderr(g_ceph_context) << "seeding connection " << i << dendl;
./test/msgr/test_msgr.cc:      lderr(g_ceph_context) << "Op " << i << ": " << dendl;
./test/msgr/test_msgr.cc:    if (!(i % 10)) lderr(g_ceph_context) << "seeding connection " << i << dendl;
./test/msgr/test_msgr.cc:      lderr(g_ceph_context) << "Op " << i << ": " << dendl;
./test/msgr/test_msgr.cc:    if (!(i % 10)) lderr(g_ceph_context) << "seeding connection " << i << dendl;
./test/msgr/test_msgr.cc:      lderr(g_ceph_context) << "Op " << i << ": " << dendl;
./test/msgr/test_msgr.cc:    if (!(i % 10)) lderr(g_ceph_context) << "seeding connection " << i << dendl;
./test/msgr/test_msgr.cc:      lderr(g_ceph_context) << "Op " << i << ": " << dendl;
./test/msgr/test_msgr.cc:    if (!(i % 10)) lderr(g_ceph_context) << "seeding connection " << i << dendl;
./test/msgr/test_msgr.cc:      lderr(g_ceph_context) << "Op " << i << ": " << dendl;
./test/msgr/test_msgr.cc:    lderr(g_ceph_context) << __func__ << " " << con << dendl;
./test/msgr/test_msgr.cc:    lderr(g_ceph_context) << __func__ << " conn: " << m->get_connection() << dendl;
./test/msgr/test_msgr.cc:    lderr(g_ceph_context) << __func__ << " " << con << dendl;
./test/msgr/test_msgr.cc:    lderr(g_ceph_context) << __func__ << " " << con << dendl;
./test/msgr/test_msgr.cc:      lderr(g_ceph_context) << __func__ << " last is " << last << dendl;
./test/libcephsqlite/main.cc:    lderr(cct) << "sqlite3 config failed: " << rc << dendl;
./test/libcephsqlite/main.cc:    lderr(cct) << "could not open sqlite3: " << rc << dendl;
./test/libcephsqlite/main.cc:    lderr(cct) << "could not set cct: " << rc << dendl;
./test/fio/fio_ceph_objectstore.cc:      derr << "Engine cleanup failed with " << cpp_strerror(-r) << dendl;
./test/fio/fio_ceph_objectstore.cc:	derr << "Failure to write OSD superblock: " << cpp_strerror(-r) << dendl;
./test/fio/fio_ceph_objectstore.cc:	derr << "Engine init failed with " << cpp_strerror(-r) << dendl;
./test/fio/fio_ceph_objectstore.cc:	derr << "job cleanup failed with " << cpp_strerror(-r) << dendl;
./test/fio/fio_ceph_objectstore.cc:  derr << "WARNING: Only DDIR_READ and DDIR_WRITE are supported!" << dendl;
./test/mon/test-mon-msg.cc:    derr << __func__ << " failing monc" << dendl;
./test/testkeys.cc:    derr(0) << "couldn't encode!" << dendl;
./test/testkeys.cc:    derr(0) << "couldn't decode!" << dendl;
./test/rbd_mirror/random_write.cc:    derr << "could not initialize RADOS handle" << dendl;
./test/rbd_mirror/random_write.cc:    derr << "error connecting to local cluster" << dendl;
./test/crimson/test_messenger_peer.cc:    lderr(cct) << "[CmdSrv] unexpected policy type" << dendl;
./test/objectstore/test_memstore_clone.cc:      derr << "failed to create collection with " << cpp_strerror(r) << dendl;
./osdc/Journaler.cc:    lderr(cct) << "may got older pool id from header layout" << dendl;
./osdc/Journaler.cc:    lderr(cct) << "_finish_write_head got " << cpp_strerror(r) << dendl;
./osdc/Journaler.cc:    lderr(cct) << "_finish_flush got " << cpp_strerror(r) << dendl;
./osdc/Journaler.cc:    lderr(cct) << "_prezeroed got " << cpp_strerror(r) << dendl;
./osdc/Journaler.cc:    lderr(cct) << "_decode error from assimilate_prefetch" << dendl;
./osdc/Journaler.cc:    lderr(cct) << __func__ << ": decode error from journal_stream" << dendl;
./osdc/Journaler.cc:    lderr(cct) << __func__ << ": decode error from _is_readable" << dendl;
./osdc/Journaler.cc:    lderr(cct) << "_finish_trim got " << cpp_strerror(r) << dendl;
./osdc/Journaler.cc:  lderr(cct) << "handle_write_error " << cpp_strerror(r) << dendl;
./osdc/Objecter.cc:    lderr(cct) << __func__ << ": start " << start << " > end " << end << dendl;
./osdc/Objecter.cc:    lderr(cct) << __func__ << ": result size may not be zero" << dendl;
./osdc/Objecter.cc:    lderr(cct) << __func__ << ": SORTBITWISE cluster flag not set" << dendl;
derr << __func__ << " already have backoff for " << s << " begin " << begin	 << " " << *b << dendl;
derr << __func__ << ": queue_transaction returned "	 << cpp_strerror(r) << dendl;
derr << __func__ << " removed_snaps already contains "	     << overlap << dendl;
derr << __func__ << " purged_snaps does not contain "	     << rm << ", only " << overlap << dendl;
derr << __func__ << ": queueing trans to clean up obsolete rollback objs"	 << dendl;
derr << __func__ << ": queue_transaction got " << cpp_strerror(r)	     << dendl;
derr << info.pgid << " required past_interval bounds are"	   << " empty [" << rpib << ") but past_intervals is not: "	   << past_intervals << dendl;
derr << info.pgid << " required past_interval bounds are"	   << " not empty [" << rpib << ") but past_intervals "	   << past_intervals << " is empty" << dendl;
derr << info.pgid << " past_intervals [" << apib	   << ") start interval does not contain the required"	   << " bound [" << rpib << ") start" << dendl;
derr << info.pgid << " past_interal bound [" << apib	   << ") end does not match required [" << rpib	   << ") end" << dendl;
derr << __func__ << ": received unsolicited reservation grant from osd " << from	 << " (" << op << ")" << dendl;
derr << __func__ << ": get_hash_info(" << i << ")"	     << " returned a null pointer and there is no "	     << " way to recover from such an error in this "	     << " context" << dendl;
derr << __func__ << ": log entry " << i << " requires kraken"	     << " but overwrites are not enabled!" << dendl;
derr << "Error opening class '" << class_name << "': "           << cpp_strerror(r) << dendl;
derr << "Error finding filter '" << filter_name << "' in class "           << class_name << dendl;
derr << "Buggy class " << class_name << " failed to construct "              "filter " << filter_name << dendl;
derr << "Error initializing filter " << type << ": "         << cpp_strerror(r) << dendl;
derr << __func__ << " " << info.pgid.pgid << " does not contain "	 << head << " pg_num " << pool.info.get_pg_num() << " hash "	 << std::hex << head.get_hash() << std::dec << dendl;
derr << "do_op msg data len " << m->get_data_len()           << " > osd_max_write_size " << (cct->_conf->osd_max_write_size << 20)           << " on " << *m << dendl;
derr << __func__ << ": bytes read " << read_bl.length() << " != "	 << op.checksum.length << dendl;
derr << __func__ << std::hex << " data digest 0x" << cop->results.data_digest	 << " != source 0x" << cop->results.source_data_digest << std::dec	 << dendl;
derr << __func__ << std::hex	 << " omap digest 0x" << cop->results.omap_digest	 << " != source 0x" << cop->results.source_omap_digest	 << std::dec << dendl;
derr << __func__ << ": op " << *(std::get<0>(j)->get_req())               << " waiting on " << i.first << dendl;
derr << __func__ << ": object " << soid << " last_backfill "	       << pi.last_backfill << dendl;
  derr << __func__ << ": object added to missing set for backfill, but "	       << "is not in recovering, error!" << dendl;
derr << __func__ << " " << p->soid << " exists, but should have been "	     << "deleted" << dendl;
derr << __func__ << " " << hoid << " mask_bits " << mask_bits       << " match 0x" << std::hex << match << std::dec << " is false"       << dendl;
derr << __func__ << " found existing snaps mapped on " << oid	   << ", removing" << dendl;
derr << __func__ << " unable to load latest full map " << m->newest_map	   << dendl;
derr << "OSD::mkfs: ObjectStore::mkfs failed with error "         << cpp_strerror(ret) << dendl;
derr << "OSD::mkfs: couldn't mount ObjectStore: error "         << cpp_strerror(ret) << dendl;
derr << "provided osd id " << whoami << " != superblock's " << sb.whoami	   << dendl;
derr << "provided cluster fsid " << fsid	   << " != superblock's " << sb.cluster_fsid << dendl;
derr << "OSD::mkfs: error while writing OSD_SUPERBLOCK_GOBJECT: "	   << "queue_transaction returned " << cpp_strerror(ret) << dendl;
derr << "OSD::mkfs: failed to write fsid file: error "         << cpp_strerror(ret) << dendl;
derr << __func__ << " failed to read keyfile " << keyfile << ": "	     << err << ": " << cpp_strerror(r) << dendl;
derr << "OSD::pre_init: object store '" << dev_path << "' is "         << "currently in use. (Is ceph-osd already running?)" << dendl;
derr << __func__ << " unable to identify cluster interface '" << back_iface           << "' numa node: " << cpp_strerror(r) << dendl;
derr << __func__ << " unable to identify public interface '" << front_iface	 << "' numa node: " << cpp_strerror(r) << dendl;
derr << __func__ << " failed to set numa affinity: " << cpp_strerror(r)	     << dendl;
derr << __func__ << " failed to rmdir " << mntpath << ": "           << cpp_strerror(r) << dendl;
derr << __func__ << " unable to create " << mntpath << ": "	   << cpp_strerror(r) << dendl;
derr << "backend (" << store->get_type() << ") is unable to support max "	   << "object name[space] len" << dendl;
derr << "   osd max object name len = "	   << cct->_conf->osd_max_object_name_len << dendl;
derr << "   osd max object namespace len = "	   << cct->_conf->osd_max_object_namespace_len << dendl;
derr << "osd_check_max_object_name_len_on_startup = false, starting anyway"	   << dendl;
derr << "OSD::init: superblock says osd"	 << superblock.whoami << " but I am osd." << whoami << dendl;
  derr << __func__ << " missing pg_pool_t for deleted pool "	       << pgid.pool() << " for pg " << pgid	       << ";
please downgrade to luminous and allow "    derr << __func__ << " authentication failed: " << cpp_strerror(r)         << dendl;
derr << __func__ << " unable to update_crush_device_class: "	 << cpp_strerror(r) << dendl;
derr << __func__ << " unable to update_crush_location: "         << cpp_strerror(r) << dendl;
derr << "OSD::shutdown: error writing superblock: "	 << cpp_strerror(r) << dendl;
derr << "pgid " << pg->get_pgid() << " has ref count of "	     << pg->get_num_ref() << dendl;
  derr << __func__ << " fail: osd does not exist and created failed: "	       << cpp_strerror(r) << dendl;
derr << __func__ << " missing pool " << pgid.pool() << " tombstone"	   << dendl;
derr << __func__ << " missing ec_profile from pool " << pgid.pool()	   << " tombstone" << dendl;
derr << __func__ << " unable to peek at " << pgid << " metadata, skipping"	   << dendl;
  derr << __func__ << ": could not find map for epoch " << map_epoch	       << " on pg " << pgid << ", but the pool is not present in the "	       << "current map, so this is probably a result of bug 10617.  "	       << "Skipping the pg for now, you can use ceph-objectstore-tool "	       << "to clean it up later." << dendl;
  derr << __func__ << ": have pgid " << pgid << " at epoch "	       << map_epoch << ", but missing map.  Crashing."	       << dendl;
derr << "heartbeat_check: no reply from "             << p->second.con_front->get_peer_addr().get_sockaddr()             << " osd." << p->first             << " ever on either front or back, first ping sent "             << p->second.first_tx             << " (oldest deadline " << oldest_deadline << ")"             << dendl;
derr << "heartbeat_check: no reply from "             << p->second.con_front->get_peer_addr().get_sockaddr()	     << " osd." << p->first << " since back " << p->second.last_rx_back	     << " front " << p->second.last_rx_front	     << " (oldest deadline " << oldest_deadline << ")"             << dendl;
derr << __func__ << " reporting " << slow << " slow ops, oldest is "	     << oldest_op->get_desc() << dendl;
  derr << __func__ << " marked down "	       << osd_markdown_log.size()	       << " > osd_max_markdown_count "	       << cct->_conf->osd_max_markdown_count	       << " in last " << grace << " seconds, shutting down"	       << dendl;
derr << __func__ << " marked down:"	       << " rebind cluster_messenger failed" << dendl;
derr << __func__ << ": getgroups failed: " << cpp_strerror(-count)	   << dendl;
derr << "fuse_ll: do_init: safe_write failed with error "	   << cpp_strerror(err) << dendl;
derr << __func__ << " failed to create " << path	     << ": " << ec.message() << dendl;
derr << "rocksdb_cache_type '" << cache           << "' chosen, but RocksDB not compiled with LibTBB. "           << dendl;
  derr << __func__ << " invalid db path item " << p << " in "	       << kv_options["db_paths"] << dendl;
  derr << __func__ << " invalid db path item " << p << " in "	       << kv_options["db_paths"] << dendl;
derr << __func__ << " Failed to create rocksdb column family: "	     << cf_name << dendl;
derr << __func__ << " invalid db column family options for CF '"	   << column.name << "': " << column.options << dendl;
derr << __func__ << " extra columns in rocksdb. rocksdb columns = " << rocksdb_cfs	<< " target columns = " << columns_from_stored << dendl;
derr << __func__ << " Failed to create rocksdb column family: "		 << missing_cfs[i].name << dendl;
derr << __func__ << " error: " << s.ToString() << " code = " << s.code()         << " Rocksdb transaction: " << rocks_txc.seen.str() << dendl;
derr << __func__ << " Failed to create rocksdb column family: "	   << full_name << dendl;
derr << "ERROR: failed reading user info: uid=" << uid << " ret="	   << ret << dendl;
derr << "ERROR: target_shards.add_entry(" << entry.idx <<	") returned error: " << cpp_strerror(-ret) << dendl;
derr << "ERROR: " << __func__ << ": write() returned "         << cpp_strerror(errno) << dendl;
derr << "WARNING: radosgw frontend config found unexpected spacing around 'port' "               << "(ensure frontend port parameter has the form 'port=80' with no spaces "               << "before or after '=')" << dendl;
derr << __func__ << " failed to set numa affinity: " << cpp_strerror(r)        << dendl;
derr << "Cannot have the S3 or S3 Website enabled together with "           << "Swift API placed in the root of hierarchy" << dendl;
derr << "Placing Swift API in the root of URL hierarchy while running"             << " multi-site configuration requires another instance of RadosGW"             << " with S3 API enabled!" << dendl;
derr << "dmclock scheduler type is experimental and needs to be"	 << "set in the option enable experimental data corrupting features"	 << dendl;
derr << __func__ << " failed to set numa affinity: " << cpp_strerror(r)        << dendl;
derr << "MDS id '" << g_conf()->name << "' is invalid. "      "MDS names may not start with a numeric digit." << dendl;
derr << "mkdir(" << g_conf()->mon_data << ") : "	     << cpp_strerror(errno) << dendl;
derr << "error opening '" << g_conf()->mon_data << "': "           << cpp_strerror(-err) << dendl;
derr << "'" << g_conf()->mon_data << "' already exists and is not empty"           << ": monitor may already exist" << dendl;
derr << "error checking if '" << g_conf()->mon_data << "' is empty: "           << cpp_strerror(-err) << dendl;
derr << argv[0] << ": error reading " << osdmapfn << ": "	     << error << dendl;
derr << argv[0] << ": error opening mon data directory at '"           << g_conf()->mon_data << "': " << cpp_strerror(r) << dendl;
derr << "monitor data directory at '" << g_conf()->mon_data << "'"         << " does not exist: have you run 'mkfs'?" << dendl;
derr << "error accessing monitor data directory at '"         << g_conf()->mon_data << "': " << cpp_strerror(-err) << dendl;
derr << "monitor data directory at '" << g_conf()->mon_data      << "' is empty: have you run 'mkfs'?" << dendl;
derr << "error accessing '" << g_conf()->mon_data << "': "         << cpp_strerror(-err) << dendl;
derr << "error checking monitor data's fs stats: " << cpp_strerror(err)           << dendl;
derr << "error: monitor data filesystem reached concerning levels of"           << " available storage space (available: "           << stats.avail_percent << "% " << byte_u_t(stats.byte_avail)           << ")\nyou may adjust 'mon data avail crit' to a lower value"           << " to make this go away (default: " << g_conf()->mon_data_avail_crit           << "%)\n" << dendl;
derr << "error opening mon data directory at '"           << g_conf()->mon_data << "': " << cpp_strerror(err) << dendl;
derr << "unable to read monmap from " << inject_monmap << ": "	   << error << dendl;
  derr << "WARNING: 'mon addr' config option " << conf_addrs	       << " does not match monmap file" << std::endl	       << "         continuing with monmap configuration" << dendl;
derr << "WARNING: invalid 'mon addr' config option" << std::endl	     << "         continuing with monmap configuration" << dendl;
derr << argv[0] << ": error generating initial monmap: "             << cpp_strerror(err) << dendl;
derr << "no public_addr or public_network specified, and "	     << g_conf()->name << " not present in monmap or ceph.conf" << dendl;
derr << "Intended OpenSSL engine acceleration failed.\n"       << "set by openssl_engine_opts = "       << g_ceph_context->_conf->openssl_engine_opts       << "\ndetail error information:\n" << err << dendl;
derr << "Error: " << win32_strerror(status)         << ". Could not close registry key." << dendl;
derr << "Error: " << win32_strerror(status)         << ". Could not flush registry key." << dendl;
derr << "Error: " << win32_strerror(status)         << ". Could not set registry value: " << (char*)lpValue << dendl;
derr << "Error: " << win32_strerror(status)         << ". Could not set registry value: "         << (char*)lpValue << dendl;
derr << "Error: " << win32_strerror(status)         << ". Could not get registry value: "         << (char*)lpValue << dendl;
derr << "Error: " << win32_strerror(status)         << ". Could not get registry value: "         << (char*)lpValue << dendl;
derr << "Ignoring shutdown hook failure, marking the service as stopped."           << dendl;
derr << "Service control handler not initialized. Cannot "         << "update service status (" << current_state         << ") and exit code(" << exit_code << ")." << dendl;
derr << __func__ << " " << path             << ": Unsupported st_mode: " << stbuf.stx_mode << dendl;
derr << __func__ << " " << path             << ": Unsupported create disposition: "             << CreationDisposition << dendl;
derr << __func__ << " " << path             << ": ceph_rmdir failed. Error: " << ret << dendl;
derr << __func__ << " " << path             << ": ceph_unlink failed. Error: " << ret << dendl;
derr << __func__ << " dict item " << i	   << " not a size 2 tuple" << dendl;
derr << __func__ << " item " << i << " " << check_name	   << " value not a dict" << dendl;
derr << __func__ << " item " << i << " pair " << j	     << " not a tuple" << dendl;
derr << __func__ << " item " << i << " pair " << j	     << " not a size 2 tuple" << dendl;
  derr << __func__ << " check " << check_name	       << " severity value not string" << dendl;
  derr << __func__ << " check " << check_name	       << " summary value not [unicode] string" << dendl;
  derr << __func__ << " check " << check_name	       << " count value not int" << dendl;
  derr << __func__ << " check " << check_name	       << " detail value not list" << dendl;
    derr << __func__ << " check " << check_name		 << " detail item " << k << " not a [unicode] string" << dendl;
derr << __func__ << " check " << check_name	     << " unexpected key " << k << dendl;
derr << __func__ << " query " << query_param_name << " item " << j               << " not a dict" << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                 << " pair " << k << " not a tuple" << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                 << " pair " << k << " not a size 2 tuple" << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                   << " contains invalid param " << param_name << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                   << " contains invalid type " << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                   << " contains invalid param " << param_name << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                   << " contains invalid regex " << d.regex_str << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                   << " regex " << d.regex_str << ": no capturing groups"                   << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                 << " contains invalid param " << param_name << dendl;
derr << __func__ << " query " << query_param_name << " item " << i               << " invalid" << dendl;
derr << __func__ << " query " << query_param_name << " item " << j               << " not a string" << dendl;
derr << __func__ << " query " << query_param_name << " item " << type               << " is not valid type" << dendl;
derr << __func__ << " query " << query_param_name << " not a dict"             << dendl;
derr << __func__ << " limit item " << j << " not a size 2 tuple"               << dendl;
derr << __func__ << " " << limit_param_name << " not a string"                 << dendl;
derr << __func__ << " limit " << limit_param_name                 << " not a valid counter type" << dendl;
derr << __func__ << " " << limit_param_name << " not an int"                 << dendl;
derr << __func__ << " unknown limit param: " << limit_param_name               << dendl;
derr << __func__ << " limit order_by " << limit->order_by           << " not in performance_counter_descriptors" << dendl;
derr << __func__ << " query " << query_param_name << " item " << j               << " not a dict" << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                 << " pair " << k << " not a tuple" << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                 << " pair " << k << " not a size 2 tuple" << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                   << " contains invalid param " << param_name << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                   << " contains invalid type " << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                   << " contains invalid param " << param_name << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                   << " contains invalid regex " << d.regex_str << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                   << " regex " << d.regex_str << ": no capturing groups"                   << dendl;
derr << __func__ << " query " << query_param_name << " item " << j                 << " contains invalid param " << param_name << dendl;
derr << __func__ << " query " << query_param_name << " item " << i               << " invalid" << dendl;
derr << __func__ << " query " << query_param_name << " item " << j               << " not a string" << dendl;
derr << __func__ << " query " << query_param_name << " item " << type               << " is not valid type" << dendl;
derr << __func__ << " query " << query_param_name << " not a dict"             << dendl;
derr << __func__ << " limit item " << j << " not a size 2 tuple"               << dendl;
derr << __func__ << " " << limit_param_name << " not a string"                 << dendl;
derr << __func__ << " limit " << limit_param_name                 << " not a valid counter type" << dendl;
derr << __func__ << " " << limit_param_name << " not an int"                 << dendl;
derr << __func__ << " unknown limit param: " << limit_param_name               << dendl;
derr << __func__ << " limit order_by " << limit->order_by           << " not in performance_counter_descriptors" << dendl;
derr << "Failed to run module in active mode ('" << name << "')"           << dendl;
derr << "module '" << py_module->get_name() << "' command handler "              "returned wrong type!" << dendl;
derr << "module '" << py_module->get_name() << "' command handler "            "threw exception: " << peek_pyerror() << dendl;
derr << __func__ << " failed to parse " << p->second << ": " << ss.str()	   << dendl;
derr << "mgrmap module list changed to (" << m.modules << "), respawn"	 << dendl;
derr << "Error loading module '" << module_name << "': "        << cpp_strerror(r) << dendl;
derr << __func__ << " pool '" << PyUnicode_AsUTF8(pool_name)           << "' does not exist" << dendl;
derr << "respawn execv " << orig_argv[0]       << " failed with " << cpp_strerror(errno) << dendl;
derr << "Failed to run module in standby mode ('" << name << "')"           << dendl;
derr << __func__ << " error fetching store key '" << global_key << "': "         << cpp_strerror(r) << " " << outs << dendl;
derr << __func__ << " " << key		 << " sent me an unknown health metric: "		 << std::hex << static_cast<uint8_t>(metric.get_type())		 << std::dec << dendl;
derr << "Missing or invalid COMMANDS attribute in module '"          << module_name << "'" << dendl;
derr << "Missing or invalid MODULE_OPTIONS attribute in module '"          << module_name << "'" << dendl;
derr << "Module " << get_name()               << " returned wrong type in can_run" << dendl;
derr << "Module " << get_name()             << " returned wrong type in can_run" << dendl;
derr << "Module " << get_name() << " has missing " << attr_name         << " member" << dendl;
derr << "Module " << get_name() << " has " << attr_name         << " member of wrong type (should be a list)" << dendl;
derr << "Module " << get_name() << " has non-dict entry "           << "in " << attr_name << " list" << dendl;
derr << "Exception calling _register_options on " << get_name()         << dendl;
derr << "Exception calling _register_commands on " << get_name()         << dendl;
derr << __func__ << ": ignoring '"	   << module_name << "." << class_name << "'"	   << ": only one '" << base_class	   << "' class is loaded from each plugin" << dendl;
derr << __func__ << " " << std::hex         << off << "~" << len         << " block_size " << block_size         << " size " << size         << std::dec << dendl;
derr << "WARNING: io_uring API is not supported! Fallback to libaio!"           << dendl;
derr << __func__ << " failed to lock " << path << ": " << cpp_strerror(r)	   << dendl;
derr << "unable to get device name for " << path << ": "	<< cpp_strerror(r) << dendl;
derr << __func__ << " got r=" << r << " (" << cpp_strerror(r) << ")"	       << dendl;
derr << __func__ << " translating the error to EIO for upper layer"		 << dendl;
derr << "aio to 0x" << std::hex << aio[i]->offset	       << "~" << aio[i]->length << std::dec               << " but returned: " << r << dendl;
      derr << __func__ << " stalled aio " << debug_oldest		   << " since " << debug_stall_since << ", timeout is "		   << cct->_conf->bdev_debug_aio_suicide_timeout		   << "s, suicide" << dendl;
derr << __func__ << " bdev_inject_crash trigger from aio thread"	     << dendl;
derr << __func__ << " inflight overlap of 0x"	   << std::hex	   << offset << "~" << length << std::dec	   << " with " << debug_inflight << dendl;
  derr << __func__ << " stalled aio " << debug_oldest		<< " since " << debug_stall_since << ", timeout is "		<< age		<< "s" << dendl;
derr << __func__ << " bdev_inject_crash: dropping io 0x" << std::hex	 << off << "~" << len << std::dec << dendl;
derr << __func__ << " bdev_inject_crash: dropping io 0x" << std::hex	   << off << "~" << len << std::dec	   << dendl;
derr << __func__ << " stalled read "         << " 0x" << std::hex << off << "~" << len << std::dec         << (buffered ? " (buffered)" : " (direct)")	 << " since " << start1 << ", timeout is "	 << age	 << "s" << dendl;
derr << __func__ << " stalled read "         << " 0x" << std::hex << off << "~" << len << std::dec	 << " since " << start1 << ", timeout is "	 << age	 << "s" << dendl;
derr << __func__ << " 0x" << std::hex << off << "~" << len << std::dec      << " error: " << cpp_strerror(r) << dendl;
derr << __func__ << " 0x" << std::hex << off << "~" << left          << std::dec << " error: " << cpp_strerror(r) << dendl;
derr << __func__ << " stalled read "	   << " 0x" << std::hex << off0 << "~" << len << std::dec           << " (buffered) since " << start1 << ", timeout is "	   << age	   << "s" << dendl;
derr << __func__ << " stalled read "	   << " 0x" << std::hex << off << "~" << len << std::dec           << " (direct) since " << start1 << ", timeout is "	   << age	   << "s" << dendl;
derr << __func__ << " direct_aligned_read" << " 0x" << std::hex	   << off << "~" << std::left << std::dec << " error: " << cpp_strerror(r)        << dendl;
derr << __func__ << " 0x" << std::hex << off << "~" << len << std::dec	 << " error: " << cpp_strerror(r) << dendl;
derr << "WARNING: io_uring API is not supported! Fallback to libaio!"           << dendl;
derr << __func__ << " failed to lock " << path << ": " << cpp_strerror(r)	   << dendl;
derr << "unable to get device name for " << path << ": "	<< cpp_strerror(r) << dendl;
derr << __func__ << " got r=" << r << " (" << cpp_strerror(r) << ")"	       << dendl;
derr << __func__ << " translating the error to EIO for upper layer"		 << dendl;
derr << "aio to 0x" << std::hex << aio[i]->offset	       << "~" << aio[i]->length << std::dec               << " but returned: " << r << dendl;
      derr << __func__ << " stalled aio " << debug_oldest		   << " since " << debug_stall_since << ", timeout is "		   << cct->_conf->bdev_debug_aio_suicide_timeout		   << "s, suicide" << dendl;
derr << __func__ << " bdev_inject_crash trigger from aio thread"	     << dendl;
derr << __func__ << " inflight overlap of 0x"	   << std::hex	   << offset << "~" << length << std::dec	   << " with " << debug_inflight << dendl;
  derr << __func__ << " stalled aio " << debug_oldest		<< " since " << debug_stall_since << ", timeout is "		<< age		<< "s" << dendl;
derr << __func__ << " bdev_inject_crash: dropping io 0x" << std::hex	 << off << "~" << len << std::dec << dendl;
derr << __func__ << " bdev_inject_crash: dropping io 0x" << std::hex	   << off << "~" << len << std::dec	   << dendl;
derr << __func__ << " stalled read "         << " 0x" << std::hex << off << "~" << len << std::dec         << (buffered ? " (buffered)" : " (direct)")	 << " since " << start1 << ", timeout is "	 << age	 << "s" << dendl;
derr << __func__ << " stalled read "         << " 0x" << std::hex << off << "~" << len << std::dec	 << " since " << start1 << ", timeout is "	 << age	 << "s" << dendl;
derr << __func__ << " 0x" << std::hex << off << "~" << len << std::dec      << " error: " << cpp_strerror(r) << dendl;
derr << __func__ << " 0x" << std::hex << off << "~" << left          << std::dec << " error: " << cpp_strerror(r) << dendl;
derr << __func__ << " stalled read "	   << " 0x" << std::hex << off0 << "~" << len << std::dec           << " (buffered) since " << start1 << ", timeout is "	   << age	   << "s" << dendl;
derr << __func__ << " stalled read "	   << " 0x" << std::hex << off << "~" << len << std::dec           << " (direct) since " << start1 << ", timeout is "	   << age	   << "s" << dendl;
derr << __func__ << " direct_aligned_read" << " 0x" << std::hex        << off << "~" << left << std::dec << " error: " << cpp_strerror(r)        << dendl;
derr << __func__ << " 0x" << std::hex << off << "~" << len << std::dec	 << " error: " << cpp_strerror(r) << dendl;
derr << __func__ << " failed to lock " << path << ": " << cpp_strerror(r)	 << dendl;
derr << __func__ << " bdev_inject_crash: dropping io " << off << "~" << len      << dendl;
derr << __func__ << " invalid bluestore_spdk_coremask, "	 << "at least one core is needed" << dendl;
derr << __func__ << " unable to read " << p << ": " << cpp_strerror(r)	 << dendl;
derr << "missing 'type' file, inferring filestore from current/ dir"	     << dendl;
  derr << "missing 'type' file, inferring bluestore from block symlink"	       << dendl;
derr << TEXT_RED << " ** ERROR: writing new keyring to "             << keyring_path << ": " << cpp_strerror(r) << TEXT_NORMAL             << dendl;
derr << TEXT_RED << " ** ERROR: error creating empty object store in "	   << data_path << ": " << cpp_strerror(-err) << TEXT_NORMAL << dendl;
derr << TEXT_RED << " ** ERROR: error creating fresh journal "           << journal_path << " for object store " << data_path << ": "           << cpp_strerror(-err) << TEXT_NORMAL << dendl;
derr << "created new journal " << journal_path	 << " for object store " << data_path << dendl;
derr << TEXT_RED << " ** ERROR: error flushing journal " << journal_path	   << " for object store " << data_path	   << ": " << cpp_strerror(-err) << TEXT_NORMAL << dendl;
derr << "flushed journal " << journal_path	 << " for object store " << data_path	 << dendl;
derr << TEXT_RED << " ** ERROR: error dumping journal " << journal_path	   << " for object store " << data_path	   << ": " << cpp_strerror(-err) << TEXT_NORMAL << dendl;
derr << "dumped journal " << journal_path	 << " for object store " << data_path	 << dendl;
derr << TEXT_RED << " ** ERROR: error mounting store " << data_path	   << ": " << cpp_strerror(-err) << TEXT_NORMAL << dendl;
derr << TEXT_RED << " ** ERROR: error converting store " << data_path	   << ": " << cpp_strerror(-err) << TEXT_NORMAL << dendl;
derr << TEXT_RED << " ** ERROR: unable to open OSD superblock on "	 << data_path << ": " << cpp_strerror(-r)	 << TEXT_NORMAL << dendl;
derr << TEXT_RED << " **        please verify that underlying storage "	   << "supports xattrs" << TEXT_NORMAL << dendl;
derr << "OSD magic " << magic << " != my " << CEPH_OSD_ONDISK_MAGIC	 << dendl;
derr << TEXT_RED << " ** ERROR: osd pre_init failed: " << cpp_strerror(-err)	 << TEXT_NORMAL << dendl;
derr << TEXT_RED << " ** ERROR: osd init failed: " << cpp_strerror(-err)         << TEXT_NORMAL << dendl;
derr << "Fail to proc_pidpath(" << pid << ")"	 << " error = " << cpp_strerror(ret)	 << dendl;
derr << "Fail to open '" << proc_pid_path          << "' error = " << cpp_strerror(fd)          << dendl;
derr << "Fail to read '" << proc_pid_path         << "' error = " << cpp_strerror(ret)         << dendl;
derr << __func__ << ": failed to open pid file '"	 << pf_path << "': " << cpp_strerror(err) << dendl;
derr << __func__ << ": failed to fstat pid file '"	 << pf_path << "': " << cpp_strerror(err) << dendl;
derr << __func__ << ": failed to lock pidfile "	   << pf_path << " because another process locked it" 	   << "': " << cpp_strerror(errno) << dendl;
derr << __func__ << ": failed to lock pidfile "	   << pf_path << "': " << cpp_strerror(errno) << dendl;
derr << __func__ << ": failed to ftruncate the pid file '"	 << pf_path << "': " << cpp_strerror(err) << dendl;
derr << __func__ << ": failed to write to pid file '"	 << pf_path << "': " << cpp_strerror(-res) << dendl;
derr << __func__ << ": failed to set pidfile_remove function "	 << "to run at exit." << dendl;
derr << "global_init_daemonize: BUG: daemon error: "	 << cpp_strerror(ret) << dendl;
derr << "global_init_daemonize: global_init_shutdown_stderr failed with "	   << "error code " << ret << dendl;
derr << "global_init_chdir: failed to chdir to directory: '"	 << conf->chdir << "': " << cpp_strerror(err) << dendl;
derr << "failed to read nbd request header: " << cpp_strerror(r)	     << dendl;
    derr << *ctx << ": failed to read nbd request data: "		 << cpp_strerror(r) << dendl;
derr << *ctx << ": failed to write reply header: " << cpp_strerror(r)	     << dendl;
  derr << *ctx << ": failed to write replay data: " << cpp_strerror(r)	       << dendl;
derr << "invalidate page cache failed: " << cpp_strerror(errno)               << dendl;
derr << "rescan of partition table failed: " << cpp_strerror(errno)               << dendl;
derr << __func__ << ": " << quiesce_hook << " " << devpath << " "         << command << " failed: " << err.to_str() << dendl;
derr << "Error looking up inode " << std::hex << inode << std::dec <<      ": " << cpp_strerror(r) << dendl;
derr << ": error accessing local pool (id=" << m_pool_id << "): "         << cpp_strerror(r) << dendl;
derr << ": error connecting to remote cluster: " << cpp_strerror(r)         << dendl;
derr << ": failed to open remote dir_path=" << dir_path << ": " << cpp_strerror(r)         << dendl;
derr << ": failed to create remote directory=" << dir_path << ": " << cpp_strerror(r)           << dendl;
derr << ": failed to open remote dir_path=" << dir_path << ": " << cpp_strerror(r)           << dendl;
derr << ": failed to lock dir_path=" << dir_path << ": " << cpp_strerror(r)           << dendl;
derr << ": failed to close (cleanup) remote dir_path=" << dir_path << ": "           << cpp_strerror(r) << dendl;
derr << ": failed to unlock remote dir_path=" << dir_path << ": " << cpp_strerror(r)         << dendl;
derr << ": failed to close remote dir_path=" << dir_path << ": " << cpp_strerror(r)         << dendl;
derr << ": failed to open " << lr_str << " snap directory=" << snap_dir         << ": " << cpp_strerror(r) << dendl;
derr << ": failed to fetch " << lr_str << " snap info for snap_path=" << snap_path           << ": " << cpp_strerror(r) << dendl;
derr << ": snap_path=" << snap_path << " has invalid metadata in remote snapshot"             << dendl;
derr << ": snap_path=" << snap_path << " has missing \"" << PRIMARY_SNAP_ID_KEY               << "\" in metadata" << dendl;
derr << ": failed to close " << lr_str << " snap directory=" << snap_dir         << ": " << cpp_strerror(r) << dendl;
derr << ": failed to delete remote snap dir_path=" << dir_path           << ", snapshot=" << snaps << ": " << cpp_strerror(r) << dendl;
derr << ": failed to rename remote snap dir_path=" << dir_path           << ", snapshot from =" << from << ", to=" << to << ": "           << cpp_strerror(r) << dendl;
derr << ": failed to create remote directory=" << remote_path << ": " << cpp_strerror(r)         << dendl;
derr << ": failed to chown remote directory=" << remote_path << ": " << cpp_strerror(r)         << dendl;
derr << ": failed to change [am]time on remote directory=" << remote_path << ": "         << cpp_strerror(r) << dendl;
derr << ": failed to open local file path=" << local_path << ": "         << cpp_strerror(r) << dendl;
derr << ": failed to create remote file path=" << remote_path << ": "         << cpp_strerror(r) << dendl;
derr << ": failed to read local file path=" << local_path << ": "           << cpp_strerror(r) << dendl;
derr << ": failed to write remote file path=" << remote_path << ": "           << cpp_strerror(r) << dendl;
derr << ": failed to sync data for dir_path=" << remote_path << ": "           << cpp_strerror(r) << dendl;
derr << ": failed to close remote fd path=" << remote_path << ": " << cpp_strerror(r)         << dendl;
derr << ": failed to close local fd path=" << local_path << ": " << cpp_strerror(r)         << dendl;
derr << ": failed to copy path=" << local_path << ": " << cpp_strerror(r)           << dendl;
derr << ": failed to readlink local path=" << local_path << ": " << cpp_strerror(r)           << dendl;
derr << ": failed to symlink remote path=" << remote_path << " to target=" << target           << ": " << cpp_strerror(r) << dendl;
derr << ": failed to chown remote directory=" << remote_path << ": "         << cpp_strerror(r) << dendl;
derr << ": failed to change [am]time on remote directory=" << remote_path << ": "         << cpp_strerror(r) << dendl;
derr << ": failed to open remote directory=" << dir_path << ": "         << cpp_strerror(r) << dendl;
derr << ": failed to stat remote directory=" << dir_path << ": "         << cpp_strerror(r) << dendl;
derr << ": failed to remove remote directory=" << entry.epath << ": "                 << cpp_strerror(r) << dendl;
derr << ": failed to open remote directory=" << epath << ": "               << cpp_strerror(r) << dendl;
derr << ": failed to remove remote directory=" << entry.epath << ": "             << cpp_strerror(r) << dendl;
derr << ": failed to open local directory=" << snap_path << ": "         << cpp_strerror(r) << dendl;
derr << ": failed to stat local directory=" << snap_path << ": "         << cpp_strerror(r) << dendl;
derr << ": failed to open local directory=" << l_path << ": "               << cpp_strerror(r) << dendl;
derr << ": failed to synchronize dir_path=" << dir_path << ", snapshot="         << snap_path << dendl;
derr << ": failed to snap remote directory dir_path=" << dir_path         << ": " << cpp_strerror(r) << dendl;
derr << ": failed to synchronize dir_path=" << dir_path           << ", snapshot=" << it->second << dendl;
derr << ": failed to initialize FSMirror for filesystem=" << filesystem         << ": " << cpp_strerror(r) << dendl;
derr << ": failed to initialize FSMirror for filesystem=" << filesystem         << ": " << cpp_strerror(r) << dendl;
derr << ": failed to update service daemon status: " << cpp_strerror(r)         << dendl;
derr << ": error connecting to " << cluster_name << ": " << cpp_strerror(r)         << dendl;
derr << ": filesystem-id mismatch " << fs_id << " vs " << filesystem.fscid         << dendl;
derr << pctx << ": invalid request command: " << pctx->req->get_cmd()           << dendl;
derr << __func__ << " failed waiting for dispatcher to stop: "           << err << dendl;
derr << "Could not send response. Request id: " << wnbd_rsp.RequestHandle           << ". Error: " << err << dendl;
derr << "Could not load registry disk info for: "         << conn_props.InstanceName << ". Error: " << error << dendl;
derr << "Could not retrieve executable path. "        << "Error: " << win32_strerror(err) << dendl;
derr << "Could not send device map request. "         << "Make sure that the ceph service is running. "         << "Error: " << win32_strerror(err) << dendl;
derr << "The ceph service failed to map the image. Error: "         << reply.status << dendl;
derr << "Couln't establish a connection with the child process. "             << "Error: " << win32_strerror(err) << dendl;
derr << "Receiving child process reply failed with: "           << win32_strerror(err) << dendl;
derr << "Receiving child process reply failed with: "             << win32_strerror(err) << dendl;
derr << "Could not recreate mapping, missing command line: "           << cfg.devpath << dendl;
derr << __func__ << ": could not clean up non-persistent mapping: "             << cfg.devpath << dendl;
derr << "Could not create mapping: "               << cfg.devpath << ". Error: " << r << dendl;
derr << "Could not remove mapping: " << cfg.devpath               << ". Error: " << r << dendl;
derr << "Could not read service command: "             << win32_strerror(err) << dendl;
derr << "Could not send service command result: "             << win32_strerror(err) << dendl;
derr << "Could not start pipe connection handler thread: "             << win32_strerror(err) << dendl;
derr << "rbd-wnbd: couldn't initialize rados: " << cpp_strerror(r)         << dendl;
derr << "rbd-wnbd: couldn't connect to rados: " << cpp_strerror(r)         << dendl;
derr << "rbd-wnbd: couldn't create IO context: " << cpp_strerror(r)         << dendl;
derr << "rbd-wnbd: couldn't open rbd image: " << cpp_strerror(r)         << dendl;
derr << "rbd-wnbd: failed to acquire exclusive lock: " << cpp_strerror(r)           << dendl;
derr << "rbd-wnbd: couldn't use snapshot: " << cpp_strerror(r)         << dendl;
derr << "rbd-wnbd: image is too large (" << byte_u_t(info.size)         << ", max is " << byte_u_t(_UI64_MAX) << ")" << dendl;
derr << "Failed to communicate with the parent: "           << win32_strerror(err) << dendl;
derr << __func__ << ": could not clean up non-persistent mapping: "           << cfg->devpath << dendl;
derr << "rbd-wnbd: failed to unregister device: "           << cfg->devpath << ". Error: " << err << dendl;
derr << "Could not load registry disk info for: "         << devpath << ". Error: " << error << dendl;
derr << "Error reading path " << path << ": " << cpp_strerror(r)           << dendl;
derr << "Failed to stat path " << de_path << ": "            << cpp_strerror(r) << dendl;
derr << "Error reading layout on " << path << ": " << cpp_strerror(r)         << dendl;
derr << "Failed to erase region 0x" << std::hex << start << "~0x" << range << std::dec             << ": " << cpp_strerror(r) << dendl;
derr << "Failed to erase event 0x" << std::hex << i->first << std::dec               << ": " << cpp_strerror(r) << dendl;
derr << "Failed to write fnode for frag object "             << frag_oid.name << dendl;
derr << "unexpected error reading fragment object "           << frag_oid.name << ": " << cpp_strerror(r) << dendl;
derr << "error writing dentries to " << frag_oid.name	     << ": " << cpp_strerror(r) << dendl;
derr << "error removing dentries from " << frag_oid.name	  << ": " << cpp_strerror(r) << dendl;
derr << "error reading root inode object " << root_oid.name            << ": " << cpp_strerror(r) << dendl;
derr << "error writing inode object " << root_oid.name              << ": " << cpp_strerror(r) << dendl;
derr << "unable to read inotable '" << inotable_oid.name << "': "        << cpp_strerror(read_r) << dendl;
derr << "error writing modified inotable " << inotable_oid.name          << ": " << cpp_strerror(write_r) << dendl;
derr << "Failed to accumulate metadata data from '"        << oid << "': " << cpp_strerror(r) << dendl;
derr << "Unexpected error checking roots: '"      << cpp_strerror(r) << "'" << dendl;
derr << "Unexpected error checking size of ino 0x" << std::hex               << obj_name_ino << std::dec << ": " << cpp_strerror(r) << dendl;
  derr << "Bad nlink on " << ino << " expected " << nlink		       << " has " << inode.inode->nlink << dendl;
derr << "Bad remote link dentry 0x" << std::hex << dir_ino		     << std::dec << "/" << dname		     << ", ino " << ino << " not found" << dendl;
    derr << "Invalid tag char '" << dentry_type << "' dentry 0x" << dir_ino		 << std::dec << "/" << dname << dendl;
  derr << "Error decoding dentry 0x" << std::hex << dir_ino	       << std::dec << "/" << dname << dendl;
derr << "Remove duplicated ino 0x" << p.first << " from "	   << q.dirfrag() << "/" << q.name << dendl;
derr << "Bad nlink on " << p.first << " expected " << nlink	   << " has " << newest.nlink << dendl;
derr << "Unexpected error reading dentry "	   << p.second.dirfrag() << "/" << p.second.name	   << ": " << cpp_strerror(r) << dendl;
derr << "Unexpected error reading dentry "	<< p.second.dirfrag() << "/" << p.second.name	<< ": " << cpp_strerror(r) << dendl;
derr << "Unexpected error checking roots: '"      << cpp_strerror(r) << "'" << dendl;
derr << "unable to read mds table '" << table_oid.name << "': "      << cpp_strerror(r) << dendl;
derr << "unable to decode mds table '" << table_oid.name << "': "      << err.what() << dendl;
derr << "error updating mds table " << table_oid.name      << ": " << cpp_strerror(r) << dendl;
derr << "Unexpected error reading dentry 0x" << std::hex        << parent_ino << std::dec << "/"        << dname << ": " << cpp_strerror(r) << dendl;
derr << "Dentry 0x" << std::hex          << parent_ino << std::dec << "/"          << dname << " already exists but points to 0x"          << std::hex << existing_dentry.inode->ino << std::dec << dendl;
derr << "Failed to create dirfrag 0x" << std::hex        << ino << std::dec << ": " << cpp_strerror(r) << dendl;
derr << "Unexpected error reading dirfrag 0x" << std::hex      << ino << std::dec << " : " << cpp_strerror(r) << dendl;
derr << "Error writing dentry 0x" << std::hex      << dir_ino << std::dec << "/"      << dname << ": " << cpp_strerror(r) << dendl;
derr << "Pool " << metadata_pool_id	   << " identified in MDS map not found in RADOS!" << dendl;
derr << "error reading data object '" << oid << "': "        << cpp_strerror(r) << dendl;
derr << "error creating directory: '" << path_builder << "': "          << cpp_strerror(r) << dendl;
derr << "error creating directory: '" << lf_path << "': "      << cpp_strerror(r) << dendl;
derr << "Error " << r << " (" << cpp_strerror(r) << ") reading "                "journal at offset 0x" << std::hex << pos << std::dec << dendl;
derr << std::hex << "Invalid header (trimmed 0x" << trimmed_pos      << " > expire 0x" << start << std::dec << dendl;
derr << std::hex << "Invalid header (expire 0x" << start      << " > write 0x" << write_pos << std::dec << dendl;
derr << "Corrupt dentry '" << dname << "' : "           << err.what() << "(" << "" << ")" << dendl;
derr << "Corrupt dentry '" << dname << "' : "               << err.what() << "(" << "" << ")" << dendl;
derr << "Bad entry start ptr (0x" << std::hex << start_ptr << ") at 0x"              << read_offset << std::dec << dendl;
derr << "error reading table object " << object_name        << ": " << cpp_strerror(read_r) << dendl;
derr << "error writing table object " << object_name        << ": " << cpp_strerror(r) << dendl;
derr << "error reading header on '" << object_name << "': "           << cpp_strerror(r) << dendl;
derr << "Pool " << pool_id << " identified in MDS map not found in RADOS!"         << dendl;
derr << "error initializing local mirror status updater: "         << cpp_strerror(r) << dendl;
derr << "error initializing remote mirror status updater: "         << cpp_strerror(r) << dendl;
derr << "error initializing instance replayer: " << cpp_strerror(r)         << dendl;
derr << "error initializing instance watcher: " << cpp_strerror(r)         << dendl;
derr << "error shutting instance watcher down: " << cpp_strerror(r)         << dendl;
derr << "error shutting instance replayer down: " << cpp_strerror(r)         << dendl;
derr << "error shutting remote mirror status updater down: "         << cpp_strerror(r) << dendl;
derr << "error shutting local mirror status updater down: "         << cpp_strerror(r) << dendl;
derr << "error creating " << m_oid << " object: " << cpp_strerror(r)         << dendl;
derr << "error registering leader watcher for " << m_oid << " object: "           << cpp_strerror(r) << dendl;
derr << "error unregistering leader watcher for " << m_oid << " object: "         << cpp_strerror(r) << dendl;
derr << "error notifying leader lock acquired: " << cpp_strerror(r)           << dendl;
derr << "error notifying leader lock released: " << cpp_strerror(r)           << dendl;
derr << "error notifying heartbeat: " << cpp_strerror(r)         <<  ", releasing leader" << dendl;
derr << "failed to init mirror status watcher: " << cpp_strerror(r)         << dendl;
derr << "failed to shut down mirror status watcher: " << cpp_strerror(r)         << dendl;
derr << "failed to update mirror image statuses: " << cpp_strerror(r)         << dendl;
derr << "local image linked to unknown peer: "           << m_local_mirror_snap_ns.primary_mirror_uuid << dendl;
derr << "failed to locate remote start snapshot: "         << "snap_id=" << m_remote_snap_id_start << dendl;
derr << "split-brain detected: failed to find matching non-primary "         << "snapshot in remote image: "         << "local_snap_id_start=" << m_local_snap_id_start << ", "         << "local_snap_ns=" << m_local_mirror_snap_ns << dendl;
derr << "failed to prune non-primary snapshot: " << cpp_strerror(r)         << dendl;
derr << "failed to copy snapshots from remote to local image: "         << cpp_strerror(r) << dendl;
derr << "failed to retrieve remote snapshot image state: "         << cpp_strerror(r) << dendl;
derr << "failed to retrieve local snapshot image state: "         << cpp_strerror(r) << dendl;
derr << "failed to locate local snapshot " << m_local_snap_id_start           << dendl;
derr << "failed to create local mirror snapshot: " << cpp_strerror(r)         << dendl;
derr << "failed to update local mirror image state: " << cpp_strerror(r)         << dendl;
derr << "failed to copy remote image to local image: " << cpp_strerror(r)         << dendl;
derr << "failed to apply remote image state to local image: "         << cpp_strerror(r) << dendl;
derr << "failed to update local snapshot progress: " << cpp_strerror(r)         << dendl;
derr << "failed to unlink local peer from remote image: " << cpp_strerror(r)         << dendl;
derr << "failed to register local update watcher: " << cpp_strerror(r)         << dendl;
derr << "failed to register remote update watcher: " << cpp_strerror(r)         << dendl;
derr << "failed to unregister remote update watcher: " << cpp_strerror(r)         << dendl;
derr << "failed to unregister local update watcher: " << cpp_strerror(r)         << dendl;
derr << "failed to disable mirror image " << m_global_image_id << ": "         << cpp_strerror(r) << dendl;
derr << "failed to remove mirror image " << m_global_image_id << ": "         << cpp_strerror(r) << dendl;
derr << "failed to register mirror image " << m_global_image_id << ": "         << cpp_strerror(r) << dendl;
derr << "failed to rename image to '" << m_image_state.name << "': "         << cpp_strerror(r) << dendl;
derr << "failed to fetch local image metadata: " << cpp_strerror(r)         << dendl;
derr << "failed to unprotect snapshot " << m_snap_name << ": "         << cpp_strerror(r) << dendl;
derr << "failed to remove snapshot " << m_snap_name << ": "         << cpp_strerror(r) << dendl;
derr << "failed to protect snapshot " << m_snap_name << ": "         << cpp_strerror(r) << dendl;
derr << "failed to protect snapshot " << m_snap_name << ": "         << cpp_strerror(r) << dendl;
derr << "failed to update snapshot limit: " << cpp_strerror(r)         << dendl;
derr << "failed to retrieve mirror image details for image "         << m_global_image_id << ": " << cpp_strerror(r) << dendl;
derr << "local and remote mirror image using different mirroring modes "         << "for image " << m_global_image_id << ": split-brain" << dendl;
derr << "unsupported mirror image mode " << m_mirror_image.mode << " "         << "for image " << m_global_image_id << dendl;
derr << "failed to register with remote journal: " << cpp_strerror(r)         << dendl;
derr << "failed to retrieve global image id for parent image "         << m_remote_parent_spec.image_id << ": " << cpp_strerror(r) << dendl;
derr << "failed to retrieve local image id for parent image "         << m_parent_global_image_id << ": " << cpp_strerror(r) << dendl;
derr << "failed to open remote parent image " << m_parent_pool_name << "/"         << m_remote_parent_spec.image_id << dendl;
derr << "failed to retrieve local parent mirror uuid for pool "         << m_local_parent_io_ctx.get_id() << dendl;
derr << "failed to clone image " << m_parent_pool_name << "/"         << m_remote_parent_spec.image_id << " to "         << m_local_image_name << dendl;
derr << "error encountered closing remote parent image: "         << cpp_strerror(r) << dendl;
derr << "failed to open remote parent pool " << m_remote_parent_spec.pool_id         << ": " << cpp_strerror(r) << dendl;
derr << "failed to open local parent pool " << m_parent_pool_name << ": "         << cpp_strerror(r) << dendl;
derr << "failed to retrieve local mirror image info: " << cpp_strerror(r)         << dendl;
derr << "unsupported mirror image mode " << m_mirror_image.mode << " "         << "for image " << m_global_image_id << dendl;
derr << "error retrieving remote journal client: " << cpp_strerror(r)         << dendl;
derr << "error starting external replay on local image "         << m_state_builder->local_image_ctx->id << ": "         << cpp_strerror(r) << dendl;
derr << "failed to stop remote journaler replay : " << cpp_strerror(r)         << dendl;
derr << "error flushing remote journal commit position: "         << cpp_strerror(r) << dendl;
derr << "failed to retrieve remote tag " << m_replay_tag_tid << ": "         << cpp_strerror(r) << dendl;
derr << "failed to unregister with remote journal: " << cpp_strerror(r)         << dendl;
derr << "failed to register with remote journal: " << cpp_strerror(r)         << dendl;
derr << "failed to update remote journal client meta for image "         << m_state_builder->global_image_id << ": " << cpp_strerror(r)         << dendl;
derr << "error encountered during image refresh: " << cpp_strerror(r)         << dendl;
derr << "failed to update mirror peer journal client: "         << cpp_strerror(r) << dendl;
derr << "split-brain detected: local_image_id="         << m_state_builder->local_image_id << ", "         << "registered local_image_id="         << m_state_builder->remote_client_meta.image_id << dendl;
derr << "failed to decode remote client meta data: " << err.what()         << dendl;
derr << "failed to decode remote tag " << remote_tag.tid << ": "           << err.what() << dendl;
derr << "failed to shut down remote journaler: " << cpp_strerror(r)         << dendl;
derr << "error retrieving registered master client: "	 << cpp_strerror(r) << dendl;
derr << "error retrieving registered mirror client: "	   << cpp_strerror(r) << dendl;
derr << "error retrieving tag " << master_tag_tid << ": " << cpp_strerror(r)	 << dendl;
derr << "error decoding tag " << master_tag_tid << ": " << err.what()	   << dendl;
derr << ": failed to open image '" << m_image_id << "': "         << cpp_strerror(r) << dendl;
derr << "failed to close local image for image " << global_image_id << ": "         << cpp_strerror(r) << dendl;
derr << "failed to close remote image for image " << global_image_id << ": "         << cpp_strerror(r) << dendl;
derr << "error preparing local image for replay" << cpp_strerror(r)         << dendl;
derr << "error encountered closing remote image: " << cpp_strerror(r)         << dendl;
derr << ": error encountered while closing image: " << cpp_strerror(r)         << dendl;
derr << ": failed to open image '" << m_local_image_id << "': "           << cpp_strerror(r) << dendl;
derr << ": error querying local image primary status: " << cpp_strerror(r)         << dendl;
derr << ": failed to lock image '" << m_local_image_id << "': "       << cpp_strerror(r) << dendl;
derr << "failed to retrieve remote mirror uuid: " << cpp_strerror(r)           << dendl;
derr << ": failed to update client data: " << cpp_strerror(r)         << dendl;
derr << ": failed to refresh image for snapshot: " << cpp_strerror(r)         << dendl;
derr << ": failed to locate sync point snapshot: "               << sync_point.snap_name << dendl;
derr << ": unexpected from_snap_name in primary sync point: "               << sync_point.from_snap_name << dendl;
derr << ": failed to remove snapshot '" << snap_name << "': "         << cpp_strerror(r) << dendl;
derr << ": failed to update client data: " << cpp_strerror(r)         << dendl;
derr << "C_NotifyInstanceRequest: " << this << " " << __func__                 << ": ack instance_id (" << ack.instance_id << ") "                 << "does not match, ignoring" << dendl;
derr << "C_NotifyInstanceRequest: " << this << " " << __func__                 << ": ack request_id (" << ack.request_id << ") "                 << "does not match, ignoring" << dendl;
derr << "C_NotifyInstanceRequest: " << this << " " << __func__               << ": failed to decode ack: " << err.what() << dendl;
derr << "C_NotifyInstanceRequest: " << this << " " << __func__               << ": resending after timeout" << dendl;
derr << "C_NotifyInstanceRequest: " << this << " " << __func__               << ": resending due to leader change" << dendl;
derr << "error creating " << m_oid << " object: " << cpp_strerror(r)         << dendl;
derr << "error registering instance watcher for " << m_oid << " object: "         << cpp_strerror(r) << dendl;
derr << "error unregistering instance watcher for " << m_oid << " object: "         << cpp_strerror(r) << dendl;
derr << "error removing " << m_oid << " object: " << cpp_strerror(r)         << dendl;
derr << "global_image_id=" << global_image_id << ": blocklisted detected "         << "during image replay" << dendl;
derr << ": failed to prune catch-up sync point: "         << cpp_strerror(r) << dendl;
derr << ": failed to create sync point: " << cpp_strerror(r)         << dendl;
derr << ": failed to locate from snapshot: "             << sync_point.from_snap_name << dendl;
derr << ": failed to update client data: " << cpp_strerror(r)         << dendl;
derr << ": failed to prune sync point: "         << cpp_strerror(r) << dendl;
derr << "could not tell whether mirroring was enabled for " << pool_name	   << " : " << cpp_strerror(r) << dendl;
derr << "error reading mirroring config for pool " << pool_name	   << cpp_strerror(r) << dendl;
derr << "error reading mirroring peer config for pool " << pool_name << ": "         << cpp_strerror(r) << dendl;
derr << "error parsing mirroring peer config for pool " << pool_name << ", "         << "peer " << peer->uuid << dendl;
derr << "unexpected error registering mirroring directory watch: "         << cpp_strerror(r) << dendl;
derr << "error unregistering watcher for "             << m_mirroring_watcher->get_oid() << " object: " << cpp_strerror(r)             << dendl;
derr << "failed to retrieve mirroring directory: " << cpp_strerror(r)         << dendl;
derr << "unexpected error re-registering mirroring directory watch: "         << cpp_strerror(r) << dendl;
derr << "error accessing local pool " << m_local_pool_id << ": "         << cpp_strerror(r) << dendl;
derr << "failed to retrieve local mirror uuid from pool "         << m_local_io_ctx.get_pool_name() << ": " << cpp_strerror(r) << dendl;
derr << "error accessing remote pool " << m_local_io_ctx.get_pool_name()         << ": " << cpp_strerror(r) << dendl;
derr << "failed to initialize remote pool poller: " << cpp_strerror(r)         << dendl;
derr << "error initializing default namespace replayer: " << cpp_strerror(r)         << dendl;
derr << "could not read ceph conf for " << description << ": "	 << cpp_strerror(r) << dendl;
derr << "could not parse environment for " << description << ":"         << cpp_strerror(r) << dendl;
derr << "could not parse command line args for " << description << ": "	   << cpp_strerror(r) << dendl;
derr << "failed to set mon_host config for " << description << ": "           << cpp_strerror(r) << dendl;
derr << "failed to set key config for " << description << ": "           << cpp_strerror(r) << dendl;
derr << "error connecting to " << description << ": "	 << cpp_strerror(r) << dendl;
derr << "failed to initialize namespace replayer for namespace "                 << name << ": " << cpp_strerror(r) << dendl;
derr << "failed to get namespace mirror mode: " << cpp_strerror(r)           << dendl;
derr << "failed to handle acquire leader for namespace: "               << name << ": " << cpp_strerror(r) << dendl;
derr << "failed to update service daemon status: " << cpp_strerror(r)         << dendl;
derr << "failed to open image '" << m_image_id << "': " << cpp_strerror(r)         << dendl;
derr << "failed to get snap protection status: " << cpp_strerror(r)         << dendl;
derr << "error retrieving local id for image " << m_global_image_id << ": "         << cpp_strerror(r) << dendl;
derr << "error retrieving image primary info for image "         << m_global_image_id << ": " << cpp_strerror(r) << dendl;
derr << "cannot disable mirroring for image " << m_global_image_id         << ": global_image_id has changed/reused: "         << cpp_strerror(r) << dendl;
derr << "cannot disable mirroring for image " << m_global_image_id         << ": " << cpp_strerror(r) << dendl;
derr << "failed to remove mirror image state for " << m_global_image_id         << ": " << cpp_strerror(r) << dendl;
derr << "error getting image id " << m_image_id << " info from trash: "         << cpp_strerror(r) << dendl;
derr << "error setting trash image state for image id " << m_image_id         << ": " << cpp_strerror(r) << dendl;
derr << "error retrieving snapshot context for image "         << m_image_id << ": " << cpp_strerror(r) << dendl;
derr << "error removing image " << m_image_id << " "         << "(" << m_image_id << ") from local pool: "         << cpp_strerror(r) << dendl;
derr << "unexpected error re-registering trash directory watch: "         << cpp_strerror(r) << dendl;
derr << "unexpected error registering trash directory watch: "         << cpp_strerror(r) << dendl;
derr << "error unregistering watcher for trash directory: "         << cpp_strerror(r) << dendl;
derr << "corrupt OSD cap data for " << entity_name << " in auth db"           << dendl;
derr << __func__ << " using default osd cache size - mon_osd_cache_size ("         << g_conf()->mon_osd_cache_size         << ") without priority cache management"         << dendl;
derr << __func__ << " mon_memory_target:"           << g_conf()->mon_memory_target           << " rocksdb_cache_size:"           << g_conf()->rocksdb_cache_size           << ". Unable to update cache size."           << dendl;
derr << __func__ << " Cache ratios for pcm could not be set."         << " Review the kv (rocksdb) and mon_memory_target sizes."         << dendl;
derr << __func__ << " mon_memory_target:" << mon_memory_target           << " mon_memory_min:" << mon_memory_min           << ". Invalid size option(s) provided."           << dendl;
derr << __func__ << " full map CRC mismatch, resetting to canonical"	     << dendl;
derr << __func__ << " Invalid memory size specified for mon caches."         << " Caches will not be auto-tuned."         << dendl;
derr << __func__ << " Cache ratios for pcm could not be set."         << " Review the kv (rocksdb) and mon_memory_target sizes."         << dendl;
derr << __func__ << " Cache kv ratio (" << cache_kv_ratio         << ") must be in range [0,<1.0]."         << dendl;
derr << __func__         << " prune is enabled BUT prune interval is zero;
abort."    derr << __func__         << " prune interval is equal to one, which essentially means"            " no pruning;
abort."    derr << __func__         << " prune is enabled BUT prune min is zero;
abort."    derr << __func__         << " impossible to ascertain proper prune interval because"         << " it is greater than the minimum prune epochs"         << " (min: " << prune_min << ", interval: " << prune_interval << ")"         << dendl;
derr << __func__         << " 'mon_osdmap_full_prune_txsize' (" << txsize         << ") < 'mon_osdmap_full_prune_interval-1' (" << prune_interval - 1         << ");
abort." << dendl;
derr << __func__ << " received from entity "         << "with insufficient privileges " << session->caps << dendl;
derr << __func__ << " received from entity "         << "with insufficient privileges " << session->caps << dendl;
derr << __func__ << " unable to parse value for key '" << it->key()	     << "': \n";
derr << __func__ << " received from entity "         << "with insufficient privileges " << session->caps << dendl;
derr << __func__ << " closest pinned map ver " << closest_pinned           << " not available! error: " << cpp_strerror(err) << dendl;
derr << __func__             << "    osdmap crc mismatch! (osdmap crc " << tosdm.get_crc()             << ", expected " << inc.full_crc << ")" << dendl;
derr << "no beacon from osd." << i << " since " << t->second.first             << ", " << diff << " seconds ago.  marking down" << dendl;
derr << __func__ << " failed to set " << name << " device_class "	   << device_class << ": " << cpp_strerror(r) << " - " << ss.str()	   << dendl;
derr << __func__ << " mon_debug_no_initial_persistent_features=true"	 << dendl;
derr << __func__ << " unable to log to syslog -- level or facility"               << " not defined (level: " << level << ", facility: "               << facility << ")" << dendl;
derr << __func__ << " error parsing 'mon_cluster_log_to_syslog_level'"         << dendl;
derr << __func__ << " error parsing 'mon_cluster_log_to_syslog_facility'"         << dendl;
derr << __func__ << " error parsing 'mon_cluster_log_file_level'"         << dendl;
derr << __func__ << " error parsing 'mon_cluster_log_to_graylog'"         << dendl;
derr << __func__ << " error parsing 'mon_cluster_log_to_graylog_host'"         << dendl;
derr << __func__ << " error parsing 'mon_cluster_log_to_graylog_port'"         << dendl;
derr << "Shutting down because I am release " << (int)ceph_release()	 << " < min_mon_release " << (int)m->mon_release << dendl;
derr << "Shutting down because I lack required monitor features: { "	 << diff << " } " << mon_diff << dendl;
derr << "dropping PING_REPLY stamp " << m->stamp	   << " as it is newer than newest sent " << newest << dendl;
derr << "standby " << gid << " attempted to change state to "           << ceph_mds_state_name(state) << ", rejecting" << dendl;
derr << "daemon " << gid << " (rank " << info.rank << ") "           << "reported invalid state transition "           << ceph_mds_state_name(info.state) << " -> "           << ceph_mds_state_name(state) << dendl;
derr << "Unexpected error reading metadata: " << cpp_strerror(r)               << dendl;
derr << __func__ << " repair: adjusting config key '" << key << "'"	   << dendl;
derr << __func__ << " adding global/ prefix to key '" << key << "'"	     << dendl;
derr << " stashing newest monmap " << monmap->get_epoch()	   << " for next startup" << dendl;
derr << __func__           << " something wrong happened while reading the store: "           << cpp_strerror(err) << dendl;
derr << __func__           << " something wrong happened while reading the store: "           << cpp_strerror(err) << dendl;
derr << __func__ << " require release " << (int)m->mon_release << " > "	 << (int)ceph_release()	 << ", or missing features (have " << CEPH_FEATURES_ALL	 << ", required " << m->required_features	 << ", missing " << (m->required_features & ~CEPH_FEATURES_ALL) << ")"	 << dendl;
derr << __func__ << " existing cluster has not completed upgrade to"	   << " luminous;
'ceph osd require_osd_release luminous' before"      derr << __func__ << " existing cluster has not completed a full luminous"	   << " scrub to purge legacy snapdir objects;
please scrub before"          derr << "Unexpected error from get_mon_metadata: "               << cpp_strerror(r) << dendl;
derr << __func__ << " reporting " << slow << " slow ops, oldest is "	   << oldest_op->get_desc() << dendl;
derr << "error: cluster_uuid file exists with value " << ondisk	 << ", != our uuid " << monmap->get_fsid() << dendl;
derr << "unable to find a keyring file on " << g_conf()->keyring	   << ": " << cpp_strerror(r) << dendl;
  derr << "error decoding keyring " << keyring_plaintext	       << ": " << e.what() << dendl;
derr << __func__ << " hmm, they didn't like " << old_auth_method       << " result " << cpp_strerror(result) << dendl;
derr << __func__ << " failed to build mgr service session_auth_info "	   << cpp_strerror(ret) << dendl;
derr << __func__ << " unrecognized auth mode " << auth_meta->auth_mode	 << dendl;
derr << __func__ << " corrupt cap data for " << con->get_peer_entity_name()	   << " in auth db" << dendl;
derr << __func__ << " unparseable caps '" << str << "' for "	     << con->get_peer_entity_name() << dendl;
derr << "could not find " << oid << " in index: "      << cpp_strerror(-r) << dendl;
derr << "error creating " << oid << " (" << (*path)->path()          << ") in index: " << cpp_strerror(-r) << dendl;
derr << "error setting spillout xattr for oid " << oid << " (" << (*path)->path()                     << "):" << cpp_strerror(-r) << dendl;
derr << __FUNC__ << ": failed to truncate fsid: "	   << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": failed to write fsid: "	   << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": close failed: can't write fsid: "	   << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": write_version_stamp() failed: "	 << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": write_superblock() failed: "	 << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": cannot fstatfs basedir "	 << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": failed to create " << current_op_seq_fn << ": "	   << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": failed to write to " << current_op_seq_fn << ": "	     << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": failed to truncate fsid: "	   << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": failed to write fsid: "	   << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": close failed: can't write fsid: "	   << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": " << omap_fsid_fn           << " has existed omap fsid " << old_omap_fsid           << " != expected osd fsid " << fsid           << dendl;
derr << __FUNC__ << ": error creating journal on " << journalpath		<< ": " << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": unable to access basedir '" << basedir << "': "	 << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": error opening '" << buf << "': "	 << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": error reading fsid_fd: " << cpp_strerror(ret)	 << dendl;
derr << __FUNC__ << ": error in version_stamp_is_valid: "	 << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": stale version stamp detected: "	   << version_stamp	   << ". Proceeding, do_update "	   << "is set, performing disk format upgrade."	   << dendl;
derr << __FUNC__ << ": stale version stamp " << version_stamp	   << ". Please run the FileStore update script before starting the "	   << "OSD, or set filestore_update_to to " << target_version	   << " (currently " << cct->_conf->filestore_update_to << ")"	   << dendl;
derr << __FUNC__ << ": Incompatible features set "	   << superblock.compat_features << dendl;
derr << __FUNC__ << ": failed to open " << basedir << ": "	 << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": error in _detect_fs: "	 << cpp_strerror(ret) << dendl;
derr << TEXT_RED	     << " ** NOTE: rolling back to cluster snapshot " << m_osd_rollback_to_cluster_snap << " **"	     << TEXT_NORMAL	     << dendl;
  derr << "WARNING: user forced start with data sequence mismatch: current was " << curr_seq	       << ", newest snap is " << cp << dendl;
derr << __FUNC__ << ": error rolling back to " << s << ": "	     << cpp_strerror(ret) << dendl;
derr << __FUNC__ << ": error opening '" << omap_fsid_buf << "': "             << cpp_strerror(ret)             << dendl;
derr << __FUNC__ << ": error reading omap_fsid_fd"           << ", omap_fsid = " << omap_fsid           << cpp_strerror(ret)           << dendl;
derr << __FUNC__ << ": " << omap_fsid_buf           << " has existed omap fsid " << omap_fsid           << " != expected osd fsid " << fsid           << dendl;
derr << __FUNC__ << ": Error initializing " << superblock.omap_backend	   << " : " << err.str() << dendl;
derr << __FUNC__ << ": _sanity_check_fs failed with error "	 << ret << dendl;
derr << "Unable to mount index " << *i	     << " with error: " << ret << dendl;
derr << "maybe journal is not pointing to a block device and its size "	     << "wasn't configured?" << dendl;
derr << __FUNC__ << ": fsetxattr " << GLOBAL_REPLAY_GUARD_XATTR	 << " got " << cpp_strerror(r) << dendl;
derr << __FUNC__ << ": write_fd on " << cid << "/" << oid         << " error: " << cpp_strerror(r) << dendl;
derr << __FUNC__ << ": copy error at " << miter->first << "~" << miter->second             << " to " << it_off << ", " << cpp_strerror(r) << dendl;
derr << __FUNC__ << ": safe_splice read error at " << pos << "~" << len	  << ", " << cpp_strerror(r) << dendl;
derr << __FUNC__ << ": got short read result at " << pos	  << " of fd " << from << " len " << len << dendl;
derr << __FUNC__ << ": write error at " << pos << "~"	  << r << ", " << cpp_strerror(r) << dendl;
  derr << __FUNC__ << ": read error at " << pos << "~" << len	    << ", " << cpp_strerror(r) << dendl;
derr << __FUNC__ << ": got short read result at " << pos	  << " of fd " << from << " len " << len << dendl;
  derr << __FUNC__ << ": write error at " << pos << "~"	    << r-op << ", " << cpp_strerror(r) << dendl;
derr << __FUNC__ << ": get_index returned: " << cpp_strerror(r)         << dendl;
derr << __FUNC__ << ": collection_list_partial returned: "         << cpp_strerror(r) << dendl;
derr << "tried to set invalid params: "	 << ss.str()	 << dendl;
derr << "WARNING: max attr value size ("	 << m_filestore_max_xattr_value_size	 << ") is smaller than osd_max_object_name_len ("	 << cct->_conf->osd_max_object_name_len	 << ").  Your backend filesystem appears to not support attrs large "	 << "enough to handle the configured max rados name size.  You may get "	 << "unexpected ENAMETOOLONG errors on rados operations or buggy "	 << "behavior"	 << dendl;
derr << "FileJournal::_open: error closing old fd: "	   << cpp_strerror(err) << dendl;
derr << "FileJournal::_open: disabling aio for non-block journal.  Use "	   << "journal_force_aio to force use of aio anyway" << dendl;
derr << "FileJournal::_open: wrong journal file type: " << st.st_mode	 << dendl;
  derr << "FileJournal::_open: user's limit of aio events exceeded. "	       << "Try increasing /proc/sys/fs/aio-max-nr" << dendl;
derr << "I'm sorry, I don't know how large of a journal to create."	 << "Please specify a block device to use as the journal OR "	 << "set osd_journal_size in your ceph.conf" << dendl;
derr << "FileJournal::_open_file : unable to extend journal to "	   << newsize << " bytes: " << cpp_strerror(err) << dendl;
derr << "FileJournal::_open_file : unable to preallocation journal to "	   << newsize << " bytes: " << cpp_strerror(ret) << dendl;
derr << "check: ondisk fsid " << header.fsid << " doesn't match expected " << fsid	 << ", invalid (someone else's?) journal" << dendl;
derr << "FileJournal::create : create write header error "         << cpp_strerror(ret) << dendl;
derr << "FileJournal::create: failed to allocate " << block_size	 << " bytes of memory: " << cpp_strerror(ret) << dendl;
derr << "FileJournal::create: error zeroing first " << block_size	 << " bytes " << cpp_strerror(ret) << dendl;
derr << "FileJournal::create: OSD journal is not large enough to hold "	 << "osd_max_write_size bytes!" << dendl;
derr << "FileJournal::create: error closing fd: " << cpp_strerror(ret)	 << dendl;
derr << "FileJournal::open: ondisk fsid " << header.fsid << " doesn't match expected " << fsid         << ", invalid (someone else's?) journal" << dendl;
derr << "FileJournal::do_write: write_bl(pos=" << orig_pos	   << ") failed" << dendl;
derr << "FileJournal::do_write: write_bl(pos=" << orig_pos	   << ") failed" << dendl;
derr << "FileJournal::do_write: pwrite(fd=" << fd	     << ", hbp.length=" << hbp.length() << ") failed :"	     << cpp_strerror(err) << dendl;
derr << "FileJournal::do_write: write_bl(pos=" << pos	   << ") failed" << dendl;
derr << "FileJournal::do_aio_write: write_aio_bl(pos=" << pos	   << ") failed" << dendl;
derr << "FileJournal::do_aio_write: write_aio_bl(pos=" << pos	   << ") failed" << dendl;
derr << "FileJournal::do_aio_write: write_aio_bl(pos=" << pos	   << ") failed" << dendl;
derr << "io_submit to " << aio.off << "~" << cur_len	     << " got " << cpp_strerror(r) << dendl;
  derr << "aio to " << ai->off << "~" << ai->len	       << " returned: " << (int)event[i].res << dendl;
derr << "tried to set invalid params: "	 << ss.str()	 << dendl;
derr << "FileJournal::wrap_read_bl: safe_read_exact " << pos << "~" << len << " returned "	   << cpp_strerror(r) << dendl;
derr << "Unable to read past sequence " << seq	 << " but header indicates the journal has committed up through "	 << header.committed_up_to << ", journal is corrupt" << dendl;
derr << __func__ << " buffer_size " << buffer_bytes << " actual " << s           << dendl;
derr << __func__ << " hot_list_bytes "           << list_bytes[BUFFER_HOT]           << " != actual " << hot_bytes           << dendl;
derr << __func__ << " warm_in_list_bytes "           << list_bytes[BUFFER_WARM_IN]           << " != actual " << warm_in_bytes           << dendl;
derr << __func__ << " buffer_bytes " << buffer_bytes << " actual " << s           << dendl;
    derr << __func__ << " missing shard 0x" << std::hex		 << p->shard_info->offset << std::dec << " for " << onode->oid		 << dendl;
derr << __func__ << "on write 0x" << std::hex << offset	   << "~" << length << " shard 0x" << p->shard_info->offset	   << std::dec << " is not loaded, can't mark dirty" << dendl;
derr << __func__ << " unrecognized value '"         << cct->_conf->bluestore_compression_mode         << "' for bluestore_compression_mode, reverting to 'none'"         << dendl;
derr << __func__ << " unable to initialize " << alg_name.c_str() << " compressor"           << dendl;
derr << __func__ << " bluestore_cache_meta_ratio (" << cache_meta_ratio         << ") must be in range [0,1.0]" << dendl;
derr << __func__ << " bluestore_cache_kv_ratio (" << cache_kv_ratio         << ") must be in range [0,1.0]" << dendl;
derr << __func__ << " bluestore_cache_kv_onode_ratio (" << cache_kv_onode_ratio         << ") must be in range [0,1.0]" << dendl;
derr << __func__ << " bluestore_cache_meta_ratio (" << cache_meta_ratio         << ") + bluestore_cache_kv_ratio (" << cache_kv_ratio         << ") = " << cache_meta_ratio + cache_kv_ratio << ";
must be <= 1.0"    derr << __func__ << " unable to open " << path << ": " << cpp_strerror(r)	 << dendl;
derr << __func__ << " failed to open " << path << ": " << cpp_strerror(fd)	 << dendl;
derr << __func__ << " failed to write to " << path	 << ": " << cpp_strerror(r) << dendl;
derr << __func__ << " failed to fsync " << path	 << ": " << cpp_strerror(r) << dendl;
derr << __func__ << " failed to open " << path << ": " << cpp_strerror(fd)	 << dendl;
derr << __func__ << " failed to read from " << path	 << ": " << cpp_strerror(r) << dendl;
derr << __func__ << " bad crc on label, expected " << expected_crc	 << " != actual " << crc << dendl;
derr << __func__ << " bdev " << path << " fsid " << label.osd_uuid	   << " does not match our fsid " << fsid << dendl;
derr << __func__ << " failed to lock " << path << "/fsid"	 << " (is another ceph-osd still running?)"	 << cpp_strerror(err) << dendl;
derr << __func__ << " add block device(" << bfn << ") returned: "            << cpp_strerror(r) << dendl;
derr << __func__	      << " check block device(" << bfn << ") label returned: "              << cpp_strerror(r) << dendl;
derr << __func__ << " " << bfn << " symlink exists but target unusable: "	    << cpp_strerror(r) << dendl;
derr << __func__ << " add block device(" << bfn << ") returned: "	  << cpp_strerror(r) << dendl;
derr << __func__ << " add block device(" << bfn << ") returned: "	    << cpp_strerror(r) << dendl;
derr << __func__ << " check block device(" << bfn              << ") label returned: " << cpp_strerror(r) << dendl;
derr << __func__ << " " << bfn << " symlink exists but target unusable: "           << cpp_strerror(r) << dendl;
derr << __func__ << " bluefs = " << s << " : not 0 or 1, aborting"	   << dendl;
derr << __func__ << " failed to load os-type: " << cpp_strerror(r)        << dendl;
derr << __func__ << " failed to create " << fn << ": " << cpp_strerror(r)	     << dendl;
derr << __func__ << " failed to create " << walfn	  << ": " << cpp_strerror(r)	  << dendl;
derr << __func__ << " failed to decode cnode, key:"             << pretty_binary_string(it->key()) << dendl;
derr << __func__ << " failed to decode pool stats, key:"             << pretty_binary_string(it->key()) << dendl;
derr << __func__ << " failed to create " << name << " symlink to "           << epath << ": " << cpp_strerror(r) << dendl;
derr << __func__ << " failed to open " << epath << " file: "	     << cpp_strerror(r) << dendl;
  derr << __func__ << " failed to resize " << name << " file to "	       << size << ": " << cpp_strerror(r) << dendl;
    derr << __func__ << " failed to prefallocate " << name << " file to "	      << size << ": " << cpp_strerror(r) << dendl;
derr << __func__ << " failed to open " << name << " file: "	     << cpp_strerror(r) << dendl;
derr << __func__ << " osd_max_object_size "	 << cct->_conf->osd_max_object_size << " > bluestore max "	 << OBJECT_MAX_SIZE << dendl;
derr << __func__ << " fsck found fatal error: " << cpp_strerror(r)               << dendl;
derr << __func__ << " on-disk fsid " << old_fsid	   << " != provided " << fsid << dendl;
derr << __func__ << " min_alloc_size 0x"	 << std::hex << min_alloc_size << std::dec	 << " is not power of 2 aligned!"	 << dendl;
derr << __func__         << " can't migrate, free space at target: " << target_free	 << " is less than required space: " << used_space	 << dendl;
derr << "unable to read label for " << path << ": "          << cpp_strerror(r) << dendl;
derr << "unable to write label for " << path << ": "            << cpp_strerror(r) << dendl;
derr << devid	    <<": can't find device path " << dendl;
derr << __func__ << " osd_max_object_size "	 << cct->_conf->osd_max_object_size << " > bluestore max "	 << OBJECT_MAX_SIZE << dendl;
derr << "fsck error: " << oid << " extent " << e		   << " or a subset is already allocated (misreferenced)" << dendl;
derr << "fsck error:  " << oid << " extent " << e	     << " past end of block device" << dendl;
  derr << "fsck error: " << "legacy statfs record found, removing"	       << dendl;
derr << "fsck error: bad key " << key	     << "in statfs namespece" << dendl;
derr << "fsck error: failed to decode Pool StatFS record"	     << pretty_binary_string(key) << dendl;
  derr << "fsck error: found stray Pool StatFS record for pool id 0x"	       << std::hex << pool_id << std::dec << dendl;
derr << "fsck error: actual " << statfs	     << " != expected " << stat_it->second	     << " for pool "	     << std::hex << pool_id << std::dec << dendl;
derr << "fsck error: missing Pool StatFS record for pool "	 << std::hex << s.first << std::dec << dendl;
derr << "fsck error: " << oid << " shard 0x" << std::hex            << s.shard_info->offset << " past EOF at 0x" << o->onode.size            << std::dec << dendl;
derr << "fsck error: " << oid << " lextent at 0x"        << std::hex << l.logical_offset        << " overlaps with the previous, which ends at 0x" << pos        << std::dec << dendl;
derr << "fsck error: " << oid << " lextent at 0x"        << std::hex << l.logical_offset << "~" << l.length        << " spans a shard boundary"        << std::dec << dendl;
derr << "fsck error: " << oid << " blob " << *i.first        << " doesn't match expected ref_map " << i.second << dendl;
derr << "fsck error: " << oid << " blob " << blob          << " sbid " << i.first->shared_blob->get_sbid() << " > blobid_max "          << blobid_max << dendl;
derr << "fsck error: " << oid << " blob " << blob          << " marked as shared but has uninitialized sbid"          << dendl;
derr << "fsck error: " << oid << " - " << broken           << " zombie spanning blob(s) found, the first one: "           << *first_broken << dendl;
derr << "fsck error: missing shard key "            << pretty_binary_string(expecting_shards.front())            << dendl;
derr << "fsck error: stray shard 0x" << std::hex << offset          << std::dec << dendl;
derr << "fsck error: " << pretty_binary_string(it->key())            << " is unexpected" << dendl;
derr << "fsck error:   saw " << pretty_binary_string(it->key())            << dendl;
derr << "fsck error:   exp "            << pretty_binary_string(expecting_shards.front()) << dendl;
derr << "fsck error: bad object key "          << pretty_binary_string(it->key()) << dendl;
derr << "fsck error: stray object " << oid            << " not owned by any collection" << dendl;
derr << "fsck error: missing shard key "            << pretty_binary_string(k) << dendl;
derr << "fsck error: " << oid << " nid " << o->onode.nid              << " > nid_max " << nid_max << dendl;
derr << "fsck error: " << oid << " nid " << o->onode.nid              << " already in use" << dendl;
derr << "fsck error: " << oid << " blob claims unused 0x"              << std::hex << blob.unused              << " but extents reference 0x" << i.second << std::dec              << " on blob " << *i.first << dendl;
derr << "fsck error: " << oid                    << " blob claims csum chunk 0x" << std::hex << pos                    << "~" << csum_chunk_size                    << " is unused (mask 0x" << mask << " of unused 0x"                    << blob.unused << ") but csum is non-zero 0x"                    << blob.get_csum_item(p) << std::dec << " on blob "                    << *i.first << dendl;
derr << "fsck error: " << o->oid << " omap_head " << o->onode.nid                 << " already in use" << dendl;
derr << "fsck error: " << oid << std::hex                << " error during read: "                << " " << offset << "~" << l                << " " << cpp_strerror(r) << std::dec                << dendl;
derr << "fsck " << w << ": store not yet converted to per-pool stats"	 << dendl;
derr << "fsck " << w << ": store not yet converted to per-pg omap"	 << dendl;
derr << "fsck error: bad key '" << key	     << "' in shared blob namespace" << dendl;
derr << "fsck error: found stray shared blob data for sbid 0x"	     << std::hex << sbid << std::dec << dendl;
derr << "fsck error: failed to decode Shared Blob"    	       << pretty_binary_string(it->key()) << dendl;
  derr << "fsck error: shared blob 0x" << std::hex << sbid		<< std::dec << " ref_map " << shared_blob.ref_map		<< " != expected " << sbi.ref_map << dendl;
      derr << __func__	           << " failed to allocate 0x" << std::hex << e->length		   << " allocated 0x " << (alloc_len < 0 ? 0 : alloc_len)		   << " min_alloc_size 0x" << min_alloc_size		   << " available 0x " << shared_alloc.a->get_free()		   << std::dec << dendl;
      derr << __func__ << " failed to read from 0x" << std::hex << e->offset		    <<"~" << e->length << std::dec << dendl;
derr << "fsck error: actual " << actual_statfs	 << " != expected " << expected_store_statfs << dendl;
  derr << "fsck error: failed to decode deferred txn "	       << pretty_binary_string(it->key()) << dendl;
  derr << "fsck error: free extent 0x" << std::hex << offset	        << "~" << length << std::dec	        << " intersects allocated blocks" << dendl;
      derr << "fsck error: leaked extent 0x" << std::hex		   << ((uint64_t)start * fm->get_alloc_size()) << "~"		   << ((cur + 1 - start) * fm->get_alloc_size()) << std::dec		   << dendl;
derr << __func__ << " bdev-read failed: " << cpp_strerror(r)               << dendl;
derr << __func__ << " bad "	   << Checksummer::get_csum_type_string(blob->csum_type)	   << "/0x" << std::hex << blob->get_csum_chunk_size()	   << " checksum at blob offset 0x" << bad	   << ", got 0x" << bad_csum << ", expected 0x"	   << blob->get_csum_item(bad / blob->get_csum_chunk_size()) << std::dec	   << ", device location " << pex	   << ", logical extent 0x" << std::hex	   << (logical_offset + bad - blob_xoffset) << "~"	   << blob->get_csum_chunk_size() << std::dec	   << ", object " << o->oid	   << dendl;
derr << __func__ << " collection_list returned: " << cpp_strerror(r)         << dendl;
derr << __func__ << " compat_ondisk_format is "	 << compat_ondisk_format << " but we only understand version "	 << latest_ondisk_format << dendl;
derr << __func__ << " unexpected txc " << txc	   << " state " << txc->get_state_name() << dendl;
derr << __func__ << " failed to decode deferred txn "	   << pretty_binary_string(it->key()) << dendl;
derr << __func__ << " error " << cpp_strerror(r)           << " not handled on operation " << op->op           << " (op " << pos << ", counting from 0)" << dendl;
derr << __func__ << " error " << cpp_strerror(r)             << " not handled on operation " << op->op             << " (op " << pos << ", counting from 0)"             << dendl;
        derr << __func__ << " unable to initialize " << val.c_str()		     << " compressor" << dendl;
derr << __func__ << " failed to allocate 0x" << std::hex << need         << " allocated 0x " << (prealloc_left < 0 ? 0 : prealloc_left)         << " min_alloc_size 0x" << min_alloc_size         << " available 0x " << shared_alloc.a->get_free()         << std::dec << dendl;
derr << __func__ << " _do_alloc_write failed with " << cpp_strerror(r)         << dendl;
derr << __func__ << " _do_alloc_write failed with " << cpp_strerror(r)	 << dendl;
derr << __func__ << " _do_gc failed with " << cpp_strerror(r)            << dendl;
derr << __func__ << " mismatched hash on " << oldo->oid	 << " and " << newo->oid << dendl;
derr << __func__ << " Failed to parse - "          << keys[i] << ":" << val          << ", error: " << err << dendl;
derr << __func__ << " injecting error, zeros at "	   << int(ndev) << ": 0x" << std::hex << (off + len / 2)	   << "~" << (block_size * 2) << std::dec << dendl;
derr << __func__ << " initial read of " << int(ndev)	   << ": 0x" << std::hex << off << "~" << len	   << std::dec << ": different then re-read " << dendl;
derr << __func__ << " injecting error, zeros at "	   << int(ndev) << ": 0x" << std::hex << (off + len / 2)	   << "~" << (block_size * 2) << std::dec << dendl;
derr << __func__ << " initial read of " << int(ndev)	   << ": 0x" << std::hex << off << "~" << len	   << std::dec << ": different then re-read " << dendl;
derr << __func__ << " bad crc on superblock, expected 0x"         << std::hex << expected_crc << " != actual 0x" << crc << std::dec         << dendl;
derr << __func__ << " invalid extent " << int(e.bdev)        << ": 0x" << std::hex << e.offset << "~" << e.length        << std::dec << ": duplicate reference, ino " << fnode.ino        << dendl;
derr << __func__ << " " << op << " of " << (int)id	 << ":0x" << std::hex << offset << "~" << length << std::dec	 << " does not align to alloc_size 0x"	 << std::hex << alloc_size[id] << std::dec << dendl;
derr << "work-around by setting " << which << " = " << need	   << " for this OSD" << dendl;
derr << __func__ << " 0x" << std::hex << pos << std::dec		 << ": stop: uuid " << uuid << " != super.uuid " << super.uuid		 << ", block dump: \n";
derr << __func__ << " 0x" << std::hex << pos << std::dec	     << ": stop: seq " << seq << " != expected " << log_seq + 1	     << dendl;
;
derr << __func__ << " 0x" << std::hex << pos << std::dec           << ": stop: failed to decode: " << e.what()           << dendl;
derr << __func__ << " invalid extent " << int(id)                    << ": 0x" << std::hex << e.offset << "~" << e.length                    << std::dec                    << ": not in use but is allocated for removed ino " << ino                    << dendl;
derr << __func__ << " 0x" << std::hex << pos << std::dec             << ": stop: unrecognized op " << (int)op << dendl;
derr << __func__ << " file with link count 0: " << p.second->fnode	     << dendl;
  derr << __func__ << " failed to read 0x" << std::hex	       << old_ext.offset << "~" << old_ext.length << std::dec	       << " from " << (int)dev_target << dendl;
derr << __func__ << " unable to allocate len 0x" << std::hex	     << bl.length() << std::dec << " from " << (int)dev_target	     << ": " << cpp_strerror(l) << dendl;
  derr << __func__ << " failed to read 0x" << std::hex	       << old_ext.offset << "~" << old_ext.length << std::dec	       << " from " << (int)dev_target << dendl;
derr << __func__ << " unable to allocate len 0x" << std::hex	     << bl.length() << std::dec << " from " << (int)dev_target	     << ": " << cpp_strerror(l) << dendl;
derr << __func__ << " allocated: 0x" << std::hex << allocated           << " offset: 0x" << offset << " length: 0x" << length << std::dec           << dendl;
derr << __func__ << " unable to allocate 0x" << std::hex << need	 << " on bdev " << (int)id         << ", allocator name " << alloc[id]->get_name()         << ", allocator type " << alloc[id]->get_type()         << ", capacity 0x" << alloc[id]->get_capacity()         << ", block size 0x" << alloc[id]->get_block_size()         << ", free 0x" << alloc[id]->get_free()         << ", fragmentation " << alloc[id]->get_fragmentation()         << ", allocated 0x" << (alloc_len > 0 ? alloc_len : 0)	 << std::dec << dendl;
derr << __func__ << " allocation failed, needed 0x" << std::hex << need           << dendl;
derr << __func__ << " Failed to parse - "          << keys[i] << ":" << val          << ", error: " << err << dendl;
derr << __func__ << " unable to open " << path << ": " << cpp_strerror(r)	 << dendl;
derr << __func__ << " failed to lock " << path << "/fsid"	 << " (is another ceph-osd still running?)"	 << cpp_strerror(err) << dendl;
derr << __func__ << " failed to create " << fn << ": " << cpp_strerror(r)	   << dendl;
derr << __func__ << " failed to create " << walfn	   << ": " << cpp_strerror(r)	   << dendl;
derr << __func__ << " failed to decode cnode, key:"             << pretty_binary_string(it->key()) << dendl;
derr << __func__ << " on-disk fsid " << old_fsid	   << " != provided " << fsid << dendl;
derr << __func__ << " collection_list returned: " << cpp_strerror(r)         << dendl;
derr << __func__ << " unexpected txc " << txc	   << " state " << txc->get_state_name() << dendl;
derr << " error " << cpp_strerror(r)	   << " not handled on operation " << op->op	   << " (op " << pos << ", counting from 0)" << dendl;
derr << __func__ << " mismatched hash on " << oldo->oid	 << " and " << newo->oid << dendl;
derr << __func__ << " not enough chunks in " << available_chunks       << " to read " << want_to_read << dendl;
derr << __func__ << " layer " << layer.chunks_map	   << " failed with " << err << " trying to encode "	   << layer_want_to_encode << dendl;
derr << __func__ << " layer " << layer->chunks_map	     << " failed with " << err << " trying to decode "	     << layer_want_to_read << " with " << available_chunks << dendl;
derr << __func__ << " want to read " << want_to_read	 << " with available_chunks = " << available_chunks	 << " end up being unable to read " << want_to_read_erasures << dendl;
derr << "k=" << k	   << " must be a positive number" << dendl;
derr << "m=" << m	   << " must be a positive number" << dendl;
derr << "c=" << c	   << " must be a positive number" << dendl;
derr << "c=" << c	   << " must be less than or equal to m=" << m << dendl;
derr << "k=" << k	   << " must be less than or equal to 12" << dendl;
derr << "k+m=" << k+m	   << " must be less than or equal to 20" << dendl;
derr << "m=" << m	   << " must be less than or equal to k=" << k << dendl;
derr << "(k, m, c)=(" << k << ", " << m << ", " << c	 << ") is not a valid parameter." << dendl;
derr << "w=" << w	   << " must be one of {8, 16, 32}" << dendl;
derr << "The Ceph MDS does not support running on Windows at the moment."       << dendl;
derr << "ERROR: failed to refresh rotating keys, "         << "maximum retry time reached." << dendl;
derr << "Invalid rank transition " << mds_rank->get_nodeid() << "->"           << whoami << dendl;
derr << "Invalid state transition " << ceph_mds_state_name(oldstate)      << "->" << ceph_mds_state_name(state) << dendl;
derr << "reply_client_request: failed to replay " << *req	   << " error " << r << " (" << cpp_strerror(r)  << ")" << dendl;
derr << "Decode error at read_pos=0x" << std::hex           << journaler.get_read_pos() << dendl;
derr << "Invalid item (action=" << item.action << ") in purge queue, "            "dropping it" << dendl;
derr << __func__ << ": error reading values: "      << cpp_strerror(values_r) << dendl;
derr << "Corrupt fnode in dirfrag " << dirfrag()	   << ": " << err.what() << dendl;
derr << "Damage to dentries in fragment " << frag << " of ino " << ino         << "is fatal because it is a system directory for this rank" << dendl;
derr << "Damage to fragment " << frag << " of ino " << ino         << " is fatal because it is a system directory for this rank" << dendl;
derr << "corrupt backtrace on ino x0" << std::hex << ino           << std::dec << ": " << decode_exc.what() << dendl;
derr << __func__ << " scrub error on inode " << *in << ": " << css->strv()         << dendl;
derr << " updating snaprealm_v2_since " << snaprealm_v2_since	 << " -> " << v2_since << dendl;
derr << "Problem checking " << oid << ", r=" << r	     << ", st.st_size=" << st.st_size	     << ", file_size=" << file_size	     << ", nr_files=" << td->o.nr_files << dendl;
derr << "fio_ceph_objectstore checked " << checked_or_preallocated	 << " files"<< dendl;
derr << "fio_ceph_objectstore preallocated " << checked_or_preallocated	 << " files"<< dendl;
derr << "ClientStub::" << __func__ << " ERROR: build initial monmap: "	   << cpp_strerror(err) << dendl;
derr << "ClientStub::" << __func__ << " monc init error: "	   << cpp_strerror(-err) << dendl;
derr << "ClientStub::" << __func__ << " monc authenticate error: "	   << cpp_strerror(-err) << dendl;
derr << __func__ << " monc init error: "	   << cpp_strerror(-err) << dendl;
derr << __func__ << " monc authenticate error: "	   << cpp_strerror(-err) << dendl;
derr << __func__	     << " pgid " << pgid << " not on our map" << dendl;
derr << "osd." << whoami << "::" << __func__	     << "** ERROR: applying incremental: "	     << cpp_strerror(err) << dendl;
derr << __func__ << " error building monmap: "           << cpp_strerror(err) << dendl;
derr << __func__ << " monc init failed: "           << cpp_strerror(err) << dendl;
derr << __func__ << " monc auth failed: "           << cpp_strerror(err) << dendl;
derr << "error finding local pool " << pool_name << ": "	 << cpp_strerror(r) << dendl;
derr << "error opening image " << image_name << ": "         << cpp_strerror(r) << dendl;
derr << "--- buffer lengths mismatch " << std::hex         << "expected 0x" << expected.length() << " != actual 0x"         << actual.length() << std::dec << dendl;
derr << "--- buffer mismatch between offset 0x" << std::hex << first         << " and 0x" << last << ", total 0x" << len << std::dec         << dendl;
