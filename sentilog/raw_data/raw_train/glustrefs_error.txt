./glusterfs/tests/basic/logchecks.c:    gf_msg("logchecks", GF_LOG_CRITICAL, 0, logchecks_msg_3);
./glusterfs/tests/basic/logchecks.c:    gf_msg_callingfn("logchecks", GF_LOG_CRITICAL, 0, logchecks_msg_9);
./glusterfs/tests/basic/logchecks.c:    gf_msg("logchecks", GF_LOG_CRITICAL, 0, logchecks_msg_5);
./glusterfs/tests/basic/logchecks.c:    gf_msg("logchecks", GF_LOG_CRITICAL, 0, logchecks_msg_6);
gf_msg("logchecks", GF_LOG_CRITICAL, 22, logchecks_msg_4, 42, "Forty-Two",           42);
gf_msg(this->name, GF_LOG_CRITICAL, 0, P_MSG_SUBVOLUME_ERROR,               "FATAL: storage/posix cannot have subvolumes");
gf_msg(this->name, GF_LOG_CRITICAL, 0, P_MSG_EXPORT_DIR_MISSING,               "Export directory not specified in volume file.");
gf_msg(this->name, GF_LOG_CRITICAL, 0, P_MSG_XATTR_NOTSUP,                       "Extended attribute not supported, "                       "exiting.");
gf_msg(this->name, GF_LOG_CRITICAL, 0, P_MSG_XATTR_NOTSUP,                   "Extended attribute not supported, exiting.");
gf_msg(this->name, GF_LOG_CRITICAL, EINVAL, P_MSG_LEASE_DISABLED,           "\"features/leases\" translator is not loaded. You need"           "to use it for proper functioning of your application");
gf_msg(this->name, GF_LOG_CRITICAL, 0, SHARD_MSG_DOT_SHARD_NODIR,               "%s already exists and "               "is not a directory. Please remove it from all bricks "               "and try again",               shard_internal_dir_string(type));
gf_msg(GF_NFS, GF_LOG_CRITICAL, op_errno, NFS_MSG_LOOKUP_ROOT_FAIL,               "Failed to lookup root: %s", strerror(op_errno));
gf_msg(GF_NFS, GF_LOG_CRITICAL, 0, NFS_MSG_ROOT_LOC_INIT_FAIL,               "Failed to init root loc");
gf_msg(GF_NFS, GF_LOG_CRITICAL, -ret, NFS_MSG_LOOKUP_ROOT_FAIL,               "Failed to lookup root: %s", strerror(-ret));
gf_msg(GF_NFS, GF_LOG_CRITICAL, 0, NFS_MSG_STARTUP_FAIL,                   "Failed to start-up xlator: %s", cl->xlator->name);
gf_msg(GF_NFS, GF_LOG_CRITICAL, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to allocate inode table");
gf_msg(GF_NFS, GF_LOG_CRITICAL, 0, NFS_MSG_XLATOR_INIT_FAIL,                   "Failed to init "                   "xlator: %s",                   cl->xlator->name);
gf_msg(GF_NFS, GF_LOG_CRITICAL, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to allocate fops local pool");
gf_msg(GF_NFS, GF_LOG_CRITICAL, 0, NFS_MSG_INIT_FAIL,               "Failed to init NFS exports");
gf_msg(GF_NFS, GF_LOG_CRITICAL, 0, NFS_MSG_INIT_FAIL,               "Failed to init Mount state");
gf_msg(GF_NFS, GF_LOG_CRITICAL, 0, NFS_MSG_INIT_FAIL,               "Failed to init NLM state");
gf_msg(GF_EXP, GF_LOG_CRITICAL, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to allocate file struct!");
gf_msg(GF_EXP, GF_LOG_CRITICAL, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to allocate dict!");
gf_msg(GF_EXP, GF_LOG_CRITICAL, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to allocate export dir structure!");
gf_msg(GF_EXP, GF_LOG_CRITICAL, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to allocate export item!");
gf_msg(GF_EXP, GF_LOG_CRITICAL, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to allocate options structure!");
gf_msg(GF_MNT, GF_LOG_CRITICAL, EINVAL, NFS_MSG_INVALID_ENTRY,               "mres == NULL, this should *never* happen");
gf_msg(GF_MNT, GF_LOG_CRITICAL, ENOMEM, NFS_MSG_NO_MEMORY,                   "Allocation error when copying "                   "authorized path");
gf_msg(GF_MNT, GF_LOG_CRITICAL, ENOMEM, NFS_MSG_NO_MEMORY,                   "Allocation error when copying "                   "authorized host");
gf_msg(GF_NG, GF_LOG_CRITICAL, -ret, NFS_MSG_PARSE_FAIL,               "Critical error : %s", strerror(-ret));
gf_msg(GF_NG, GF_LOG_CRITICAL, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to allocate netgroup file dict");
gf_msg(GF_NG, GF_LOG_CRITICAL, errno, NFS_MSG_FILE_OP_FAILED,               "Failed to duplicate filename");
gf_msg(GF_NG, GF_LOG_CRITICAL, ENOMEM, NFS_MSG_NO_MEMORY,                   "Allocation error "                   "while parsing line!");
gf_msg(this->name, GF_LOG_CRITICAL, 0,               GD_MSG_SERVER_QUORUM_MET_STARTING_BRICKS,               "Server quorum regained for volume %s. Starting local "               "bricks.",               volinfo->volname);
gf_msg(this->name, GF_LOG_CRITICAL, 0,               GD_MSG_SERVER_QUORUM_LOST_STOPPING_BRICKS,               "Server quorum lost for volume %s. Stopping local "               "bricks.",               volinfo->volname);
gf_msg("glusterd", GF_LOG_CRITICAL, 0, GD_MSG_REQ_FROM_UNKNOWN_PEER,               "Received remove-friend from unknown peer %s", hostname);
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_SERVER_QUORUM_NOT_MET,               "Server quorum not met. Rejecting operation.");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_SERVER_QUORUM_NOT_MET,                   "Server quorum not met. Rejecting operation.");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_REQ_FROM_UNKNOWN_PEER,               "Received friend update request "               "from unknown peer %s",               uuid_utoa(friend_req.uuid));
gf_msg(THIS->name,               (RPC_CLNT_CONNECT == event) ? GF_LOG_CRITICAL : GF_LOG_DEBUG,               ENOENT, GD_MSG_PEER_NOT_FOUND,               "Could not find peer "               "%s(%s)",               peerctx->peername, uuid_utoa(peerctx->peerid));
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_SERVER_QUORUM_NOT_MET,                   "Server quorum not met. Rejecting operation.");
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_DICT_GET_FAILED,               "Failed to get volname "               "from operation context");
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_SPAWN_THREADS_FAIL,               "Failed to spawn post "               "hooks worker thread");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_RESP_FROM_UNKNOWN_PEER,               "cluster lock response received from unknown peer: %s."               "Ignoring response",               uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_RESP_FROM_UNKNOWN_PEER,               "mgmt_v3 lock response received "               "from unknown peer: %s. Ignoring response",               uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_CLUSTER_UNLOCK_FAILED,               "mgmt_v3 unlock response received "               "from unknown peer: %s. Ignoring response",               uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_CLUSTER_UNLOCK_FAILED,               "Unlock response received from unknown peer %s",               uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_RESP_FROM_UNKNOWN_PEER,               "Stage response received "               "from unknown peer: %s. Ignoring response.",               uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_RESP_FROM_UNKNOWN_PEER,               "Commit response for "               "'Volume %s' received from unknown peer: %s",               gd_op_list[opinfo.op], uuid_utoa(rsp.uuid));
gf_msg("glusterd", GF_LOG_CRITICAL, 0, GD_MSG_PEER_NOT_FOUND,                       "Received"                       " event %s with empty peer info",                       glusterd_friend_sm_event_name_get(event_type));
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_BRICK_STOP_FAIL,                   "Unable to stop"                   " brick: %s:%s",                   src_brickinfo->hostname, src_brickinfo->path);
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_BRICK_STOP_FAIL,                       "Unable to stop brick: %s:%s", src_brickinfo->hostname,                       src_brickinfo->path);
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_BRICK_ADD_FAIL,                   "Unable to add dst-brick: "                   "%s to volume: %s",                   dst_brick, volinfo->volname);
gf_msg(this->name, GF_LOG_CRITICAL, 0,                   GD_MSG_GLUSTER_SERVICE_START_FAIL,                   "Failed to start one or more gluster services.");
gf_msg(this->name, GF_LOG_CRITICAL, errno,                       GD_MSG_BRICKINFO_CREATE_FAIL,                       "realpath"                       " () failed for brick %s. The "                       "underlying filesystem may be in bad "                       "state. Error - %s",                       new_brickinfo->path, strerror(errno));
gf_msg(THIS->name, GF_LOG_CRITICAL, errno,                   GD_MSG_BRICKINFO_CREATE_FAIL,                   "realpath"                   " () failed for brick %s. The "                   "underlying filesystem may be in bad "                   "state. Error - %s",                   path, strerror(errno));
gf_msg(THIS->name, GF_LOG_CRITICAL, 0,                       GD_MSG_BRICKINFO_CREATE_FAIL,                       "_is_prefix call failed for brick %s "                       "against brick %s",                       tmp_path, brickinfo->real_path);
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_NO_FREE_PORTS,                       "Couldn't allocate a port");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_QUOTA_CONF_CORRUPT,                   "Quota "                   "configuration store may be corrupt.");
gf_msg(this->name, GF_LOG_CRITICAL, errno,                   GD_MSG_QUOTA_CONF_WRITE_FAIL,                   "Unable to write "                   "gfid %s into quota.conf for %s",                   gfid_str, new_volinfo->volname);
gf_msg(this->name, GF_LOG_CRITICAL, errno,                           GD_MSG_BRICKINFO_CREATE_FAIL,                           "realpath () failed for brick "                           "%s. The underlying filesystem "                           "may be in bad state",                           new_brickinfo->path);
gf_msg(this->name, GF_LOG_CRITICAL, errno,                               GD_MSG_BRICKINFO_CREATE_FAIL,                               "realpath () failed for brick "                               "%s. The underlying filesystem "                               "may be in bad state",                               new_brickinfo->path);
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_BRICK_STOP_FAIL,               "Unable to stop"               " brick: %s:%s",               brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_SPAWN_SVCS_FAIL,               "Failed to spawn bricks"               " and other volume related services");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_OP_VERS_STORE_FAIL,               "Storing glusterd global-info failed ret = %d", ret);
gf_msg(this->name, GF_LOG_CRITICAL, errno,                           GD_MSG_BRICKINFO_CREATE_FAIL,                           "realpath() failed for brick %s"                           ". The underlying file system "                           "may be in bad state",                           brickinfo->path);
gf_msg(this->name, GF_LOG_CRITICAL, errno,                           GD_MSG_BRICKINFO_CREATE_FAIL,                           "realpath() failed for brick %s"                           ". The underlying file system "                           "may be in bad state",                           brickinfo->path);
gf_msg(this->name, GF_LOG_CRITICAL, errno,                       GD_MSG_DICT_GET_FAILED,                       "volname is not present in "                       "operation ctx");
gf_msg(this->name, GF_LOG_CRITICAL, errno,                       GD_MSG_DICT_GET_FAILED,                       "volname is not present in "                       "operation ctx");
gf_msg("glusterd", GF_LOG_CRITICAL, errno,               GD_MSG_WRITE_ACCESS_GRANT_FAIL,               "failed to set up write access to %s for group %d (%s)", path,               gid, strerror(errno));
gf_msg("glusterd", GF_LOG_CRITICAL, 0, GD_MSG_DIRPATH_TOO_LONG,               "directory path %s/" GEOREP " is longer than PATH_MAX",               conf->workdir);
gf_msg("glusterd", GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create " GEOREP " directory %s", georepdir);
gf_msg("glusterd", GF_LOG_CRITICAL, 0, GD_MSG_LOGGROUP_INVALID,                   "group " GEOREP "-log-group %s does not exist", greplg_s);
gf_msg("glusterd", GF_LOG_CRITICAL, 0, GD_MSG_DIRPATH_TOO_LONG,               "directory path %s/" GEOREP " is longer than PATH_MAX",               conf->logdir);
gf_msg("glusterd", GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create " GEOREP " log directory");
gf_msg("glusterd", GF_LOG_CRITICAL, 0, GD_MSG_DIRPATH_TOO_LONG,               "directory path  %s/" GEOREP               "-secondaries"               " is longer than PATH_MAX",               conf->logdir);
gf_msg("glusterd", GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create " GEOREP " secondary log directory");
gf_msg("glusterd", GF_LOG_CRITICAL, 0, GD_MSG_DIRPATH_TOO_LONG,               "directory path  %s/" GEOREP               "-secondaries/mbr"               " is longer than PATH_MAX",               conf->logdir);
gf_msg("glusterd", GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create " GEOREP               " mountbroker secondary log directory");
gf_msg(this->name, GF_LOG_CRITICAL, ENOENT, GD_MSG_DIR_NOT_FOUND,               "Provided snap path %s is not a directory,"               "exiting",               abs_path);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,                   "Unable to create directory %s"                   " ,errno = %d",                   abs_path, errno);
gf_msg(this->name, GF_LOG_CRITICAL, ENOENT, GD_MSG_DIR_NOT_FOUND,               "Provided working area %s is not a directory,"               "exiting",               workdir);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,                   "Unable to create directory %s"                   " ,errno = %d",                   workdir, errno);
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_VAR_RUN_DIR_FIND_FAIL,               "Unable to find "               "the correct var run dir");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_CREATE_DIR_FAILED,               "Unable to create "               "snap backend folder");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_DIR_OP_FAILED,               "Snap mount dir too long");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_DIR_OP_FAILED,               "Unable to create "               "shared storage brick");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_CREATE_DIR_FAILED,               "Unable to create "               "bitd running directory");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_CREATE_DIR_FAILED,               "Unable to create "               "scrub running directory");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_CREATE_DIR_FAILED,               "Unable to create "               "nfs running directory");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_CREATE_DIR_FAILED,               "Unable to create "               "quota running directory");
gf_msg("this->name", GF_LOG_CRITICAL, errno, GD_MSG_FILE_OP_FAILED,               "Unable to create cmd log file %s", cmd_log_filename);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create volume directory %s"               " ,errno = %d",               storedir, errno);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create volume directory %s"               " ,errno = %d",               storedir, errno);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create snaps directory %s"               " ,errno = %d",               storedir, errno);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create peers directory %s"               " ,errno = %d",               storedir, errno);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create logs directory %s"               " ,errno = %d",               storedir, errno);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create nfs directory %s"               " ,errno = %d",               storedir, errno);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create bitrot directory %s", storedir);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create scrub directory %s", storedir);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create glustershd directory %s"               " ,errno = %d",               storedir, errno);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create quotad directory %s"               " ,errno = %d",               storedir, errno);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create glustershd directory %s"               " ,errno = %d",               storedir, errno);
gf_msg(this->name, GF_LOG_CRITICAL, errno, GD_MSG_DIR_OP_FAILED,               "Unable to create hooks directory ");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_BRICK_ADD_FAIL,               "Unable to add dst-brick: "               "%s to volume: %s",               dst_brick, volinfo->volname);
gf_msg(this->name, GF_LOG_CRITICAL, 0,               GD_MSG_GLUSTER_SERVICE_START_FAIL,               "Failed to start one or more gluster services.");
gf_msg(this->name, GF_LOG_CRITICAL, errno,                   GD_MSG_BRICKINFO_CREATE_FAIL,                   "realpath () "                   "failed for brick %s. The underlying filesystem"                   " may be in bad state",                   snap_brick_path);
gf_msg(THIS->name, GF_LOG_CRITICAL, EINVAL, GD_MSG_COMMAND_NOT_FOUND,               "Provided command %s is not a regular file,"               "exiting",               lvm_cmd);
gf_msg(THIS->name, GF_LOG_CRITICAL, 0, GD_MSG_NO_EXEC_PERMS,               "Provided command %s has no exec permissions,"               "exiting",               lvm_cmd);
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_RESP_FROM_UNKNOWN_PEER,               "Staging response "               "for 'Volume %s' received from unknown "               "peer: %s",               gd_op_list[rsp.op], uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_RESP_FROM_UNKNOWN_PEER,               "Commit response "               "for 'Volume %s' received from unknown "               "peer: %s",               gd_op_list[rsp.op], uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_SERVER_QUORUM_NOT_MET,               "Server quorum not met. Rejecting operation.");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_DICT_GET_FAILED,                       "volname is not present in "                       "operation ctx");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_DICT_GET_FAILED,                       "volname is not present in "                       "operation ctx");
gf_msg(this->name, GF_LOG_CRITICAL, -ret, GD_MSG_DICT_GET_FAILED,                   "volname is not present in "                   "operation ctx");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_SERVER_QUORUM_NOT_MET,               "Server quorum not met. Rejecting operation.");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_OPCTX_NULL,               "Operation context is not present.");
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_GLUSTERD_UNLOCK_FAIL,                   "Unable to clear local lock, ret: %d", ret);
gf_msg(this->name, GF_LOG_CRITICAL, 0,                   GD_MSG_GLUSTER_SERVICE_START_FAIL,                   "Failed to start shd for %s.", volinfo->volname);
gf_msg(this->name, GF_LOG_CRITICAL, 0, GD_MSG_SERVER_QUORUM_NOT_MET,                   "Server quorum not met. Rejecting operation.");
gf_msg(this->name, GF_LOG_CRITICAL, 0, DHT_MSG_SUBVOL_INSUFF_INODES,                   "inodes on subvolume '%s' are at "                   "(%.2f %%), consider adding more bricks",                   subvol->name, usage);
gf_msg(this->name, GF_LOG_CRITICAL, 0, DHT_MSG_INVALID_CONFIGURATION,               "Distribute needs more than one subvolume");
gf_msg("", GF_LOG_CRITICAL, 0, LG_MSG_GLOBAL_INIT_FAILED,               "Exiting as global initialization failed");
gf_msg("", GF_LOG_CRITICAL, ret, LG_MSG_PTHREAD_FAILED,               "pthread_once failed");
gf_msg("", GF_LOG_CRITICAL, 0, LG_MSG_UNKNOWN_LOCK_TYPE,                       "unknown lock type");
gf_msg("", GF_LOG_CRITICAL, 0, LG_MSG_UNLOCK_BEFORE_LOCK,               "Unlock called  before lock ");
gf_msg(this->name, GF_LOG_EMERG, 0, P_MSG_HEALTHCHECK_FAILED,           "health-check failed, going down");
gf_msg(this->name, GF_LOG_EMERG, 0, P_MSG_HEALTHCHECK_FAILED,               "still alive! -> SIGTERM");
gf_msg(this->name, GF_LOG_EMERG, 0, P_MSG_HEALTHCHECK_FAILED,               "still alive! -> SIGKILL");
./glusterfs/xlators/storage/posix/src/posix-helpers.c:                gf_msg(this->name, GF_LOG_ERROR, 0, 0, "no memory for value");
./glusterfs/xlators/storage/posix/src/posix-inode-fd-ops.c:        gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FUTIMES_FAILED, "%d", fd);
./glusterfs/xlators/storage/posix/src/posix-inode-fd-ops.c:                    gf_msg(this->name, GF_LOG_ERROR, 0, 0, "set state failed");
./glusterfs/xlators/storage/posix/src/posix-inode-fd-ops.c:                gf_msg_debug(this->name, GF_LOG_ERROR, "remotepath %s", cs_var);
./glusterfs/xlators/storage/posix/src/posix-inode-fd-ops.c:                    gf_msg(this->name, GF_LOG_ERROR, 0, 0, "set state failed");
./glusterfs/xlators/storage/posix/src/posix-inode-fd-ops.c:                gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0, "gf_entry is NULL");
./glusterfs/xlators/features/snapview-server/src/snapview-server-mgmt.c:        gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_NULL_CTX, "ctx is NULL");
./glusterfs/xlators/features/snapview-server/src/snapview-server.c:        gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_NULL_GFID, "gfid is NULL");
./glusterfs/xlators/features/locks/src/posix.c:        gf_msg(this->name, GF_LOG_ERROR, 0, ENOMEM, "Could not get inode");
./glusterfs/xlators/features/locks/src/posix.c:                gf_msg(THIS->name, GF_LOG_ERROR, 0, 0, "lock_dup failed");
./glusterfs/xlators/features/locks/src/posix.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "pl_inode_get failed");
./glusterfs/xlators/features/locks/src/posix.c:            gf_msg(this->name, GF_LOG_ERROR, 0, 0, "pl_ctx_get failed");
./glusterfs/xlators/features/locks/src/posix.c:            gf_msg(this->name, GF_LOG_ERROR, 0, 0, "pl_ctx_get failed");
./glusterfs/xlators/features/locks/src/posix.c:            gf_msg(THIS->name, GF_LOG_ERROR, 0, 0, "invalid locks found");
./glusterfs/xlators/features/locks/src/posix.c:            gf_msg(THIS->name, GF_LOG_ERROR, 0, 0, "empty lock list");
./glusterfs/xlators/features/locks/src/posix.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "pl_inode_get failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync-plugins/src/cloudsyncs3/src/libcloudsyncs3.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "insufficient memory");
./glusterfs/xlators/features/cloudsync/src/cloudsync-plugins/src/cloudsyncs3/src/libcloudsyncs3.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "null priv");
./glusterfs/xlators/features/cloudsync/src/cloudsync-plugins/src/cloudsyncs3/src/libcloudsyncs3.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "Memory accounting init failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync-plugins/src/cloudsyncs3/src/libcloudsyncs3.c:            gf_msg(this->name, GF_LOG_ERROR, 0, 0, "aborting download");
./glusterfs/xlators/features/cloudsync/src/cloudsync-plugins/src/cloudsyncs3/src/libcloudsyncs3.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "iobuf_copy failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync-plugins/src/cloudsyncs3/src/libcloudsyncs3.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "copy_frame failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync-plugins/src/cloudsyncs3/src/libcloudsyncs3.c:            gf_msg(this->name, GF_LOG_ERROR, 0, 0, "curl failure %s", errbuf);
./glusterfs/xlators/features/cloudsync/src/cloudsync-plugins/src/cloudsyncs3/src/libcloudsyncs3.c:            gf_msg(this->name, GF_LOG_ERROR, 0, 0, "curl download failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync-plugins/src/cvlt/src/libcvlt.c:        gf_msg(plugin, GF_LOG_ERROR, ENOMEM, 0, "xlator init failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "insufficient memory");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, ENOMEM, "initialisation failed.");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:            gf_msg(this->name, GF_LOG_ERROR, 0, 0, "null config");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "Memory accounting init failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "truncate failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "local init failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "insufficient memory");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:                gf_msg(this->name, GF_LOG_ERROR, 0, 0, "ctx update failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:                gf_msg(this->name, GF_LOG_ERROR, 0, 0, "ctx update failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg("CS", GF_LOG_ERROR, 0, 0, "fd creation failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "dict_set failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:            gf_msg(this->name, GF_LOG_ERROR, 0, -ret, "ftruncate failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg("CS", GF_LOG_ERROR, 0, 0, "fd creation failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "local init failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "insufficient memory");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, op_errno, "stat check failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:                    gf_msg(this->name, GF_LOG_ERROR, 0, 0, "ctx update failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "dict_set failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "inodelk failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "insuffcient memory");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "local init failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "build_loc failed");
./glusterfs/xlators/features/cloudsync/src/cloudsync.c:                gf_msg(this->name, GF_LOG_ERROR, 0, 0, "ctx allocation failed");
./glusterfs/xlators/features/read-only/src/worm-helper.c:        gf_msg(this->name, GF_LOG_ERROR, -ret, 0, "Error getting xattr");
./glusterfs/xlators/features/read-only/src/worm-helper.c:        gf_msg(this->name, GF_LOG_ERROR, -ret, 0, "Error getting start time");
./glusterfs/xlators/features/read-only/src/worm-helper.c:        gf_msg(this->name, GF_LOG_ERROR, -ret, 0, "Error getting file stat");
./glusterfs/xlators/nfs/server/src/nfs3.c:        gf_msg("nfs", GF_LOG_ERROR, 0, NFS_MSG_STATE_WRONG, "state wrong");
./glusterfs/xlators/nfs/server/src/nfs-fops.c:        gf_msg_nomem(GF_NFS, GF_LOG_ERROR, 4096);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volume-set.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY, "%s", errstr);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volume-set.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY, "%s", errstr);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volume-ops.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volume-ops.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_STARTED, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volume-ops.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRIV_NULL, "priv is NULL");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volume-ops.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volume-ops.c:        gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volume-ops.c:        gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volume-ops.c:        gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volume-ops.c:        gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volume-ops.c:        gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volume-ops.c:        gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_STARTED, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-rpc-ops.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RES_DECODE_FAIL, "error");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-rpc-ops.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RPC_FAILURE, "RPC Error");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-geo-rep.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SESSION_INACTIVE, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-geo-rep.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STATUS_NULL, "Status Empty");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-geo-rep.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GSYNCD_ERROR, "%s", errmsg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-geo-rep.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CMD_EXEC_FAIL, "%s", errmsg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-geo-rep.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNABLE_TO_END, "%s", errmsg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-geo-rep.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GSYNCD_ERROR, "%s", errmsg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-locks.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_EMPTY, "dict is null.");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-locks.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_EMPTY, "dict is null.");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-rebalance.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-rebalance.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-handshake.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RPC_LAYER_ERROR, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-handshake.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-handshake.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RPC_LAYER_ERROR, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-handshake.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-handshake.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RPC_LAYER_ERROR, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-handshake.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-log-ops.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-log-ops.c:        gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-log-ops.c:        gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_STARTED, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-utils.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INODE_SIZE_GET_FAIL, NULL);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-utils.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_KEY_NULL, "Key is NULL");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-utils.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OIP_RETRY_LATER, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-utils.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRKPATH_TOO_LONG, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-snapshot-utils.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_EMPTY, "dict is NULL");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-snapshot-utils.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_EMPTY, "dict is NULL");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-snapshot-utils.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_EMPTY, "dict is NULL");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-replace-brick.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-replace-brick.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-syncop.c:        gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_MGMT_OP_FAIL, "%s", op_err);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-op-sm.c:        gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-op-sm.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_ID_SET_FAIL, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-op-sm.c:        gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-op-sm.c:        gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-op-sm.c:        gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND, "%s", msg);
./glusterfs/xlators/mgmt/glusterd/src/glusterd-brick-ops.c:        gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OIP_RETRY_LATER, "%s", msg);
./glusterfs/xlators/cluster/afr/src/afr-inode-read.c:        gf_msg("", GF_LOG_ERROR, 0, AFR_MSG_INVALID_ARG, "possible NULL deref");
./glusterfs/xlators/cluster/afr/src/afr-inode-read.c:        gf_msg("", GF_LOG_ERROR, 0, AFR_MSG_INVALID_ARG, "possible NULL deref");
./glusterfs/xlators/cluster/afr/src/afr-inode-read.c:        gf_msg("", GF_LOG_ERROR, 0, AFR_MSG_INVALID_ARG, "possible NULL deref");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:        gf_msg("dht", GF_LOG_ERROR, 0, 0, "defrag is NULL");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:            gf_msg(this->name, GF_LOG_ERROR, 0, 0, "Aborting rebalance.");
./glusterfs/xlators/cluster/dht/src/dht-inode-read.c:        gf_msg(this->name, GF_LOG_ERROR, 0, 0, "no layout for fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,                   "readlink[%s] failed", dir_handle);
gf_msg(this->name, GF_LOG_ERROR, P_MSG_XATTR_NOT_REMOVED, errno,                       "removexattr failed. key %s path %s",                       GF_PROTECT_FROM_EXTERNAL_WRITES, loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,                   "post-operation lstat on"                   " parent %s failed",                   par_path);
gf_msg(this->name, GF_LOG_ERROR, ENODATA, P_MSG_NULL_GFID,               "buf->ia_gfid is null for "               "%s",               (real_path) ? real_path : "");
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "pre-operation lstat on parent of %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_CREATE_FAILED,                       "create failed on"                       "%s",                       real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LCHOWN_FAILED,               "lchown on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_ACL_FAILED,               "setting ACLs on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                   "setting xattrs on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_GFID_FAILED,                   "setting gfid on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_MKNOD_FAILED,               "mknod on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "post-operation lstat on parent %s failed", par_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "pre-operation lstat on parent %s failed", par_path);
gf_msg(this->name, GF_LOG_ERROR, errno,                       P_MSG_PREOP_CHECK_FAILED,                       "mkdir (%s/%s): GF_MALLOC failed during"                       " preop of mkdir (%s)",                       pgfid, loc->name, real_path);
gf_msg(this->name, GF_LOG_ERROR, errno,                           P_MSG_PREOP_CHECK_FAILED,                           "mkdir (%s/%s): getxattr failed during"                           " preop of mkdir (%s).",                           pgfid, loc->name, real_path);
gf_msg(this->name, GF_LOG_ERROR, errno,                           P_MSG_PREOP_CHECK_FAILED,                           "mkdir (%s/%s): getxattr on key (%s)"                           " path (%s) failed ",                           pgfid, loc->name, xattr_name, par_path);
gf_msg(this->name, GF_LOG_ERROR, errno,                           P_MSG_PREOP_CHECK_FAILED,                           "mkdir (%s/%s): GF_MALLOC failed during"                           " preop of mkdir (%s)",                           pgfid, loc->name, real_path);
gf_msg(this->name, GF_LOG_ERROR, errno,                           P_MSG_PREOP_CHECK_FAILED,                           "mkdir (%s/%s): getxattr on "                           " key (%s) path (%s) failed "                           "(%s)",                           pgfid, loc->name, xattr_name, par_path,                           strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM,                           P_MSG_PREOP_CHECK_FAILED,                           "mkdir (%s/%s):  "                           "dict allocation failed",                           pgfid, loc->name);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_MKDIR_FAILED,               "mkdir of %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_CHOWN_FAILED,               "chown on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_ACL_FAILED,               "setting ACLs on %s failed ", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,               "setting xattrs on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_GFID_FAILED,               "setting gfid on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "lstat on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "post-operation lstat on parent of %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, P_MSG_UNLINK_FAILED,               "Creation of unlink entry failed");
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_UNLINK_FAILED,               "Creation of unlink entry failed for gfid: %s", unlink_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_UNLINK_FAILED,                   "unlink of gfid handle "                   "failed for path:%s with gfid %s",                   real_path, uuid_utoa(stbuf->ia_gfid));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,                   "lstat on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_UNLINK_FAILED,               "unlink of %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "pre-operation lstat on parent %s failed", par_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_OPEN_FAILED,                   "open of %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,                   "post operation "                   "fstat failed on fd=%d",                   fd);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, P_MSG_DICT_SET_FAILED,                   "failed to set fdstat in dict");
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "post-operation lstat on parent %s failed", par_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "pre-operation lstat on parent %s failed", par_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_MKDIR_FAILED,                   "mkdir of %s failed", priv->trash_path);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_RMDIR_FAILED,               "rmdir of %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                   P_MSG_DIR_OPERATION_FAILED, "%s on %s failed",                   (flags) ? "rename" : "rmdir", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "post-operation lstat on parent of %s failed", par_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "pre-operation lstat on parent %s failed", par_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_SYMLINK_FAILED,               "symlink of %s --> %s failed", real_path, linkname);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LCHOWN_FAILED,               "lchown failed on %s", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_ACL_FAILED,               "setting ACLs on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,               "setting xattrs on %s failed ", real_path);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_GFID_FAILED,               "setting gfid on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "lstat failed on %s", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "post-operation lstat on parent %s failed", par_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "pre-operation lstat on parent %s failed", par_oldpath);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "pre-operation lstat on parent of %s failed", par_newpath);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,                       "lstat on %s failed", real_newpath);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_RENAME_FAILED,                       "rename of %s to %s failed", real_oldpath, real_newpath);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "lstat on %s failed", real_newpath);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "post-operation lstat on parent %s failed", par_oldpath);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "post-operation lstat on parent %s failed", par_newpath);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "lstat failed: %s", par_newpath);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LINK_FAILED,               "link %s to %s failed", real_oldpath, real_newpath);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "lstat on %s failed", real_newpath);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "lstat failed: %s", par_newpath);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "pre-operation lstat on parent %s failed", par_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_DICT_SET_FAILED,                       "setting key %s in dict failed", GF_PREOP_CHECK_FAILED);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_OPEN_FAILED,               "open on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_CHOWN_FAILED,               "chown on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_ACL_FAILED,               "setting ACLs on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,               "setting xattrs on %s failed ", real_path);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_GFID_FAILED,               "setting gfid on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "fstat on %d failed", _fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "post-operation lstat on parent %s failed", par_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "pre-operation lstat on parent %s failed", par_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_CREATE_FAILED,               "create of %s failed", loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "post-operation lstat on parent %s failed", par_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_WRITE_FAILED,               "write on file %s failed", loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,               "setxattr on file %s failed", loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_CLOSE_FAILED,               "setxattr on file %s failed", loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "post-operation lstat on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, *op_errno, P_MSG_XATTR_FAILED,                   "getxattr failed on %s gfid: %s key: %s ",                   real_path ? real_path                             : (real_path_arg ? real_path_arg : "null"),                   inode ? uuid_utoa(inode->gfid) : "null", GF_XATTR_MDATA_KEY);
gf_msg(this->name, GF_LOG_ERROR, *op_errno, P_MSG_XATTR_FAILED,                   "getxattr failed on %s gfid: %s key: %s ",                   real_path ? real_path                             : (real_path_arg ? real_path_arg : "null"),                   inode ? uuid_utoa(inode->gfid) : "null", GF_XATTR_MDATA_KEY);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,               "file: %s: gfid: %s key:%s ",               real_path ? real_path : (real_path_arg ? real_path_arg : "null"),               uuid_utoa(inode->gfid), key);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, P_MSG_NOMEM,                   "Could not allocate mdata. file: %s: gfid: %s",                   real_path ? real_path : "null",                   inode ? uuid_utoa(inode->gfid) : "null");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, P_MSG_NOMEM,                       "Could not allocate mdata. gfid: %s",                       uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_STOREMDATA_FAILED,                   "gfid: %s key:%s ", uuid_utoa(inode->gfid),                   GF_XATTR_MDATA_KEY);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, P_MSG_NOMEM,                       "Could not allocate mdata. file: %s: gfid: %s",                       real_path ? real_path : "null", uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_STOREMDATA_FAILED,                   "file: %s: gfid: %s key:%s ", real_path ? real_path : "null",                   uuid_utoa(inode->gfid), GF_XATTR_MDATA_KEY);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_DIR_OPERATION_FAILED,               "Failed to stat "               "brick path %s",               priv->base_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_DIR_OPERATION_FAILED,               "Failed to set uid/gid for"               " brick path %s",               priv->base_path);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_INVALID_ARGUMENT,               "Unknown mode string: %s", batch_fsync_mode_str);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_INVALID_ARGUMENT,               "Length of separator exceeds 7: %s", gfid2path_sep);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_UNKNOWN_ARGUMENT,               "Unknown xattr user namespace mode string: %s",               xattr_user_namespace_mode_str);
gf_msg("posix_delete_unlink", GF_LOG_ERROR, 0, P_MSG_HANDLE_CREATE,               "Deleting files from  %s failed", unlink_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_HANDLE_CREATE,                       "Checking for %s failed", unlink_path);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_HANDLE_CREATE,                       "Not a directory: %s", unlink_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_HANDLE_CREATE,               "Creating directory %s failed", unlink_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_HANDLE_CREATE,                   "Creating directory %s failed", dir_name);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_HANDLE_CREATE,                   "error mkdir hash-1 %s ", dir_name);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_DIR_OPERATION_FAILED,               "Directory '%s' doesn't exist, exiting.", dir_data->data);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_INVALID_OPTION,                       "wrong option provided for key "                       "\"mandate-attribute\"");
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_INVALID_VOLUME_ID,                   "wrong volume-id (%s) set"                   " in volume file",                   tmp_data->data);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_INVALID_VOLUME_ID,                       "mismatching volume-id (%s) received. "                       "already is a part of volume %s ",                       tmp_data->data, uuid_utoa(old_uuid));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_VOLUME_ID_ABSENT,                   "Extended attribute trusted.glusterfs."                   "volume-id is absent");
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_VOLUME_ID_FETCH_FAILED,                   "failed to fetch proper volume id from export");
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_GFID_SET_FAILED,                   "%s: failed to set gfid", dir_data->data);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_BASEPATH_CHDIR_FAILED,                   "chdir() to \"%s\" failed", _private->base_path);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_INVALID_OPTION_VAL,                   "'export-statfs-size' takes only boolean "                   "options");
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_INVALID_OPTION_VAL,                   "'background-unlink'"                   " takes only boolean options");
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_INVALID_OPTION_VAL,                   "wrong option provided for 'o-direct'");
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_INVALID_OPTION,                   "wrong value provided "                   "for 'update-link-count-parent'");
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_DIR_OPERATION_FAILED,               "Could not lock brick directory (%s)", strerror(op_errno));
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_INVALID_OPTION_VAL,               "'shared-brick-count' takes only integer "               "values");
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_HANDLE_CREATE,               "error open directory failed for dir %s", dir_handle);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_HANDLE_CREATE,                   "error openat failed for file %s", fhash);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_HANDLE_CREATE,               "Posix handle setup failed");
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_HANDLE_CREATE_TRASH,               "Posix landfill setup failed");
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_HANDLE_CREATE,               "Creation of unlink directory failed");
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_POSIX_AIO,                   "Posix AIO init failed");
gf_msg(this->name, GF_LOG_ERROR, errno,               P_MSG_FSYNCER_THREAD_CREATE_FAILED,               "fsyncer thread creation failed");
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_INVALID_ARGUMENT,               "Unknown mode string: %s", batch_fsync_mode_str);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_INVALID_ARGUMENT,               "Length of separator exceeds 7: %s", gfid2path_sep);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_INVALID_ARGUMENT,               "Unknown xattr user namespace mode string: %s",               xattr_user_namespace_mode_str);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_TIMER_DELETE_FAILED,                   "Failed to delete janitor timer");
gf_msg(filler->this->name, GF_LOG_ERROR, errno,                       P_MSG_XDATA_GETXATTR, "Opening file %s failed",                       filler->real_path);
gf_msg(filler->this->name, GF_LOG_ERROR, errno,                       P_MSG_XDATA_GETXATTR, "Read on file %s failed",                       filler->real_path);
gf_msg(filler->this->name, GF_LOG_ERROR, errno,                       P_MSG_XDATA_GETXATTR, "Close on file %s failed",                       filler->real_path);
gf_msg(filler->this->name, GF_LOG_ERROR, 0,                       P_MSG_XDATA_GETXATTR,                       "failed to set dict value. key: %s,"                       "path: %s",                       key, filler->real_path);
gf_msg(filler->this->name, GF_LOG_ERROR, errno,                   P_MSG_XDATA_GETXATTR, "lstat on %s failed",                   filler->real_path ?: uuid_utoa(filler->fd->inode->gfid));
gf_msg(filler->this->name, GF_LOG_ERROR, errno,                   P_MSG_XDATA_GETXATTR, "could not get acl (%s) for %s, %d",                   key, filler->real_path ?: uuid_utoa(filler->fd->inode->gfid),                   ret);
gf_msg(filler->this->name, GF_LOG_ERROR, errno,                   P_MSG_XDATA_GETXATTR,                   "could not set acl (%s) for %s in dictionary", key,                   filler->real_path ?: uuid_utoa(filler->fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, ESTALE, P_MSG_HANDLE_PATH_CREATE,               "Failed to create handle path for %s/%s", uuid_utoa(gfid),               basename ? basename : "");
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_LSTAT_FAILED,                   "lstat failed on %s and return value is %d "                   "instead of -1. Please see dmesg output to "                   "check whether the failure is due to backend "                   "filesystem issue",                   real_path, ret);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, P_MSG_INVALID_ARGUMENT,                   "xattr_req is null");
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "lstat on %s failed", path);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, P_MSG_NULL_GFID,               "gfid is null for %s", loc ? loc->path : "");
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                           "setxattr on %s failed", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                           "%s: key:%s"                           "flags: %u length:%d",                           real_path, key, flags, value->len);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                   "fsetxattr on fd=%d"                   " failed",                   fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                       "fd=%d: key:%s", fd, key);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                   "fd=%d: key:%s", fd, key);
gf_msg(this->name, GF_LOG_ERROR, errno,                   P_MSG_STALE_HANDLE_REMOVE_FAILED,                   "%s: Failed"                   "to remove handle to %s",                   hpath, newpath);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_THREAD_FAILED,               "spawning janitor "               "thread failed");
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_THREAD_FAILED,                       "spawning janitor thread failed");
gf_msg(this->name, GF_LOG_ERROR, ENOENT, P_MSG_FRESHFILE,                       "Fresh file: %s", path);
gf_msg(this->name, GF_LOG_ERROR, ENOENT, P_MSG_FRESHFILE,                       "Fresh file: %s", path);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_READ_FAILED,               "Failed to get fd context for a non-anonymous fd, "               "gfid: %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_READ_FAILED,               "Failed to create handle path (%s)", uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_READ_FAILED,                   "Failed to get anonymous fd for "                   "real_path: %s.",                   real_path);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_READ_FAILED,                   "Failed to get anonymous fd for "                   "real_path: %s.",                   real_path);
gf_msg(xl->name, GF_LOG_ERROR, ret, P_MSG_PTHREAD_CANCEL_FAILED,                       "Failed to send cancellation to health-check thread");
gf_msg(xl->name, GF_LOG_ERROR, errno, P_MSG_HEALTHCHECK_FAILED,                   "unable to setup health-check thread");
gf_msg("posix-disk", GF_LOG_ERROR, errno, P_MSG_STATVFS_FAILED,               "statvfs failed on %s", subvol_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_THREAD_FAILED,                       "spawning disk space check thread failed");
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_GET_FDCTX_FAILED,               "could not get fdctx for fd(%s)",               uuid_utoa(stub->args.fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "could not fstat fd(%s)", uuid_utoa(stub->args.fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_READLINK_FAILED,                   "could not read the "                   "link from the gfid handle %s",                   dir_handle);
gf_msg(this->name, GF_LOG_ERROR, P_MSG_XATTR_FAILED, errno,                       "setxattr failed key %s",                       GF_PROTECT_FROM_EXTERNAL_WRITES);
gf_msg(this->name, GF_LOG_ERROR, 0, errno,                   "fgetxattr"                   " failed");
gf_msg(this->name, GF_LOG_ERROR, 0, errno,                   "fgetxattr"                   " failed");
gf_msg(this->name, GF_LOG_ERROR, 0, errno,                   "getxattr"                   " failed");
gf_msg(this->name, GF_LOG_ERROR, 0, errno,                   "getxattr"                   " failed");
gf_msg(this->name, GF_LOG_ERROR, 0, errno,                   "failed to remove xattr, repair failed");
gf_msg(this->name, GF_LOG_ERROR, 0, errno,                       "truncate failed. File is in inconsistent"                       " state");
gf_msg(this->name, GF_LOG_ERROR, 0, errno,                       "truncate failed. File is in inconsistent"                       " state");
gf_msg(this->name, GF_LOG_ERROR, 0, errno,                       "failed to remove xattr, repair failed");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "getxattr "                   "failed err %d",                   errno);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "getxattr "                   "failed err : %d",                   errno);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "getxattr "                   "failed err : %d",                   errno);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "getxattr "                   "failed err : %d",                   errno);
gf_msg("POSIX", GF_LOG_ERROR, 0, op_errno,               "getxattr failed "               "with %d",               op_errno);
gf_msg(this->name, GF_LOG_ERROR, 0, ENOMEM,                   "failed to"                   " create dict");
gf_msg(this->name, GF_LOG_ERROR, 0, ENOMEM,               "failed to set "               "dict");
gf_msg(this->name, GF_LOG_ERROR, 0, errno,                       " getxattr failed for key %s", GF_CS_OBJECT_REMOTE);
gf_msg(this->name, GF_LOG_ERROR, 0, errno,                   " getxattr failed for key %s", GF_CS_OBJECT_REMOTE);
gf_msg(this->name, GF_LOG_ERROR, 0, errno,                       " getxattr failed for key %s", GF_CS_OBJECT_REMOTE);
gf_msg(this->name, GF_LOG_ERROR, 0, errno,                   " getxattr failed for key %s", GF_CS_OBJECT_REMOTE);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "failed to set"                   "value");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                       "posix_cs_set_state failed");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                           "repair check failed");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                       "posix_cs_set_state failed");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                       "posix_cs_set_state failed");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                           "repair check failed");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                       "posix_cs_set_state failed");
gf_msg(this->name, GF_LOG_ERROR, *op_errno, P_MSG_INVALID_ARGUMENT,               "%s received on %s file (%s)", fop,               (inode->ia_type == IA_IFBLK) ? "block" : "char",               uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_PREOP_CHECK_FAILED,                   "getxattr on key (%s)  failed, path : %s", xattr_name,                   par_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_PREOP_CHECK_FAILED,                   "getxattr on key (%s) failed (%s)", xattr_name,                   strerror(errno));
gf_msg("posix-helpers", GF_LOG_ERROR, P_MSG_XATTR_NOT_REMOVED, errno,               "removexattr failed. key %s path %s", k, real_path);
gf_msg(this->name, GF_LOG_ERROR, *op_errno, P_MSG_FSTAT_FAILED,                   "fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_READV_FAILED,               "readv(async) failed fd=%d.", _fd);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_FSTAT_FAILED,               "fstat failed on fd=%d", _fd);
gf_msg(this->name, GF_LOG_ERROR, -ret, P_MSG_POSIX_IO_URING,               "Failed to submit sqe");
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_WRITEV_FAILED,               "writev(async) failed fd=%d.", _fd);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_FSTAT_FAILED,               "fstat failed on fd=%d", _fd);
gf_msg(this->name, GF_LOG_ERROR, -ret, P_MSG_POSIX_IO_URING,               "Failed to submit sqe");
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_FSYNC_FAILED,               "writev(async) failed fd=%d.", _fd);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_FSTAT_FAILED,               "fstat failed on fd=%d", _fd);
gf_msg(this->name, GF_LOG_ERROR, -ret, P_MSG_POSIX_IO_URING,               "Failed to submit sqe");
gf_msg(this->name, GF_LOG_ERROR, -ret, P_MSG_POSIX_IO_URING,               "submit sqe got zero");
gf_msg(this->name, GF_LOG_ERROR, -ret, P_MSG_POSIX_IO_URING,                   "Failed to get sqe");
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_POSIX_IO_URING,               "io_uring init failed.");
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_LSTAT_FAILED,                   "lstat on gfid-handle %s (path: %s) failed",                   real_path ? real_path : "<null>", loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "setattr (lstat) on gfid-handle %s (path: %s) failed",               real_path ? real_path : "<null>", loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_CHOWN_FAILED,                   "setattr (chown) on %s "                   "failed",                   real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_CHMOD_FAILED,                   "setattr (chmod) on gfid-handle %s (path: %s) "                   "failed",                   real_path, loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_UTIMES_FAILED,                   "setattr (utimes) on gfid-handle %s (path: %s) "                   "failed",                   real_path, loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LCHOWN_FAILED,                   "lchown (gfid-handle: %s, path: %s, -1, -1) "                   "failed",                   real_path, loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "setattr (lstat) on gfid-handle %s (path: %s) failed", real_path,               loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "fsetattr (fstat) failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FCHOWN_FAILED,                   "fsetattr (fchown) failed"                   " on fd=%p",                   fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FCHMOD_FAILED,                   "fsetattr (fchmod) failed"                   " on fd=%p",                   fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FUTIMES_FAILED,                   "fsetattr (futimes) on "                   "failed fd=%p",                   fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FCHOWN_FAILED,                   "fchown (%d, -1, -1) failed", pfd->fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "fsetattr (fstat) failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "fallocate (fstat) failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "file state check failed, fd %p", fd);
gf_msg(this->name, GF_LOG_ERROR, -ret, P_MSG_FALLOCATE_FAILED,               "fallocate failed on %s offset: %jd, "               "len:%zu, flags: %d",               uuid_utoa(fd->inode->gfid), offset, len, flags);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "fallocate (fstat) failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "pre-operation fstat failed on fd = %p", fd);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "file state "                   "check failed, fd %p",                   fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_ZEROFILL_FAILED,               "zerofill failed on fd %d length %" PRId64, pfd->fd, len);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_WRITEV_FAILED,                   "fsync() in writev on fd"                   "%d failed",                   pfd->fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "post operation fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_IPC_NOT_HANDLE,           "GF_LOG_IPC(%d) not handled", op);
gf_msg(this->name, GF_LOG_ERROR, ENOTSUP, P_MSG_SEEK_UNKOWN,                   "don't know what to seek");
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,                   "pre-operation fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "file state check failed, fd %p", fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_OPENDIR_FAILED,               "opendir failed on gfid-handle: %s (path: %s)", real_path,               loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_DIRFD_FAILED,               "dirfd() failed (path: %s, gfid-handle: %s", loc->path,               real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "lstat on %s failed", loc->path ? loc->path : "<null>");
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_READYLINK_FAILED,               "readlink on gfid-handle: %s (path: %s) failed", real_path,               loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "pre-operation lstat on (path: %s gfid-handle: %s) "               "failed",               loc->path, real_path ? real_path : "<null>");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "file state check failed, path %s", loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_TRUNCATE_FAILED,               "truncate on gfid-handle: %s (path: %s) failed", real_path,               loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "lstat on gfid-handle %s (path: %s) failed", real_path,               loc->path);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, P_MSG_INVALID_ARGUMENT,               "open received on a block/char file (%s)",               uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FILE_OP_FAILED,               "open on gfid-handle %s (path: %s), flags: %d", real_path,               loc->path, flags);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,                   "pre-operation fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, P_MSG_INVALID_ARGUMENT,               "readv received on a block/char file (%s)",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,                   "pre-operation fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "file state check failed, fd %p", fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_READ_FAILED,               "read failed on gfid=%s, "               "fd=%p, offset=%" PRIu64 " size=%" GF_PRI_SIZET               ", "               "buf=%p",               uuid_utoa(fd->inode->gfid), fd, offset, size, iobuf->ptr);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, P_MSG_INVALID_ARGUMENT,               "writev received on a block/char file (%s)",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "possible overwrite from internal client, fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "pre-operation fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "file state check failed, fd %p", fd);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_WRITE_FAILED,               "write failed: offset %" PRIu64 ",", offset);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "post-operation fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_WRITEV_FAILED,                   "fsync() in writev on fd %d failed", _fd);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "possible overwrite from internal client, fd=%p", fd_out);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_MUTEX_FAILED,                   "failed to hold write atomic lock on %s",                   uuid_utoa(fd_out->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "pre-operation fstat failed on fd=%p", fd_out);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "file state check failed, fd %p", fd_out);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_COPY_FILE_RANGE_FAILED,               "copy_file_range failed: fd_in: %p (gfid: %s) ,"               " fd_out %p (gfid:%s)",               fd_in, uuid_utoa_r(fd_in->inode->gfid, in_uuid_str), fd_out,               uuid_utoa_r(fd_out->inode->gfid, out_uuid_str));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "post-operation fstat failed on fd=%p", fd_out);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "post-operation fstat failed on fd=%p", fd_in);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_STATVFS_FAILED,               "statvfs failed on gfid-handle %s (path: %s)", real_path,               loc->path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, P_MSG_UNLINK_FAILED,                   "Failed to remove gfid :%s", uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSYNC_FAILED,                   "fdatasync on fd=%p"                   "failed:",                   fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSYNC_FAILED,                   "fsync on fd=%p "                   "failed",                   fd);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                       "mtime "                       "passed is different from seen by file now."                       " Will skip truncating the file");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                       "setxattr failed. key %s err %d", GF_CS_OBJECT_SIZE,                       ret);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                       "setxattr failed. key %s err %d", GF_CS_NUM_BLOCKS, ret);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                       "setxattr failed. key %s err %d", GF_CS_BLOCK_SIZE, ret);
gf_msg(this->name, GF_LOG_ERROR, 0, ENOMEM,                   "Unable to set list-xattr in dict ");
gf_msg(this->name, GF_LOG_ERROR, P_MSG_XATTR_NOT_REMOVED,                           errno, "removexattr failed. key %s path %s",                           xattrs_to_heal[i], loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_LSTAT_FAILED,               "posix_xattr_get_real_filename (lstat) on "               "gfid-handle %s (path: %s) failed",               real_path, loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                   "getxattr failed on "                   "%s: key = %s ",                   leaf_path, key);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                           P_MSG_XATTR_FAILED,                           "getxattr failed on "                           "%s (path: %s): %s ",                           real_path, loc->path, key);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                       "getxattr failed on %s (path: %s): key = %s", real_path,                       loc->path, key);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_DICT_SET_FAILED,                   "dict set operation "                   "on %s (gfid-handle: %s) for the key %s failed.",                   loc->path, real_path, key);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                       "listxattr failed on %s (path: %s)", real_path,                       loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                       "getxattr failed on"                       " %s (path: %s): key = %s ",                       real_path, loc->path, keybuffer);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                       "getxattr failed on"                       " %s (path: %s): key = %s ",                       real_path, loc->path, keybuffer);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_DICT_SET_FAILED,                   "dict set operation "                   "on %s (gfid-handle: %s) for the key %s failed.",                   loc->path, real_path, keybuffer);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "posix_fdget_objectsignature failed");
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                           "fgetxattr"                           " failed on key %s",                           key);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                       "fgetxattr"                       " failed on fd %p for the key %s ",                       fd, key);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_DICT_SET_FAILED,                   "dict set operation "                   "on key %s failed",                   key);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                       "listxattr failed "                       "on %p:",                       fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                       "fgetxattr failed "                       "on fd %p for the key %s ",                       fd, key);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                       "fgetxattr failed o"                       "n the fd %p for the key %s ",                       fd, key);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_DICT_SET_FAILED,                   "dict set operation "                   "failed on key %s",                   key);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_FSTAT_FAILED,               "fsetxattr (fstat)"               "failed on fd=%p",               fd);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_XATTR_FAILED,               "fsetxattr (fstat)"               "failed on fd=%p",               fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                   "removexattr failed on "                   "file/dir %s with gfid: %s (for %s)",                   filler->real_path ? filler->real_path : "",                   uuid_utoa(filler->inode->gfid), key);
gf_msg(this->name, GF_LOG_ERROR, *op_errno, P_MSG_XATTR_FAILED,                       "removexattr on %s with gfid %s "                       "(for %s)",                       real_path, uuid_utoa(inode->gfid), name);
gf_msg(                        this->name, GF_LOG_ERROR, op_errno, P_MSG_XATTR_FAILED,                        "fgetxattr failed on gfid=%s "                        "while doing xattrop: "                        "Key:%s (%s)",                        uuid_utoa(filler->inode->gfid), k, strerror(op_errno));
gf_msg(this->name, GF_LOG_ERROR, EINVAL, P_MSG_UNKNOWN_OP,                       "Unknown xattrop type (%d)"                       " on %s. Please send a bug report to "                       "gluster-devel@gluster.org",                       optype, filler->real_path);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_XATTR_FAILED,                   "setxattr failed on %s "                   "while doing xattrop: key=%s",                   filler->real_path, k);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_XATTR_FAILED,                   "fsetxattr failed on gfid=%s while doing "                   "xattrop: key=%s (%s)",                   uuid_utoa(filler->inode->gfid), k, strerror(op_errno));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_ACCESS_FAILED,               "access failed on %s", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "pre-operation fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "file state check failed, fd %p", fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_TRUNCATE_FAILED,               "ftruncate failed on fd=%p (%" PRId64 "", fd, offset);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "post-operation fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,               "fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "file state check failed, fd %p", fd);
gf_msg(THIS->name, GF_LOG_ERROR, EINVAL, P_MSG_DIR_OPERATION_FAILED,                   "seekdir(0x%llx) failed on dir=%p: "                   "Invalid argument (offset reused from "                   "another DIR * structure?)",                   off, pfd->dir);
gf_msg(THIS->name, GF_LOG_ERROR, errno, P_MSG_DIR_OPERATION_FAILED,                   "telldir failed on dir=%p", pfd->dir);
gf_msg(THIS->name, GF_LOG_ERROR, EINVAL,                       P_MSG_DIR_OPERATION_FAILED,                       "seekdir(0x%llx) failed on dir=%p: "                       "Invalid argument (offset reused from "                       "another DIR * structure?)",                       in_case, pfd->dir);
gf_msg(THIS->name, GF_LOG_ERROR, errno,                   P_MSG_GF_DIRENT_CREATE_FAILED,                   "could not create "                   "gf_dirent for entry %s",                   entry->d_name);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_FSTAT_FAILED,                   "pre-operation fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "file state check failed, fd %p", fd);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, P_MSG_UNLINK_FAILED,                   "Failed to remove gfid :%s", uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                           "listxattr failed on %s", real_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_XATTR_FAILED,                       "getxattr failed on"                       " %s: key = %s ",                       real_path, keybuffer);
gf_msg(this->name, GF_LOG_ERROR, *op_errno, P_MSG_DICT_SET_FAILED,                   "dict set operation "                   "on %s for the key %s failed.",                   real_path, GFID2PATH_VIRT_XATTR_KEY);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_READV_FAILED,               "readv(async) failed fd=%d,size=%lu,offset=%llu (%d)", _fd,               paiocb->iocb.u.c.nbytes, (unsigned long long)paiocb->offset,               res);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_FSTAT_FAILED,               "fstat failed on fd=%d", _fd);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_IO_SUBMIT_FAILED,               "io_submit() returned %d", ret);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_WRITEV_FAILED,               "writev(async) failed fd=%d,offset=%llu (%d)", _fd,               (unsigned long long)paiocb->offset, res);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_FSTAT_FAILED,               "fstat failed on fd=%d", _fd);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_FSTAT_FAILED,               "fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_IO_SUBMIT_FAILED,               "io_submit() returned %d,gfid=%s", ret,               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_FSYNC_FAILED,               "%s(async) failed fd=%d (%d)",               (paiocb->iocb.aio_lio_opcode == IO_CMD_FDSYNC ? "fdatasync"                                                             : "fsync"),               _fd, res);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_FSTAT_FAILED,               "fstat failed on fd=%d", _fd);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_FSTAT_FAILED,               "fstat failed on fd=%p", fd);
gf_msg(this->name, GF_LOG_ERROR, op_errno, P_MSG_IO_SUBMIT_FAILED,               "io_submit() returned %d,gfid=%s", ret,               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, -ret, P_MSG_IO_GETEVENTS_FAILED,                   "io_getevents() returned %d", ret);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_UNKNOWN_OP,                           "unknown op %d found in piocb", paiocb->op);
gf_msg(this->name,                       (errno == ENOENT || errno == ESTALE) ? GF_LOG_DEBUG                                                            : GF_LOG_ERROR,                       errno, P_MSG_READLINK_FAILED,                       "could not read"                       " the link from the gfid handle %s ",                       dir_handle);
gf_msg(this->name, GF_LOG_ERROR, P_MSG_ANCESTORY_FAILED, 0,               "build ancestry failed due to "               "deep directory hierarchy, depth: %d.",               top);
gf_msg(this->name, GF_LOG_ERROR, P_MSG_INODE_RESOLVE_FAILED, 0,                   "posix resolve on the inode %s failed",                   uuid_utoa(gfid_stack[top]));
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_READLINK_FAILED,               "internal readlink failed on %s ", base_str);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_HANDLEPATH_FAILED,               "Unable to form handle path for %s (maxlen = %d)", buf, maxlen);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_HANDLE_CREATE,               "Not a directory: %s", priv->base_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_HANDLE_CREATE,                           "Creating directory %s failed", handle_pfx);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_HANDLE_CREATE,                       "Checking for %s failed", handle_pfx);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_HANDLE_CREATE,                       "Not a directory: %s", handle_pfx);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_HANDLE_CREATE,               "stat for %s failed", handle_pfx);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_HANDLE_CREATE,                       "%s", priv->base_path);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_HANDLE_CREATE,                       "symlink %s creation failed", rootstr);
gf_msg(this->name, GF_LOG_ERROR, 0, P_MSG_HANDLE_CREATE,                   "Different dirs %s (%lld/%lld) != %s (%lld/%lld)",                   priv->base_path, (long long)exportbuf.st_ino,                   (long long)exportbuf.st_dev, rootstr,                   (long long)rootbuf.st_ino, (long long)rootbuf.st_dev);
gf_msg(this->name, GF_LOG_ERROR, errno,                           P_MSG_HANDLE_TRASH_CREATE,                           "Creating directory %s failed", trash);
gf_msg(this->name, GF_LOG_ERROR, errno,                       P_MSG_HANDLE_TRASH_CREATE, "Checking for %s failed",                       trash);
gf_msg(this->name, GF_LOG_ERROR, errno,                       P_MSG_HANDLE_TRASH_CREATE, "Not a directory: %s", trash);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_HANDLE_TRASH_CREATE,               "Not able to move %s -> %s ", old, dest_old);
gf_msg(this->name, GF_LOG_ERROR, errno, P_MSG_HANDLE_CREATE,               "error mkdir hash-2 %s ", uuid_utoa(gfid));
gf_msg(this->name, GF_LOG_ERROR, EINVAL, P_MSG_HANDLE_CREATE,                   "%s - Expected regular file", uuid_utoa(gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_NEW_FD_CTX_FAILED,               "failed to allocate new fd "               "context for gfid %s",               uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0,                   SVS_MSG_GET_INODE_CONTEXT_FAILED,                   "failed to get inode "                   "context for %s",                   uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno, SVS_MSG_OPENDIR_FAILED,                       "failed to "                       "open the directory %s",                       uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno, SVS_MSG_OPEN_FAILED,                       "failed to "                       "open the file %s",                       uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_SET_FD_CONTEXT_FAILED,               "failed to set fd context "               "for gfid %s",               uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno,                           SVS_MSG_CLOSEDIR_FAILED,                           "failed to close the fd for %s",                           uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_CLOSE_FAILED,                           "failed to close the fd for %s",                           uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, local_errno, SVS_MSG_GLFS_NEW_FAILED,               "glfs instance for snap volume %s "               "failed",               dirent->name);
gf_msg(this->name, GF_LOG_ERROR, local_errno,               SVS_MSG_SET_VOLFILE_SERVR_FAILED,               "setting the "               "volfile server %s for snap volume %s "               "failed",               volfile_server, dirent->name);
gf_msg(this->name, GF_LOG_ERROR, local_errno,               SVS_MSG_SET_LOGGING_FAILED,               "failed to set the "               "log file path");
gf_msg(this->name, GF_LOG_ERROR, local_errno, SVS_MSG_GLFS_INIT_FAILED,               "initing the "               "fs for %s failed",               dirent->name);
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_GET_INODE_CONTEXT_FAILED,               "inode context not found for"               " the inode %s",               uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, EINVAL,                       SVS_MSG_GET_SNAPSHOT_LIST_FAILED,                       "Error in refreshing the snaplist "                       "infrastructure");
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_BUILD_TRNSPRT_OPT_FAILED,               "failed to build the "               "transport options");
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_RPC_INIT_FAILED,               "failed to initialize RPC");
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_REG_CBK_PRGM_FAILED,               "failed to register callback program");
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_RPC_CLNT_START_FAILED,               "failed to start the rpc "               "client");
gf_msg(frame->this->name, GF_LOG_ERROR, errno, SVS_MSG_NULL_CTX,               "NULL context");
gf_msg(frame->this->name, GF_LOG_ERROR, errno, SVS_MSG_RPC_CALL_FAILED,               "RPC call is not successful");
gf_msg(frame->this->name, GF_LOG_ERROR, 0, SVS_MSG_XDR_DECODE_FAILED,               "Failed to decode xdr response, rsp.op_ret = %d", rsp.op_ret);
gf_msg(frame->this->name, GF_LOG_ERROR, errno, SVS_MSG_RSP_DICT_EMPTY,               "Response dict is not populated");
gf_msg(frame->this->name, GF_LOG_ERROR, errno,               LG_MSG_DICT_UNSERIAL_FAILED, "Failed to unserialize dictionary");
gf_msg(this->name, GF_LOG_ERROR, errno, SVS_MSG_DICT_GET_FAILED,               "Error retrieving snapcount");
gf_msg(frame->this->name, GF_LOG_ERROR, errno, SVS_MSG_NO_MEMORY,                   "Unable to allocate memory");
gf_msg(this->name, GF_LOG_ERROR, errno, SVS_MSG_DICT_GET_FAILED,                   "Error retrieving snap volname %d", i + 1);
gf_msg(this->name, GF_LOG_ERROR, errno, SVS_MSG_DICT_GET_FAILED,                   "Error retrieving snap uuid %d", i + 1);
gf_msg(this->name, GF_LOG_ERROR, errno, SVS_MSG_DICT_GET_FAILED,                   "Error retrieving snap name %d", i + 1);
gf_msg(this->name, GF_LOG_ERROR, 0, LG_MSG_FRAME_ERROR,               "Error allocating frame");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, SVS_MSG_NO_MEMORY,               "Error allocating dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_DICT_SET_FAILED,               "Error setting volname in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, LG_MSG_DICT_UNSERIAL_FAILED,               "Failed to serialize dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_RPC_REQ_FAILED,               "Error sending snapshot names RPC request");
gf_msg("snapview-server", GF_LOG_ERROR, 0, SVS_MSG_SETFSUID_FAIL,                   "failed to set uid "                   "%u in thread context",                   *uid);
gf_msg("snapview-server", GF_LOG_ERROR, 0, SVS_MSG_SETFSGID_FAIL,                   "failed to set gid "                   "%u in thread context",                   *gid);
gf_msg("snapview-server", GF_LOG_ERROR, 0, SVS_MSG_SETFSGRPS_FAIL,                   "failed to set "                   "groups in thread context");
gf_msg(this->name, GF_LOG_ERROR, *op_errno,                   SVS_MSG_NEW_INODE_CTX_FAILED,                   "failed to "                   "allocate inode context for entry point "                   "directory");
gf_msg(this->name, GF_LOG_ERROR, *op_errno,               SVS_MSG_GET_LATEST_SNAP_FAILED,               "failed to get the latest "               "snapshot");
gf_msg(this->name, GF_LOG_ERROR, *op_errno,               SVS_MSG_GET_GLFS_H_OBJECT_FAILED,               "failed to do lookup and get "               "the handle on the snapshot %s (path: %s, gfid: %s)",               loc->name, loc->path, uuid_utoa(loc->gfid));
gf_msg(this->name, GF_LOG_ERROR, *op_errno,               SVS_MSG_NEW_INODE_CTX_FAILED,               "failed to allocate inode "               "context");
gf_msg(this->name, GF_LOG_ERROR, *op_errno,               SVS_MSG_NEW_INODE_CTX_FAILED,               "failed to allocate "               "inode context");
gf_msg(this->name, GF_LOG_ERROR, *op_errno,               SVS_MSG_NEW_INODE_CTX_FAILED,               "failed to allocate "               "inode context");
gf_msg(this->name, GF_LOG_ERROR, *op_errno,                           SVS_MSG_GET_GLFS_H_OBJECT_FAILED,                           "failed to get the handle for "                           "%s (gfid %s)",                           loc->path, uuid_utoa_r(loc->inode->gfid, tmp_uuid));
gf_msg(this->name, GF_LOG_ERROR, *op_errno,                   SVS_MSG_PARENT_CTX_OR_NAME_NULL, "%s is NULL",                   loc->name ? "parent context" : "loc->name");
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_INODE_CONTEXT_FAILED,               "inode context not found "               "for the inode %s",               uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_OPENDIR_FAILED,                   "opendir on %s failed "                   "(gfid: %s)",                   loc->name, uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,                   SVS_MSG_NEW_FD_CTX_FAILED,                   "failed to allocate fd context "                   "for %s (gfid: %s)",                   loc->name, uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_DICT_SET_FAILED,                   "dict set operation "                   "for the key %s failed.",                   keybuffer);
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_DICT_SET_FAILED,               "dict set operation for the key glusterfs.skip-cache failed.");
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_INODE_CONTEXT_FAILED,               "inode context not found "               "for the inode %s",               uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_NO_MEMORY,                   "failed to allocate dict");
gf_msg(this->name, GF_LOG_ERROR, op_errno,                       SVS_MSG_GETXATTR_FAILED,                       "getxattr on %s failed (key: %s) with %s", loc->path,                       name, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_NO_MEMORY,                   "failed to allocate memory for getxattr "                   "on %s (key: %s)",                   loc->name, name);
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_GETXATTR_FAILED,                   "failed to get the xattr %s for "                   "entry %s",                   name, loc->name);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                       SVS_MSG_DICT_SET_FAILED,                       "dict set operation for %s for "                       "the key %s failed.",                       loc->path, name);
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_NO_MEMORY,                       "failed to add xattrs from the list to "                       "dict for %s (gfid: %s)",                       loc->path, uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_INODE_CONTEXT_FAILED,               "inode context not found "               "for the inode %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_FS_INSTANCE_INVALID,               "glfs instance %p to which the inode %s "               "belongs to does not exist. The snapshot "               "corresponding to the instance might have"               "been deleted or deactivated",               inode_ctx->fs, uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_FD_CONTEXT_FAILED,               "failed to get the fd "               "context for %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_NO_MEMORY,                   "failed to allocate dict "                   "(gfid: %s, key: %s)",                   uuid_utoa(fd->inode->gfid), name);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                       SVS_MSG_GETXATTR_FAILED,                       "getxattr on %s failed "                       "(key: %s)",                       uuid_utoa(fd->inode->gfid), name);
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_NO_MEMORY,                       "failed to "                       "allocate memory for getxattr on %s "                       "(key: %s)",                       uuid_utoa(fd->inode->gfid), name);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                       SVS_MSG_GETXATTR_FAILED,                       "failed to get the xattr %s "                       "for inode %s",                       name, uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,                       SVS_MSG_DICT_SET_FAILED,                       "dict set operation for gfid %s "                       "for the key %s failed.",                       uuid_utoa(fd->inode->gfid), name);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                       SVS_MSG_LISTXATTR_FAILED, "listxattr on %s failed",                       uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_NO_MEMORY,                       "failed to "                       "allocate buffer for xattr "                       "list (%s)",                       uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,                       SVS_MSG_LISTXATTR_FAILED, "listxattr on %s failed",                       uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_NO_MEMORY,                       "failed to add xattrs from the list "                       "to dict (gfid: %s)",                       uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_INODE_CONTEXT_FAILED,               "inode context not found for"               " the inode %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, errno,                           SVS_MSG_RELEASE_FAILED,                           "failed to close "                           "the glfd for %s",                           uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_DELETE_INODE_CONTEXT_FAILED,               "failed to delete the inode "               "context of %s",               uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, SVS_MSG_NO_MEMORY,                       "failed to allocate dentry for %s", dirents[i].name);
gf_msg(this->name, GF_LOG_ERROR, errno, SVS_MSG_TELLDIR_FAILED,                   "telldir failed");
gf_msg(this->name, GF_LOG_ERROR, errno, SVS_MSG_NO_MEMORY,                       "could not create gf_dirent "                       "for entry %s: (%s)",                       entry->d_name, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, SVS_MSG_NO_MEMORY,                       "failed to allocate inode "                       "context for %s",                       entry->d_name);
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_INODE_CONTEXT_FAILED,               "failed to get the inode "               "context for %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,                   SVS_MSG_GET_FD_CONTEXT_FAILED,                   "failed to get the fd context "                   "for the inode %s",                   uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_INODE_CONTEXT_FAILED,               "inode context not found in "               "the inode %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,                   SVS_MSG_GET_FD_CONTEXT_FAILED,                   "failed to get the fd "                   "context for %s",                   uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_INODE_CONTEXT_FAILED,               "inode context not found for %s", uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_STAT_FAILED,                   "glfs_h_stat on %s (gfid: %s) "                   "failed",                   loc->name, uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_INODE_CONTEXT_FAILED,               "inode context not found for"               " the inode %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,                   SVS_MSG_FS_INSTANCE_INVALID,                   "glfs instance %p to which the inode %s "                   "belongs to does not exist. That snapshot "                   "corresponding to the fs instance "                   "might have been deleted or deactivated.",                   inode_ctx->fs, uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,                   SVS_MSG_GET_FD_CONTEXT_FAILED,                   "failed to get the fd context "                   "for %s",                   uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_STAT_FAILED,                   "glfs_fstat on gfid: %s failed", uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_INODE_CONTEXT_FAILED,               "inode context not found for %s", uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_STATFS_FAILED,               "glfs_h_statvfs on %s (gfid: %s) "               "failed",               loc->name, uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_INODE_CONTEXT_FAILED,               "inode context for %s (gfid: %s) "               "not found",               loc->name, uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_OPEN_FAILED,               "glfs_h_open on %s failed (gfid: %s)", loc->name,               uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_NO_MEMORY,               "failed to allocate fd context "               "for %s (gfid: %s)",               loc->name, uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_FS_INSTANCE_INVALID,               "glfs instance to which the inode "               "%s receiving read request belongs, "               "does not exist anymore",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_INODE_CONTEXT_FAILED,               "failed to get the fd "               "context for %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_NO_MEMORY,               "failed to "               "allocate iobuf while reading the "               "file with gfid %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_READ_FAILED,               "glfs_read failed on %s (%s)", uuid_utoa(fd->inode->gfid),               strerror(op_errno));
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_INODE_CONTEXT_FAILED,               "failed to get inode context "               "for %s (gfid: %s)",               loc->name, uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_STAT_FAILED,               "glfs_h_stat on %s (gfid: %s) "               "failed",               loc->name, uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_READLINK_FAILED,               "readlink on %s failed (gfid: %s)", loc->name,               uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SVS_MSG_GET_INODE_CONTEXT_FAILED,               "inode context not found for %s", uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SVS_MSG_ACCESS_FAILED,               "failed to access %s (gfid: %s)", loc->path,               uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, SVS_MSG_NO_MEMORY,               "failed to "               "allocate memory for this->private ");
gf_msg(this->name, GF_LOG_ERROR, EINVAL,               SVS_MSG_GET_SNAPSHOT_LIST_FAILED,               "Error initializing snaplist infrastructure");
gf_msg(this->name, GF_LOG_ERROR, 0, SVS_MSG_INVALID_GLFS_CTX,               "Invalid ctx found");
gf_msg("", GF_LOG_ERROR, 0, Q_MSG_DICT_SERIALIZE_FAIL,               "Failed to serialize reply");
gf_msg(this->name, GF_LOG_ERROR, 0, Q_MSG_DICT_UNSERIALIZE_FAIL,               "failed to unserialize "               "nameless lookup rsp");
gf_msg("this->name", GF_LOG_ERROR, 0, Q_MSG_XDR_DECODE_ERROR,               "xdr decoding error");
gf_msg(this->name, GF_LOG_ERROR, 0, Q_MSG_DICT_UNSERIALIZE_FAIL,                   "Failed to unserialize req-buffer to "                   "dictionary");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, Q_MSG_ENOMEM,               "Failed to set QUOTA_LIMIT_OBJECTS_KEY");
gf_msg(this->name, GF_LOG_ERROR, 0, Q_MSG_XDR_DECODING_FAILED,               "XDR decoding failed");
gf_msg("quota", GF_LOG_ERROR, 0, Q_MSG_RPCCLNT_REGISTER_NOTIFY_FAILED,               "failed to register notify");
gf_msg(this->name, GF_LOG_ERROR, 0, Q_MSG_ENFORCEMENT_FAILED,                       "Failed to "                       "check quota object limit");
gf_msg(this->name, GF_LOG_ERROR, 0, Q_MSG_ENFORCEMENT_FAILED,                       "Failed to "                       "check quota size limit");
gf_msg(this->name, GF_LOG_ERROR, ESTALE,                   Q_MSG_ANCESTRY_BUILD_FAILED,                   "failed to get "                   "common_ancestor for %s and %s",                   local->oldloc.path, local->newloc.path);
gf_msg(this->name, GF_LOG_ERROR, ESTALE, Q_MSG_ANCESTRY_BUILD_FAILED,               "failed to get "               "common_ancestor for %s and %s",               local->oldloc.path, local->newloc.path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, Q_MSG_ENOMEM,               "Dict set failed, deem-statfs option may "               "have no effect");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, Q_MSG_ENOMEM,               "integer to string conversion failed Reason"               ":\"Cannot allocate memory\"");
gf_msg(this->name, GF_LOG_ERROR, 0, Q_MSG_INVALID_VOLFILE,               "FATAL: quota (%s) not configured with "               "exactly one child",               this->name);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, Q_MSG_ENOMEM,               "failed to create local_t's memory pool");
gf_msg(this->name, GF_LOG_ERROR, errno,               INDEX_MSG_INDEX_DIR_CREATE_FAILED,               "%s/%s: Failed to "               "create",               priv->index_basepath, subdir);
gf_msg(this->name, GF_LOG_ERROR, ENOTDIR,               INDEX_MSG_INDEX_DIR_CREATE_FAILED,               "%s/%s: Failed to "               "create, path exists, not a directory ",               priv->index_basepath, subdir);
gf_msg(THIS->name, GF_LOG_ERROR, EINVAL,                   INDEX_MSG_INDEX_READDIR_FAILED,                   "seekdir(0x%llx) failed on dir=%p: "                   "Invalid argument (offset reused from "                   "another DIR * structure?)",                   off, dir);
gf_msg(THIS->name, GF_LOG_ERROR, errno,                   INDEX_MSG_INDEX_READDIR_FAILED, "telldir failed on dir=%p",                   dir);
gf_msg(THIS->name, GF_LOG_ERROR, EINVAL,                       INDEX_MSG_INDEX_READDIR_FAILED,                       "seekdir(0x%llx) failed on dir=%p: "                       "Invalid argument (offset reused from "                       "another DIR * structure?)",                       in_case, dir);
gf_msg(THIS->name, GF_LOG_ERROR, errno,                   INDEX_MSG_INDEX_READDIR_FAILED,                   "could not create gf_dirent for entry %s", entry->d_name);
gf_msg(this->name, GF_LOG_ERROR, op_errno, INDEX_MSG_INDEX_ADD_FAILED,               "%s: Not able to "               "create index",               fpath);
gf_msg(this->name, GF_LOG_ERROR, errno, INDEX_MSG_INDEX_ADD_FAILED,               "%s: Not able to "               "add to index",               fpath);
gf_msg(this->name, GF_LOG_ERROR, errno, INDEX_MSG_INDEX_DEL_FAILED,               "%s: failed to delete"               " from index",               gfid_path);
gf_msg(this->name, GF_LOG_ERROR, op_errno,               INDEX_MSG_INODE_CTX_GET_SET_FAILED,               "Not able to get inode ctx for %s", uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, EINVAL, INDEX_MSG_INDEX_ADD_FAILED,               "Got invalid entry (%s) for pargfid path (%s)", filename,               pgfid_path);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, INDEX_MSG_INDEX_DEL_FAILED,               "Got invalid entry (%s) for pargfid path (%s)", filename,               pgfid_path);
gf_msg(this->name, GF_LOG_ERROR, op_errno, INDEX_MSG_INDEX_DEL_FAILED,               "%s: failed to delete from index/entry-changes", entry_path);
gf_msg(this->name, GF_LOG_ERROR, EINVAL,               INDEX_MSG_INODE_CTX_GET_SET_FAILED,               "Not able to get"               " inode context for %s.",               uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, -ret, INDEX_MSG_DICT_SET_FAILED,                   "xattrop index "                   "gfid set failed");
gf_msg(this->name, GF_LOG_ERROR, -ret, INDEX_MSG_DICT_SET_FAILED,                   "xattrop index "                   "count set failed");
gf_msg(this->name, GF_LOG_ERROR, -ret, INDEX_MSG_DICT_SET_FAILED,                   "dirty index "                   "count set failed");
gf_msg(this->name, GF_LOG_ERROR, EINVAL,               INDEX_MSG_INODE_CTX_GET_SET_FAILED,               "Unable to get inode context for %s", path);
gf_msg(this->name, GF_LOG_ERROR, EINVAL,               INDEX_MSG_INODE_CTX_GET_SET_FAILED,               "Unable to store "               "virtual gfid in inode context for %s",               path);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, INDEX_MSG_DICT_SET_FAILED,                   "Unable to set link-count");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, INDEX_MSG_DICT_SET_FAILED,                   "Unable to set link-count");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, INDEX_MSG_INVALID_GRAPH,               "'index' not configured with exactly one child");
gf_msg(this->name, GF_LOG_ERROR, ret, INDEX_MSG_INVALID_ARGS,               "pthread_cond_init failed");
gf_msg(this->name, GF_LOG_ERROR, ret, INDEX_MSG_INVALID_ARGS,               "pthread_mutex_init failed");
gf_msg(this->name, GF_LOG_ERROR, ret, INDEX_MSG_INVALID_ARGS,               "pthread_attr_init failed");
gf_msg(this->name, GF_LOG_ERROR, errno,               INDEX_MSG_INDEX_DIR_CREATE_FAILED,               "Failed to find parent dir (%s) of index basepath %s.",               index_base_parent, priv->index_basepath);
gf_msg(this->name, GF_LOG_ERROR, errno, INDEX_MSG_FD_OP_FAILED,                   "closedir error");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, UTIME_MSG_NO_MEMORY,               "Memory accounting initialization failed.");
gf_msg(this->name, GF_LOG_ERROR, op_errno, UTIME_MSG_SET_MDATA_FAILED,               "dict set of key for set-ctime-mdata failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, UTIME_MSG_NO_MEMORY,               "Failed to allocate private memory.");
gf_msg(this->name, GF_LOG_ERROR, 0, SDFS_MSG_ENTRYLK_ERROR,                   "Unlocking entry lock failed for %s", local->loc.name);
gf_msg(this->name, GF_LOG_ERROR, 0, SDFS_MSG_ENTRYLK_ERROR,               "Acquiring entry lock failed for directory %s "               "with parent gfid %s",               local->loc.name, gfid);
gf_msg(this->name, GF_LOG_ERROR, 0, SDFS_MSG_ENTRYLK_ERROR,               "Acquiring entry lock failed for directory %s "               "with parent gfid %s",               local->loc.name, gfid);
gf_msg(this->name, GF_LOG_ERROR, 0, SDFS_MSG_ENTRYLK_ERROR,               "Acquiring entry lock failed for directory %s "               "with parent gfid %s",               local->loc.name, gfid);
gf_msg(this->name, GF_LOG_ERROR, 0, SDFS_MSG_ENTRYLK_ERROR,               "Acquiring entry lock failed for directory %s "               "with parent gfid %s",               local->loc.name, gfid);
gf_msg(this->name, GF_LOG_ERROR, 0, SDFS_MSG_ENTRYLK_ERROR,               "Acquiring entry lock failed for directory %s "               "with parent gfid %s",               local->loc.name, gfid);
gf_msg(this->name, GF_LOG_ERROR, 0, SDFS_MSG_ENTRYLK_ERROR,                   "unlocking entry lock failed ");
gf_msg(this->name, GF_LOG_ERROR, 0, SDFS_MSG_ENTRYLK_ERROR,               "Acquiring entry lock failed");
gf_msg(this->name, GF_LOG_ERROR, 0, SDFS_MSG_ENTRYLK_ERROR,               "Acquiring entry lock failed for directory %s "               "with parent gfid %s",               local->loc.name, gfid);
gf_msg(this->name, GF_LOG_ERROR, 0, SDFS_MSG_ENTRYLK_ERROR,               "Acquiring entry lock failed ");
gf_msg(this->name, GF_LOG_ERROR, 0, SDFS_MSG_ENTRYLK_ERROR,               "Acquiring entry lock failed for directory %s "               "with parent gfid %s",               local->loc.name, gfid);
gf_msg(this->name, GF_LOG_ERROR, 0, SDFS_MSG_ENTRYLK_ERROR,               "Acquiring entry lock failed for directory %s "               "with parent gfid %s",               local->loc.name, gfid);
\        gf_msg(THIS->name, GF_LOG_ERROR, 0, EINVAL,               "Could not tokenize domain string from key %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, ENOMEM,               "mem allocation"               " failed for meta lock");
gf_msg(this->name, GF_LOG_ERROR, 0, ENOMEM,               "mem allocation"               " failed for client_uid");
gf_msg(this->name, GF_LOG_ERROR, 0, ENOMEM,               "pl_inode mem allocation failedd");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "frame-root-client is "               "NULL");
gf_msg(THIS->name, GF_LOG_ERROR, 0, 0,                       "mem allocation failed for newlock");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0,                   "mem allocation failed");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, LEASE_MSG_NOT_ENABLED,           "\"features/leases\" translator is not enabled. "           "You need to enable it for proper functioning of your "           "application");
gf_msg(this->name, GF_LOG_ERROR, 0, LEASE_MSG_INVAL_INODE_CTX,               "inode_ctx_get failed");
gf_msg(frame->this->name, GF_LOG_ERROR, ENOMEM, LEASE_MSG_NO_MEM,               "Memory allocation for lease_entry failed");
gf_msg(frame->this->name, GF_LOG_ERROR, ENOMEM, LEASE_MSG_NO_MEM,               "Memory allocation for client_uid failed");
gf_msg(this->name, GF_LOG_ERROR, 0, LEASE_MSG_CLNT_NOTFOUND,                   "There is no client entry found in the cleanup list");
gf_msg(this->name, GF_LOG_ERROR, 0, LEASE_MSG_INODE_NOTFOUND,                   "There is no inode entry found in the cleanup list");
gf_msg(this->name, GF_LOG_ERROR, 0, LEASE_MSG_INVAL_FD_CTX,                       "Unable to get fd ctx");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, LEASE_MSG_INVAL_LEASE_TYPE,                   "Invalid lease type specified");
gf_msg(this->name, GF_LOG_ERROR, 0, LEASE_MSG_RECALL_FAIL,                   "Recall notification to client: %s failed",                   lease_entry->client_uid);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, LEASE_MSG_INVAL_LEASE_ID,               "Invalid lease id, from"               "client:%s",               client_uid);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                   SL_MSG_SELINUX_GLUSTER_XATTR_MISSING,                   "getxattr failed for %s", SELINUX_XATTR);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                   SL_MSG_SELINUX_GLUSTER_XATTR_MISSING,                   "getxattr failed for %s", SELINUX_XATTR);
gf_msg(this->name, GF_LOG_ERROR, 0, SL_MSG_MEM_ACCT_INIT_FAILED,               "Memory accounting init failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, SL_MSG_ENOMEM,               "Failed to create local_t's memory pool");
gf_msg(this->name, GF_LOG_ERROR, 0, CHANGELOG_LIB_MSG_INVOKE_RPC_FAILED,               "Could not initiate probe RPC, bailing out!!!");
gf_msg(primary->name, GF_LOG_ERROR, 0,                   CHANGELOG_LIB_MSG_THREAD_CREATION_FAILED,                   "failed to spawn poller thread");
gf_msg(this->name, GF_LOG_ERROR, 0,                   CHANGELOG_LIB_MSG_NOTIFY_REGISTER_FAILED,                   "Error registering with changelog xlator");
gf_msg(this->name, GF_LOG_ERROR, 0,               CHANGELOG_LIB_MSG_XDR_DECODING_FAILED, "xdr decoding failed");
gf_msg(this->name, GF_LOG_ERROR, 0, CHANGELOG_LIB_MSG_WRITE_FAILED,                   "error writing changelog filename"                   " to tracker file");
gf_msg(this->name, GF_LOG_ERROR, errno, CHANGELOG_LIB_MSG_READ_ERROR,               "could not read from htime file");
gf_msg(this->name, GF_LOG_ERROR, errno, CHANGELOG_LIB_MSG_READ_ERROR,               "cannot read from history metadata file");
gf_msg(this->name, GF_LOG_ERROR, ret,                       CHANGELOG_LIB_MSG_THREAD_CREATION_FAILED,                       "could not create consume-thread");
gf_msg(this->name, GF_LOG_ERROR, ret,                       CHANGELOG_LIB_MSG_PTHREAD_JOIN_FAILED,                       "pthread_join() error");
gf_msg(this->name, GF_LOG_ERROR, 0,                       CHANGELOG_LIB_MSG_PUBLISH_ERROR,                       "publish error, ceased publishing...");
gf_msg(this->name, GF_LOG_ERROR, errno, CHANGELOG_LIB_MSG_PTHREAD_ERROR,               "Pthread init failed");
gf_msg(this->name, GF_LOG_ERROR, errno,                       CHANGELOG_LIB_MSG_READ_ERROR,                       "unable to read htime file");
gf_msg(this->name, GF_LOG_ERROR, ret,                       CHANGELOG_LIB_MSG_PTHREAD_ERROR,                       "unable to sets the detach"                       " state attribute");
gf_msg(this->name, GF_LOG_ERROR, ret,                       CHANGELOG_LIB_MSG_THREAD_CREATION_FAILED,                       "creation of consume parent-thread"                       " failed.");
gf_msg(this->name, GF_LOG_ERROR, errno, CHANGELOG_LIB_MSG_MMAP_FAILED,               "mmap() error");
gf_msg(this->name, GF_LOG_ERROR, errno,                   CHANGELOG_LIB_MSG_ASCII_ERROR,                   "processing binary changelog failed due to "                   " error in writing ascii change");
gf_msg(this->name, GF_LOG_ERROR, errno, CHANGELOG_LIB_MSG_MUNMAP_FAILED,               "munmap() error");
gf_msg(this->name, GF_LOG_ERROR, errno, CHANGELOG_LIB_MSG_MMAP_FAILED,               "mmap() error");
gf_msg(this->name, GF_LOG_ERROR, errno,                   CHANGELOG_LIB_MSG_ASCII_ERROR,                   "processing ascii changelog failed due to "                   " error in writing change");
gf_msg(this->name, GF_LOG_ERROR, errno, CHANGELOG_LIB_MSG_MUNMAP_FAILED,               "munmap() error");
gf_msg(this->name, GF_LOG_ERROR, 0, CHANGELOG_LIB_MSG_CLEANUP_ERROR,               "failed to cleanup processor thread");
gf_msg("", GF_LOG_ERROR, errno, CHANGELOG_LIB_MSG_OPENDIR_ERROR,               "opendir() error");
gf_msg(this->name, GF_LOG_ERROR, 0, CHANGELOG_LIB_MSG_OPENDIR_ERROR,               "could not create entries in history scratch dir");
gf_msg(this->name, GF_LOG_ERROR, 0, CHANGELOG_LIB_MSG_OPENDIR_ERROR,               "could not create entries in scratch dir");
gf_msg(this->name, GF_LOG_ERROR, 0, CHANGELOG_LIB_MSG_WRITE_FAILED,                   "error writing changelog filename"                   " to tracker file");
gf_msg(this->name, GF_LOG_ERROR, 0, BRB_MSG_GET_SIGN_FAILED,               "failed to extract signature info [GFID: %s]",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, BRB_MSG_MARK_BAD_FILE,               "Error setting bad-file marker for %s [GFID: %s | "               "Brick: %s]",               loc->path, uuid_utoa(linked_inode->gfid), child->brick_path);
gf_msg(this->name, GF_LOG_ERROR, 0, BRB_MSG_MARK_BAD_FILE,               "Error marking object %s [GFID: %s] as corrupted", loc->path,               uuid_utoa(linked_inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, BRB_MSG_FD_CREATE_FAILED,               "failed to create fd for inode %s",               uuid_utoa(linked_inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, BRB_MSG_CALC_ERROR,               "error calculating hash for object [GFID: %s]",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, BRB_MSG_ZERO_TIMEOUT_BUG,               "BUG: Zero schedule timeout");
gf_msg(this->name, GF_LOG_ERROR, 0, BRB_MSG_ZERO_TIMEOUT_BUG,               "BUG: Zero schedule timeout");
gf_msg(this->name, GF_LOG_ERROR, 0, BRB_MSG_ZERO_TIMEOUT_BUG,               "BUG: Zero schedule timeout");
gf_msg(this->name, GF_LOG_ERROR, 0, BRB_MSG_UNKNOWN_THROTTLE,                   "Unknown throttle %d", throttle);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, BRB_MSG_NO_MEMORY,               "failed to allocate a new inode for"               "bad object directory");
gf_msg(this->name, GF_LOG_ERROR, 0, BRB_MSG_LOOKUP_FAILED,               "failed to lookup the bad "               "objects directory (gfid: %s (%s))",               uuid_utoa(gfid), strerror(op_errno));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, BRB_MSG_FD_CREATE_FAILED,               "fd creation for the bad "               "objects directory failed (gfid: %s)",               uuid_utoa(BR_BAD_OBJ_CONTAINER));
gf_msg(this->name, GF_LOG_ERROR, op_errno, BRB_MSG_FD_CREATE_FAILED,               "failed to open the bad "               "objects directory %s",               uuid_utoa(BR_BAD_OBJ_CONTAINER));
gf_msg(this->name, GF_LOG_ERROR, 0, BRB_MSG_BAD_OBJ_READDIR_FAIL,               "readdir of the bad "               "objects directory (%s) failed ",               uuid_utoa(BR_BAD_OBJ_CONTAINER));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, BRB_MSG_NO_MEMORY,                   "failed to allocate dict");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, BRB_MSG_NO_MEMORY,                   "failed to allocate dict");
gf_msg(this->name, GF_LOG_ERROR, -ret, BRB_MSG_SSM_FAILED,               "Scrub state machine failed");
gf_msg(this->name, GF_LOG_ERROR, -ret, BRB_MSG_SCRUB_WAIT_FAILED,                   "Scrub wait failed");
gf_msg(this->name, GF_LOG_ERROR, -ret, BRB_MSG_SPAWN_FAILED,               "monitor thread creation failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0,                       "initializing aws secret key failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0,                       "initializing aws key ID failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0,                       "initializing aws bucketid failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0,                       "initializing aws hostname failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0,                       "initializing aws secret key failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0,                       "initializing aws key ID failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0,                       "initializing aws bucketid failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0,                       "initializing aws hostname failed");
gf_msg("CS", GF_LOG_ERROR, ENOMEM, 0,               "memory allocation "               "failure for date");
gf_msg("CS", GF_LOG_ERROR, ENOMEM, 0,               "memory allocation "               "failure for sign_req");
gf_msg(this->name, GF_LOG_ERROR, 0, op_errno,               "write failed "               ". Aborting Download");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "null sign_req, "               "aborting download");
gf_msg("CS", GF_LOG_ERROR, 0, 0,               "null signature, "               "aborting download");
gf_msg("CS", GF_LOG_ERROR, ENOMEM, 0,               "mem allocation "               "failed for buf");
gf_msg(this->name, GF_LOG_ERROR, 0, 0, "download failed. err: %s\n",               curl_easy_strerror(res));
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "curl error "                   "%s\n",                   curl_easy_strerror(res));
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_DLOPEN_FAILED,               " failed to open %s ", LIBARCHIVE_SO);
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_EXTRACTION_FAILED,               " Error extracting get_archstore_methods()");
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_EXTRACTION_FAILED,               " Failed to extract methods in get_archstore_methods");
gf_msg(plugin, GF_LOG_ERROR, ENOMEM, 0,               "should have exactly one child");
gf_msg(plugin, GF_LOG_ERROR, ENOMEM, 0,               "dangling volume. check volfile");
gf_msg(plugin, GF_LOG_ERROR, ENOMEM, CVLT_RESOURCE_ALLOCATION_FAILED,               " failed to allocated request for gfid=%s",               uuid_utoa(locxattr->gfid));
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_EXTRACTION_FAILED,               " failed to extract store info for gfid=%s",               uuid_utoa(locxattr->gfid));
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_EXTRACTION_FAILED,               " failed to extract file info for gfid=%s",               uuid_utoa(locxattr->gfid));
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_EXTRACTION_FAILED,               " failed to extract destination store info for gfid=%s",               uuid_utoa(locxattr->gfid));
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_EXTRACTION_FAILED,               " failed to extract file info for gfid=%s",               uuid_utoa(locxattr->gfid));
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_RESTORE_FAILED,               " failed to restore file gfid=%s from data management store",               uuid_utoa(locxattr->gfid));
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_RESTORE_FAILED,               " restored failed for gfid=%s", uuid_utoa(locxattr->gfid));
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_READ_FAILED,               " reporting end-of-file for gfid=%s", uuid_utoa(locxattr->gfid));
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_READ_FAILED,               " zero size read attempted on gfid=%s",               uuid_utoa(locxattr->gfid));
gf_msg(plugin, GF_LOG_ERROR, ENOMEM, CVLT_NO_MEMORY,               " failed to allocated request for gfid=%s",               uuid_utoa(locxattr->gfid));
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_EXTRACTION_FAILED,               " failed to extract store info for gfid=%s"               " offset=%" PRIu64 " size=%" GF_PRI_SIZET               ", "               " buf=%p",               uuid_utoa(locxattr->gfid), off, size, req->iobuf->ptr);
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_EXTRACTION_FAILED,               " failed to extract file info for gfid=%s"               " offset=%" PRIu64 " size=%" GF_PRI_SIZET               ", "               " buf=%p",               uuid_utoa(locxattr->gfid), off, size, req->iobuf->ptr);
gf_msg(plugin, GF_LOG_ERROR, 0, CVLT_EXTRACTION_FAILED,               " read failed on gfid=%s"               " offset=%" PRIu64 " size=%" GF_PRI_SIZET               ", "               " buf=%p",               uuid_utoa(locxattr->gfid), off, size, req->iobuf->ptr);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "Could not "                   "allocate memory for priv->stores");
gf_msg(this->name, GF_LOG_ERROR, 0, 0, "null store_methods %s",                   dlerror());
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                       "failed to get"                       " read fop %s",                       dlerror());
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "failed to get"                   " download fop %s",                   dlerror());
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "failed to get"                   " init fop %s",                   dlerror());
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "failed to get"                   " reconfigure fop %s",                   dlerror());
gf_msg(this->name, GF_LOG_ERROR, 0, ENOMEM,                   "failed to create "                   "dict");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "dict_set failed key:"               " %s",               GF_CS_OBJECT_STATUS);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                       "could not get file state, unwinding");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                           "second truncate, Unwinding");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "file state "                   "could not be figured, unwinding");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "dict_set failed key:"               " %s",               GF_CS_OBJECT_STATUS);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "dict_set failed key:"               " %s",               GF_CS_OBJECT_STATUS);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "dict_set failed key:"               " %s",               GF_CS_OBJECT_STATUS);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "dict_set failed key:"               " %s",               GF_CS_OBJECT_STATUS);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,           "Stale lock would be found on"           " server");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "No remote store "               "plugins found");
gf_msg(this->name, GF_LOG_ERROR, 0, ENOMEM,               "failed to create "               "dict");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "fsetxattr failed "               "key %s",               GF_CS_OBJECT_DOWNLOADING);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "download failed"               ", remotepath: %s",               local->remotepath);
gf_msg(this->name, GF_LOG_ERROR, 0, -ret,                   "removexattr failed, remotexattr");
gf_msg(this->name, GF_LOG_ERROR, 0, -ret,                   "removexattr failed, downloading xattr, path %s",                   local->remotepath);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "remote path not"               " available. Check posix logs to resolve");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "remote path not"               " available. Check posix logs to resolve");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "No remote store "               "plugins found");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "read failed"               ", remotepath: %s",               local->remotepath);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                       "could not get file state, unwinding");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                           "second readv, Unwinding");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "file state "                   "could not be figured, unwinding");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "status is GF_CS_ERROR."               " Aborting readv");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "dict_set failed key:"               " %s",               GF_CS_OBJECT_STATUS);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   "null inode "                   "returned");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                       "status = GF_CS_ERROR. failed to get "                       " file state");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "status is GF_CS_ERROR."               " Aborting write");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,                   " download failed, unwinding writev");
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_PATH_FAILED,               "Inode path failed on %s", bname);
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SHARD_MSG_UPDATE_FILE_SIZE_FAILED,               "Update to file size"               " xattr failed on %s",               uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_SIZE_SET_FAILED,               "Failed to set size attrs for %s", uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_DICT_OP_FAILED,               "Failed to set key %s into dict. gfid=%s",               GF_XATTR_SHARD_FILE_SIZE, uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_DICT_OP_FAILED,               "Failed to set gfid of %s into dict",               shard_internal_dir_string(type));
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SHARD_MSG_BASE_FILE_LOOKUP_FAILED,               "Lookup on base file"               " failed : %s",               uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, SHARD_MSG_INODE_CTX_SET_FAILED, 0,               "Failed to set inode"               " write params into inode ctx for %s",               uuid_utoa(buf->ia_gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SHARD_MSG_STAT_FAILED,               "stat failed: %s",               local->fd ? uuid_utoa(local->fd->inode->gfid)                         : uuid_utoa((local->loc.inode)->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block "               "size from inode ctx of %s",               uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block "               "size from inode ctx of %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SHARD_MSG_TRUNCATE_LAST_SHARD_FAILED,               "truncate on last"               " shard failed : %s",               uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_PATH_FAILED,                   "Inode path failed on %s.", bname);
gf_msg(this->name, GF_LOG_ERROR, op_errno,               SHARD_MSG_LOOKUP_SHARD_FAILED,               "Lookup on shard %d "               "failed. Base file gfid = %s",               shard_block_num, uuid_utoa(gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_PATH_FAILED,                   "Inode path failed on %s", bname);
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block "               "size from inode ctx of %s",               uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block "               "size from inode ctx of %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block "               "size from inode ctx of %s",               uuid_utoa(oldloc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, local->op_errno, SHARD_MSG_FOP_FAILED,               "failed to delete shards of %s", uuid_utoa(gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_PATH_FAILED,                   "Inode path failed on %s", bname);
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_PATH_FAILED,               "Inode path  failed on %s", entry->d_name);
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_DICT_OP_FAILED,               "Failed to get dict value: key:%s", GF_XATTR_SHARD_BLOCK_SIZE);
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_DICT_OP_FAILED,               "Failed to get dict value: key:%s", GF_XATTR_SHARD_FILE_SIZE);
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_PATH_FAILED,               "Inode path  failed on %s", entry->d_name);
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_SHARDS_DELETION_FAILED,               "Failed to delete %s "               "from /%s",               entry->d_name, GF_SHARD_REMOVE_ME_DIR);
gf_msg(this->name, GF_LOG_ERROR, -ret,                       SHARD_MSG_SHARDS_DELETION_FAILED,                       "Lookup on %s failed, exiting", bname);
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_PATH_FAILED,               "Inode path failed on %s", entry->d_name);
gf_msg(this->name, GF_LOG_ERROR, -ret,                           SHARD_MSG_SHARDS_DELETION_FAILED,                           "Failed to clean up shards of gfid %s",                           entry->d_name);
gf_msg(this->name, GF_LOG_ERROR, op_errno, SHARD_MSG_FOP_FAILED,               "Unlock failed. Please check brick logs for "               "more details");
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_PATH_FAILED,                   "Inode path failed"                   " on pargfid=%s bname=%s",                   uuid_utoa(tmp_loc.parent->gfid), local->loc2.name);
gf_msg(this->name, GF_LOG_ERROR, op_errno, SHARD_MSG_FOP_FAILED,               "Xattrop on marker file failed "               "while performing %s;
entry gfid=%s",        gf_msg(this->name, GF_LOG_ERROR, op_errno, SHARD_MSG_FOP_FAILED,               "Lookup on marker file failed "               "while performing %s;
entry gfid=%s",            gf_msg(this->name, GF_LOG_ERROR, op_errno, SHARD_MSG_FOP_FAILED,                   "Marker file creation "                   "failed while performing %s;
entry gfid=%s",        gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_PATH_FAILED,               "Inode path failed on "               "pargfid=%s bname=%s",               uuid_utoa_r(priv->dot_shard_rm_gfid, g1),               uuid_utoa_r(loc->inode->gfid, g2));
gf_msg(this->name, GF_LOG_ERROR, op_errno, SHARD_MSG_FOP_FAILED,               "Unlock failed. Please check brick logs for "               "more details");
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block "               "size from inode ctx of %s",               uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block "               "size from inode ctx of %s",               uuid_utoa(oldloc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get inode "               "ctx for %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_PATH_FAILED,                   "Inode path failed"                   "on %s, base file gfid = %s",                   bname, uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block "               "size for %s from its inode ctx",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_DICT_OP_FAILED,               "Failed to set " GLUSTERFS_WRITE_UPDATE_ATOMIC               " into "               "dict: %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_DICT_OP_FAILED,               "Failed to set gfid-req for %s",               shard_internal_dir_string(type));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_FD_CTX_SET_FAILED,                   "Failed to set fd "                   "ctx for shard inode gfid=%s",                   uuid_utoa(iter->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block "               "size for %s from its inode ctx",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block size from inode ctx of %s",               uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block size from inode ctx of %s",               uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block size from inode ctx of %s",               uuid_utoa(loc->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block size from inode ctx of %s",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INODE_CTX_GET_FAILED,               "Failed to get block "               "size for %s from its inode ctx",               uuid_utoa(fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_MEM_ACCT_INIT_FAILED,               "Memory accounting init"               "failed");
gf_msg("shard", GF_LOG_ERROR, 0, SHARD_MSG_NULL_THIS,               "this is NULL. init() failed");
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INVALID_VOLFILE,               "Dangling volume. Check volfile");
gf_msg(this->name, GF_LOG_ERROR, 0, SHARD_MSG_INVALID_VOLFILE,               "shard not configured with exactly one sub-volume. "               "Check volfile");
gf_msg(this->name, GF_LOG_ERROR, -ret, 0,               "Error getting worm/retention state");
gf_msg(this->name, GF_LOG_ERROR, -ret, 0,                       "Error setting worm/retention state");
gf_msg(GF_NFS3, GF_LOG_ERROR, ENAMETOOLONG,                    \                       NFS_MSG_STR_TOO_LONG, "strlen too long");
\            gf_msg(GF_NFS3, GF_LOG_ERROR, EFAULT, NFS_MSG_STATE_MISSING,       \                   "NFSv3 state "                                              \                   "missing from RPC request");
\    gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_INDEX_NOT_FOUND,           "searchindex=%d not found", searchindex);
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_EXPORT_ID_FAIL,               "Failed to get export by ID");
gf_msg(GF_NFS3, GF_LOG_ERROR, EACCES, NFS_MSG_NO_RW_ACCESS,        \                   "No read-write access");
\            gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_BAD_HANDLE,               \                   "Bad Handle");
\            gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_RESOLVE_FH_FAIL,          \                   "Unable to "                                                \                   "resolve FH: %s",                                           \                   buf);
\            gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_RESOLVE_STAT, "%s: %s",   \                   strerror(cst->resolve_errno), buf);
\            gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_RESOLVE_STAT, "%s: %s",   \                   strerror(cst->resolve_errno), buf);
\            gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_VOL_DISABLE,              \                   "Volume is disabled: %s", vlm->name);
\        gf_msg(GF_NFS3, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "out of memory");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_INIT_CALL_STAT_FAIL,      \                   "Failed to"                                                 \                   " init call state");
\        gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_STATE_MISSING,               "NFSv3 state not found in RPC request");
gf_msg(GF_NFS3, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to get iobuf");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ENCODE_FAIL,               "Failed to encode message");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_SERIALIZE_REPLY_FAIL,               "Failed to serialize reply");
gf_msg(GF_NFS3, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "failed on iobref_new()");
gf_msg(GF_NFS3, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to add iob to iobref");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_SUBMIT_REPLY_FAIL,               "Reply submission failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_SERIALIZE_REPLY_FAIL,               "Failed to serialize reply");
gf_msg(GF_NFS3, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "failed on iobref_new");
gf_msg(GF_NFS3, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to add iob to iobref");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_SUBMIT_REPLY_FAIL,               "Reply submission failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_STAT_FOP_FAIL,               "Stat fop failed: %s: %s", cs->oploc.path, strerror(-ret));
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_GETATTR_FAIL,               "GETATTR procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_TIMESTAMP_NO_SYNC,               "Timestamps not in sync");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_SETATTR_INVALID,               "cs->setattr_valid is invalid");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_SETATTR_FAIL,               "SETATTR procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Invalid argument, carg value NULL");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_INODE_LOC_FILL_ERROR,                   "nfs_inode_loc_fill"                   " error");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Invalid argument, carg value NULL");
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_HARD_RESOLVE_FAIL,               "failed to start hard resolve");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_LOOKUP_PROC_FAIL,               "LOOKUP procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Invalid argument, carg value NULL");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_ACCESS_PROC_FAIL,               "ACCESS procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_READLINK_PROC_FAIL,               "READLINK procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ANONYMOUS_FD_FAIL,               "Failed to create anonymous fd");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_READ_FAIL,               "READ procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ANONYMOUS_FD_FAIL,               "Failed to create anonymous fd");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_WRITE_FAIL,               "WRITE procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_CREATE_FAIL,               "CREATE procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_DIR_OP_FAIL,               "MKDIR procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, EXDEV, NFS_MSG_SYMLINK_FAIL,               "SYMLINK procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_MKNOD_FAIL,               "MKNOD procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_REMOVE_FAIL,               "REMOVE procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_DIR_OP_FAIL,               "RMDIR procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_RENAME_FAIL,               "RENAME procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, EXDEV, NFS_MSG_LINK_FAIL,               "LINK procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ANONYMOUS_FD_FAIL,               "Fail to create anonymous fd");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_DIR_OP_FAIL,                   "auto-opendir failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_READDIR_FAIL,               "READDIR procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_READDIRP_FAIL,               "READDIRP procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_FSTAT_FAIL,               "FSTAT procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_FSINFO_FAIL,               "FSINFO procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_PATHCONF_FAIL,               "PATHCONF procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ANONYMOUS_FD_FAIL,               "Failed to create anonymous fd.");
gf_msg(GF_NFS3, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Bad arguments");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_COMMIT_FAIL,               "COMMIT procedure failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_READ_FAIL,                   "Failed to read option: nfs3.read-size");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_FORMAT_FAIL,                   "Failed to format option: nfs3.read-size");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_READ_FAIL,                   "Failed to read  option: nfs3.write-size");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_FORMAT_FAIL,                   "Failed to format option: nfs3.write-size");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_READ_FAIL,                   "Failed to read option: nfs3.readdir-size");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_FORMAT_FAIL,                   "Failed to format option: nfs3.readdir-size");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_SNPRINTF_FAIL,               "snprintf failed");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_READ_FAIL,                   "Failed to read option: %s", searchkey);
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_VOLID_MISSING,               "DVM is"               " on but volume-id not given for volume: %s",               exp->subvol->name);
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_PARSE_VOL_UUID_FAIL,                   "Failed to parse volume UUID");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_SNPRINTF_FAIL,               "snprintf failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_READ_FAIL,                   "Failed to read option: %s", searchkey);
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_SNPRINTF_FAIL,               "snprintf failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_READ_FAIL,                   "Failed to read option: %s", searchkey);
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_SNPRINTF_FAIL,               "snprintf failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_READ_FAIL,                   "Failed to read option: %s", searchkey);
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_STR2BOOL_FAIL,                   "Failed to convert str "                   "to gf_boolean_t");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_SNPRINTF_FAIL,               "snprintf failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_READ_FAIL,                   "Failed to read option: %s", searchkey);
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_STR2BOOL_FAIL,                   "Failed to convert str"                   " to gf_boolean_t");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_SUBVOL_INIT_FAIL,               "Failed to init subvol");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_SUBVOL_INIT_FAIL,                   "Failed to init "                   "subvol: %s",                   xl_list->xlator->name);
gf_msg(GF_NFS3, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Memory allocation failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_OPT_INIT_FAIL,               "Failed to init options");
gf_msg(GF_NFS3, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "local mempool creation failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_SUBVOL_INIT_FAIL,               "Failed to init per-subvolume state");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_LISTENERS_CREATE_FAIL,               "Unable to create listeners");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_STATE_INIT_FAIL,               "NFSv3 state init failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_RECONF_FAIL,               "Failed to reconfigure options");
gf_msg(GF_NFS3, GF_LOG_ERROR, 0, NFS_MSG_RECONF_SUBVOL_FAIL,                   "Failed to reconfigure subvol options");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_PROT_INIT_ADD_FAIL,               "Failed to add protocol initializer");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_PGM_NOT_FOUND,               "Program: %s NOT found", prog->progname);
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_PGM_INIT_FAIL,               "Program: %s init failed", prog->progname);
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_PGM_REG_FAIL,               "Program  %s registration failed", prog->progname);
gf_msg(GF_NFS, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Memory allocation failed");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_PGM_INIT_FAIL,                   "Program: %s init failed", prog->progname);
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_PGM_REG_FAIL,                       "%s program  %s registration failed",                       version->required ? "Required" : "Optional",                       prog->progname);
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_PGM_REG_FAIL,                       "Program (ipv6) %s registration failed", prog->progname);
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_PROT_INIT_ADD_FAIL,               "Failed to add MOUNT3 protocol initializer");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_PROT_INIT_ADD_FAIL,               "Failed to add MOUNT1 protocol initializer");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_PROT_INIT_ADD_FAIL,               "Failed to add NFS3 protocol initializer");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_PROT_INIT_ADD_FAIL,                   "Failed to add protocol initializer");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_PROT_INIT_ADD_FAIL,                   "Failed to add ACL protocol initializer");
gf_msg(GF_NFS, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to allocated inited xls");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Memory accounting init failed");
gf_msg(GF_NFS, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "memory allocation failed");
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_DICT_GET_FAILED,                   "Failed to parse dict");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_PARSE_FAIL,                   "Failed to parse uint string");
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_DICT_GET_FAILED,                   "Failed to parse dict");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_PARSE_FAIL,                   "Failed to parse bool string");
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_PARSE_FAIL,                   "Failed to parse dict");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_PARSE_FAIL,                   "Failed to parse bool string");
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_PARSE_FAIL,                   "Failed to parse dict");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_PARSE_FAIL,                   "Failed to parse uint string");
gf_msg(GF_NFS, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "failed mem-allocation");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_DICT_SET_FAILED,                   "dict_set_dynstr error");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_DICT_SET_FAILED,               "dict_set_str error");
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_PARSE_FAIL,                   "Failed to parse dict");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_PARSE_FAIL,                   "Failed to parse bool "                   "string");
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_PARSE_FAIL,                   "Failed to parse dict");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_PARSE_FAIL,                   "Failed to parse bool string");
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_PARSE_FAIL,                   "Failed to parse dict");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_PARSE_FAIL,                   "Failed to parse uint string");
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_PARSE_FAIL,                   "Failed to parse dict");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_PARSE_FAIL,                   "Failed to parse uint string");
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_PARSE_FAIL,                   "Failed to parse dict");
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_PARSE_FAIL,                   "Failed to parse dict");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_PARSE_FAIL,                   "Failed to parse bool "                   "string");
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_PARSE_FAIL,                   "Failed to parse dict");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_PARSE_FAIL,                   "Failed to parse bool string");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_DICT_SET_FAILED,                   "dict_set_str error");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_DICT_SET_FAILED,                   "dict_set_str error");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_INIT_GRP_CACHE_FAIL,               "Failed to initialize group cache.");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_RPC_INIT_FAIL,               "RPC service init failed");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_ENABLE_THROTTLE_FAIL,               "Enabling throttle failed");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_RPC_CONFIG_FAIL,               "Failed to configure outstanding-rpc-limit");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_RECONFIG_FAIL,                   "Reconfiguring %s needs NFS restart",                   options_require_restart[keyindx]);
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_RECONFIG_FAIL,               "Reconfiguring nfs.port needs NFS restart");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_READ_FAIL,                   "Failed to read reconfigured option: "                   "nfs.rpc-statd");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_READ_FAIL,                   "Failed to read reconfigured option:"                   " nfs.mount-rmtab");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_READ_FAIL,                   "Failed to read reconfigured option: "                   "nfs.enable-ino32");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_RECONFIG_FAIL,               "nfs reconfigure state failed");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_RECONFIG_FAIL,               "nfs3 reconfigure state failed");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_RECONFIG_FAIL,               "mount reconfigure state failed");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_RECONFIG_FAIL,               "rpcsvc reconfigure options failed");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_RECONFIG_FAIL,               "Failed to reconfigure outstanding-rpc-limit");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_RECONFIG_FAIL,               "rpcsvc DRC reconfigure failed");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_OPT_INIT_FAIL,               "Failed to init nfs option");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_INIT_FAIL,               "Failed to add initiators");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_INIT_FAIL,               "Failed to initialize protocols");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_INIT_FAIL,               "Failed to initialize DRC");
gf_msg(this->name, GF_LOG_ERROR, -ret, NFS_MSG_VOL_NOT_FOUND,               "Could not get volname");
gf_msg(this->name, GF_LOG_ERROR, 0, NFS_MSG_WRITE_FAIL,                   "Error writing hostname to dict");
gf_msg(this->name, GF_LOG_ERROR, 0, NFS_MSG_WRITE_FAIL,                   "Error writing bytes read to dict");
gf_msg(this->name, GF_LOG_ERROR, 0, NFS_MSG_WRITE_FAIL,                   "Error writing bytes write to dict");
gf_msg(this->name, GF_LOG_ERROR, 0, NFS_MSG_WRITE_FAIL,               "Error writing client count to dict");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_SVC_RUN_RETURNED,           "svc_run returned");
gf_msg(GF_NFS, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to create new fd");
gf_msg(GF_NFS, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to create fd");
gf_msg(GF_NFS, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to create fd");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_ARG_FREE_FAIL,               "unable to free arguments");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_PMAP_UNSET_FAIL,               "pmap_unset failed");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_UDP_SERV_FAIL,               "cannot create udp service.");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_REG_NLMCBK_FAIL,               "unable to register (NLMCBK_PROGRAM, "               "NLMCBK_V0, udp).");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_TCP_SERV_FAIL,               "cannot create tcp service.");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_REG_NLMCBK_FAIL,               "unable to register (NLMCBK_PROGRAM, "               "NLMCBK_V0, tcp).");
gf_msg(GF_EXP, GF_LOG_ERROR, 0, NFS_MSG_PARSE_DIR_FAIL,               "Parsing directory failed: %s", strerror(-ret));
gf_msg(GF_EXP, GF_LOG_ERROR, -ret, NFS_MSG_PARSE_FAIL,               "Critical error: %s", strerror(-ret));
gf_msg(GF_EXP, GF_LOG_ERROR, -ret, NFS_MSG_PARSE_FAIL,               "Critical error: %s", strerror(-ret));
gf_msg(GF_EXP, GF_LOG_ERROR, -ret, NFS_MSG_PARSE_FAIL,                   "Failed to parse line #%lu", line_number);
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Unable to allocate memory");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Unable to allocate memory");
gf_msg(GF_MNT, GF_LOG_ERROR, errno, NFS_MSG_GET_FH_FAIL,               "Unable to get fh for %s", mpath);
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Unable to allocate memory");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_SVC_ERROR,               "svc_sendreply returned error");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_ARG_FREE_FAIL,               "Unable to free arguments");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_SVC_ERROR,               "svcudp_create error");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_SVC_ERROR,               "svc_register error");
gf_msg(GF_NFS, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "strdup failed");
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_PATH_RESOLVE_FAIL,                   "path resolution "                   "failed %s",                   resolvedpath);
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_LOC_FILL_RESOLVE_FAIL,               "loc fill resolution failed %s", resolvedpath);
gf_msg(GF_NFS, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                       "Failed to "                       "allocate memory");
gf_msg(GF_NFS, GF_LOG_ERROR, ENOENT, NFS_MSG_INODE_NOT_FOUND,                   "Inode not found in "                   "itable and no creation was requested.");
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_INODE_LOC_FILL_ERROR,               "Inode loc filling failed.: %s", strerror(-ret));
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_PATH_RESOLVE_FAIL,               "path resolution failed %s", path);
gf_msg(GF_NFS, GF_LOG_ERROR, -ret, NFS_MSG_PATH_RESOLVE_FAIL,               "path resolution failed %s", resolvedpath);
gf_msg(GF_NFS, GF_LOG_ERROR, 0, NFS_MSG_INODE_LOC_FILL_ERROR,               "loc_fill failed %s", resolvedpath);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "could not allocate nfs inode ctx");
gf_msg(this->name, GF_LOG_ERROR, 0, NFS_MSG_INODE_CTX_STORE_FAIL,                   "could not store nfs inode ctx");
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_INODE_LOC_FILL_ERROR,               "inode loc fill failed");
gf_msg(GF_NFS3, GF_LOG_ERROR, op_errno, NFS_MSG_LOOKUP_FAIL,                   "Lookup failed: %s: %s", cs->resolvedloc.path,                   strerror(op_errno));
gf_msg(GF_NFS3, GF_LOG_ERROR, op_errno, NFS_MSG_LOOKUP_FAIL,                   "Lookup failed: %s: %s", cs->resolvedloc.path,                   strerror(op_errno));
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_INODE_LOC_FILL_ERROR,               "Failed to fill loc using gfid: "               "%s",               strerror(-ret));
gf_msg(GF_NFS3, GF_LOG_ERROR, op_errno, NFS_MSG_LOOKUP_ROOT_FAIL,               "Root lookup failed: %s", strerror(op_errno));
gf_msg(GF_NFS3, GF_LOG_ERROR, -ret, NFS_MSG_LOOKUP_ROOT_FAIL,               "Failed to lookup root from itable: %s", strerror(-ret));
gf_msg(this->name, GF_LOG_ERROR, 0, NFS_MSG_GETPWUID_FAIL,               "getpwuid_r(%u) failed", root->uid);
gf_msg(this->name, GF_LOG_ERROR, 0, NFS_MSG_GETPWUID_FAIL,               "getpwuid_r(%u) found nothing", root->uid);
gf_msg(this->name, GF_LOG_ERROR, 0, NFS_MSG_MAP_GRP_LIST_FAIL,               "could not map %s to group list", result->pw_name);
gf_msg(GF_NFS, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,            \                   "Frame creation failed");
\        gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_GFID_DICT_CREATE_FAIL,               "Failed to create gfid dict");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_STATE_MISSING,         \                   "NFSv3 state "                                              \                   "missing from RPC request");
\            gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_INIT_CALL_STAT_FAIL,   \                   "Failed to "                                                \                   "init call state");
\            gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_FH_TO_VOL_FAIL,        \                   "Failed to map "                                            \                   "FH to vol: client=%s, exportid=%s, gfid=%s",               \                   trans->peerinfo.identifier, exportid, gfid);
\            gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_VOLUME_ERROR,          \                   "Stale nfs client %s must be trying to "                    \                   "connect to a deleted volume, please "                      \                   "unmount it.",                                              \                   trans->peerinfo.identifier);
\            gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_VOL_DISABLE,               \                   "Volume is disabled: %s", vlm->name);
\            gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_RESOLVE_FH_FAIL,           \                   "Unable to resolve FH"                                      \                   ": %s",                                                     \                   buf);
\        gf_msg(GF_NLM, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "invalid args");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_CALLER_NOT_FOUND,               "%s was not found in the nlmclnt list", caller_name);
gf_msg(GF_NLM, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "malloc error");
gf_msg(GF_NLM, GF_LOG_ERROR, EINVAL, NFS_MSG_MNT_STATE_NOT_FOUND,               "mount state not found");
gf_msg(GF_NLM, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to get iobuf");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_ENCODE_MSG_FAIL,               "Failed to encode message");
gf_msg(GF_NLM, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to get iobref");
gf_msg(GF_NLM, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to add iob to iobref");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_REP_SUBMIT_FAIL,               "Reply submission failed");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_CLNT_CREATE_ERROR, "%s",               clnt_spcreateerror("Clnt_create()"));
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_CLNT_CALL_ERROR,               "clnt_call(): %s", clnt_sperrno(ret));
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_CLNT_CALL_ERROR,               "clnt_call(): %s", clnt_sperrno(ret));
gf_msg(GF_NLM, GF_LOG_ERROR, ENOLCK, NFS_MSG_NO_MEMORY,               "nlm_get_uniq() "               "returned NULL");
gf_msg(GF_NLM, GF_LOG_ERROR, ENOLCK, NFS_MSG_NO_MEMORY,               "fd_create_uint64() returned NULL");
gf_msg(GF_NLM, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "unable to create frame");
gf_msg(GF_NLM, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Got NULL request!");
gf_msg(GF_NLM, GF_LOG_ERROR, -ret, NFS_MSG_OPEN_FAIL,               "unable to open_and_resume");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NLM, GF_LOG_ERROR, -ret, NFS_MSG_RESOLVE_ERROR,               "unable to resolve and resume");
gf_msg(GF_NLM, GF_LOG_ERROR, EAFNOSUPPORT,                   NFS_MSG_UNSUPPORTED_VERSION,                   "NLM is not supported on IPv6 in this release");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_GET_PORT_ERROR,               "Unable to get NLM port of the client."               " Is the firewall running on client?"               " OR Are RPC services running (rpcinfo -p)?");
gf_msg(GF_NLM, GF_LOG_ERROR, ENOMEM, NFS_MSG_GFID_DICT_CREATE_FAIL,               "dict allocation failed");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,               "dict_set_str error");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,               "dict_set_str error");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,               "dict_set_dynstr error");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,               "dict_set_dynstr error");
gf_msg(GF_NLM, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "rpc_clnt NULL");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_RPC_CLNT_ERROR,               "rpc_clnt_register_connect error");
gf_msg(GF_NLM, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to get iobuf");
gf_msg(GF_NLM, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to get iobref");
gf_msg(GF_NLM, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to add iob to iobref");
gf_msg(GF_NLM, GF_LOG_ERROR, -ret, NFS_MSG_RPC_CLNT_ERROR,               "rpc_clnt_submit error");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_NLMCLNT_NOT_FOUND,               "nlmclnt not found");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_NLMCLNT_NOT_FOUND,               "nlmclnt not found");
gf_msg(GF_NLM, GF_LOG_ERROR, stat, NFS_MSG_LOCK_FAIL,               "unable to call lk()");
gf_msg(GF_NLM, GF_LOG_ERROR, -ret, NFS_MSG_OPEN_FAIL,               "unable to open and resume");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NLM, GF_LOG_ERROR, -ret, NFS_MSG_RESOLVE_ERROR,               "unable to resolve and resume");
gf_msg(GF_NLM, GF_LOG_ERROR, ENOLCK, NFS_MSG_NO_MEMORY,               "nlm_get_uniq() returned NULL");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_FD_LOOKUP_NULL,               "fd_lookup_uint64 retrned NULL");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NLM, GF_LOG_ERROR, -ret, NFS_MSG_RESOLVE_ERROR,               "unable to resolve and resume");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_NLM, GF_LOG_ERROR, -ret, NFS_MSG_RESOLVE_ERROR,               "unable to resolve and resume");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "could not allocate nfs inode ctx");
gf_msg(this->name, GF_LOG_ERROR, 0, NFS_MSG_SHARE_LIST_STORE_FAIL,                   "could not store share list");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_INODE_NOT_FOUND,               "inode not found");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_CLIENT_NOT_FOUND,               "client not found");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding SHARE args");
gf_msg(GF_NLM, GF_LOG_ERROR, -ret, NFS_MSG_SHARE_CALL_FAIL,               "SHARE call failed");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_CLIENT_NOT_FOUND,               "client not found: %s", caller);
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_INODE_NOT_FOUND,               "inode not found: client: %s", caller);
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_INODE_SHARES_NOT_FOUND,               "no shares found for inode:"               "gfid: %s;
client: %s",        gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding UNSHARE args");
gf_msg(GF_NLM, GF_LOG_ERROR, -ret, NFS_MSG_UNSHARE_CALL_FAIL,               "UNSHARE call failed");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding FREE_ALL args");
gf_msg(GF_NLM, GF_LOG_ERROR, EINVAL, NFS_MSG_RPC_CLNT_ERROR,               "Spurious notify?!");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_RPC_CLNT_ERROR,                   "(re)connect with an "                   "unexpected NLM4 procedure (%d)",                   nlm_proc);
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_RPC_CLNT_ERROR,                       "Failed to set "                       "rpc clnt");
gf_msg(GF_NLM, GF_LOG_ERROR, 0, NFS_MSG_RPC_CLNT_ERROR,                   "(re)connect with an unexpected NLM4 procedure "                   "(%d)",                   nlm_proc);
gf_msg(GF_NLM, GF_LOG_ERROR, EINVAL, NFS_MSG_NLM_INIT_FAIL,               "NLM4 init failed");
gf_msg(GF_NLM, GF_LOG_ERROR, ENOMEM, NFS_MSG_GFID_DICT_CREATE_FAIL,               "dict allocation failed");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,               "dict_set_str error");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,                   "dict_set_str error");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,                   "dict_set_str error");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,               "dict_set_str error");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_LISTENERS_CREATE_FAIL,               "Unable to create listeners");
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_UNLINK_ERROR,               "unable to unlink %s: %d", GF_SM_NOTIFY_PIDFILE, errno);
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_UNLINK_ERROR,               "unable to unlink %s", pid_file);
gf_msg(GF_NLM, GF_LOG_ERROR, errno, NFS_MSG_START_ERROR,               "unable to start %s", nfs->rpc_statd);
gf_msg(GF_MNT_AUTH, GF_LOG_ERROR, 0, NFS_MSG_LOAD_PARSE_ERROR,               "Failed to load & parse file"               " %s, see logs for more information",               filename);
gf_msg(GF_MNT_AUTH, GF_LOG_ERROR, 0, NFS_MSG_LOAD_PARSE_ERROR,               "Failed to load file %s, see logs for more "               "information",               filename);
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_MNT_STATE_NOT_FOUND,               "mount state not found");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to get iobuf");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_ENCODE_MSG_FAIL,               "Failed to encode message");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to get iobref");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to add iob to iobref");
gf_msg(GF_MNT, GF_LOG_ERROR, errno, NFS_MSG_REP_SUBMIT_FAIL,               "Reply submission failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "Out of memory");
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Failed to open %s", sh->path);
gf_msg(GF_MNT, GF_LOG_ERROR, errno, NFS_MSG_RWTAB_OVERWRITE_FAIL,               "Failed to overwrite rwtab %s", sh->path);
gf_msg(GF_MNT, GF_LOG_ERROR, errno, NFS_MSG_UPDATE_FAIL,           "Failed to update %s", sh->path);
gf_msg(GF_MNT, GF_LOG_ERROR, errno, NFS_MSG_NO_MEMORY,                   "Out of memory, keeping %s as rmtab", nfs->rmtab);
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_MNT_STATE_NOT_FOUND,               "mount state not found");
gf_msg(GF_NFS, GF_LOG_ERROR, op_errno, NFS_MSG_LOOKUP_MNT_ERROR,               "error=%s", strerror(op_errno));
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Memory allocation failed.");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_INODE_LOC_FILL_ERROR,               "Loc fill failed for export inode"               ": gfid %s, volume: %s",               uuid_utoa(exportinode->gfid), xl->name);
gf_msg(GF_MNT, GF_LOG_ERROR, ENOENT, NFS_MSG_GET_ROOT_INODE_FAIL,               "Failed to get root inode");
gf_msg(GF_MNT, GF_LOG_ERROR, EFAULT, NFS_MSG_RESOLVE_INODE_FAIL,               "Failed to resolve and "               "create inode: parent gfid %s, entry %s",               uuid_utoa(gfid), nextcomp);
gf_msg(GF_NFS, GF_LOG_ERROR, op_errno, NFS_MSG_RESOLVE_SUBDIR_FAIL,               "path=%s (%s)", mres->resolveloc.path, strerror(op_errno));
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "Memory allocation failed.");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "Memory allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_RESOLVE_SYMLINK_ERROR,               "Cannot resolve symlink, path is out of boundary "               "from current location %s and with relative path "               "%s pointed by symlink",               parent_path, relative_path);
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_RESOLVE_ERROR,               "Resolved into an unknown path %s%s "               "from the current location of symlink %s",               absolute_path, mres->remainingdir, parent_path);
gf_msg(GF_MNT, GF_LOG_ERROR, EFAULT, NFS_MSG_RESOLVE_INODE_FAIL,               "Failed to resolve and "               "create inode for volume root: %s",               mres->exp->vol->name);
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Invalid argument");
gf_msg(GF_MNT, GF_LOG_ERROR, EAFNOSUPPORT, NFS_MSG_UNSUPPORTED_VERSION,               "Only IPv4 is supported for subdir-auth");
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,                   "Invalid structure");
gf_msg(GF_MNT, GF_LOG_ERROR, EACCES, NFS_MSG_AUTH_VERIFY_FAILED,                   "AUTH verification failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Memory allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_RESOLVE_SUBDIR_FAIL,               "Failed to resolve export dir: %s", mres->exp->expname);
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_RESOLVE_SUBDIR_FAIL,               "Failed to resolve export dir: %s", exp->expname);
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_RESOLVE_SUBDIR_FAIL,               "Failed to resolve export dir: %s", subdir);
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_MNT_STATE_NOT_FOUND,               "Mount state not present");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_BAD_PEER, "Bad peer %s",               peer_addr);
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_PEER_TOO_LONG,               "Peer too long %s", peer_addr);
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Failed to decode args");
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_MNT_STATE_NOT_FOUND,               "Mount state not present");
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Got NULL request!");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "Memory allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "Memory allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "Memory allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_ARGS_DECODE_ERROR,               "Failed decode args");
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_MNT_STATE_NOT_FOUND,               "Mount state not present");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOENT, NFS_MSG_GET_REMOTE_NAME_FAIL,               "Failed to get remote name: %s", gai_strerror(ret));
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_MNT_STATE_NOT_FOUND,               "Mount state not present");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "Memory allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "Memory allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                           "Memory "                           "allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                           "Memory "                           "allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                       "Memory allocation "                       "failed");
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_MNT_STATE_NOT_FOUND,               "mount state not found");
gf_msg(GF_MNT, GF_LOG_ERROR, EACCES, NFS_MSG_AUTH_VERIFY_FAILED,                   "AUTH(nfs.export-dir) verification failed");
gf_msg(GF_MNT, GF_LOG_ERROR, EFAULT, NFS_MSG_UNKNOWN_MNT_TYPE,                   "Unknown MOUNT3 type");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Memory allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Invalid hostname or IPv4 address: %s", ip);
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Memory allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_PARSE_HOSTSPEC_FAIL,               "Export path is NULL");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Memory allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,                   "Memory allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Memory allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_PARSE_AUTH_PARAM_FAIL,                   "Failed to parse auth param");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Memory allocation failed");
gf_msg(xl->name, GF_LOG_ERROR, ret, NFS_MSG_SET_EXP_FAIL,               "Failed to set the export name");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_INIT_DIR_EXP_FAIL,                   "Failed to init dir "                   "export: %s",                   token);
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_SNPRINTF_FAIL,               "snprintf failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_DICT_GET_FAILED,                   "Failed to read "                   "option: %s",                   searchstr);
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_VOLID_MISSING,               "DVM is on but volume-id not "               "given for volume: %s",               xlator->name);
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_PARSE_VOL_UUID_FAIL,                   "Failed to parse "                   "volume UUID");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_SNPRINTF_FAIL,               "snprintf failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_DICT_GET_FAILED,                   "Failed to read "                   "option: %s",                   searchstr);
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_DIR_EXP_SETUP_FAIL,                   "Dir export "                   "setup failed for volume: %s",                   xlator->name);
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_DICT_GET_FAILED,               "Failed to read option: nfs3.export-volumes");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_STR2BOOL_FAIL,               "Failed to convert string to boolean");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_DICT_GET_FAILED,               "Failed to read option: nfs3.export-dirs");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_STR2BOOL_FAIL,               "Failed to convert string to boolean");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_VOL_INIT_FAIL,                   "Volume init failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Memory allocation failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_OPT_INIT_FAIL,               "Options init failed");
gf_msg(GF_NFS, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to allocate mount state");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_AUTH_ERROR,           "Client [IP=%s, Hostname=%s] not authorized for this mount. "           "Unmounting!",           host_addr_ip, host_addr_fqdn);
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_SET_EXP_AUTH_PARAM_FAIL,                       "Failed to set export auth params.");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_SET_NET_GRP_FAIL,                       "Failed to set netgroup auth params.");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to init mount auth params.");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_SET_EXP_AUTH_PARAM_FAIL,               "Failed to set export auth params.");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_SET_EXP_AUTH_PARAM_FAIL,               "Failed to set netgroup auth params.");
gf_msg(GF_MNT, GF_LOG_ERROR, 0, NFS_MSG_MNT_STATE_INIT_FAIL,               "Mount v3 state init failed");
gf_msg(GF_MNT, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to setup mount dict. Allocation error.");
gf_msg(GF_NFS, GF_LOG_ERROR, ENOMEM, NFS_MSG_GFID_DICT_CREATE_FAIL,               "dict allocation failed");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,               "dict_set_str error");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,                   "dict_set_str error");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,                   "dict_set_str error");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_LISTENERS_CREATE_FAIL,               "Unable to create listeners");
gf_msg(GF_MNT, GF_LOG_ERROR, EINVAL, NFS_MSG_MNT_STATE_INIT_FAIL,               "Mount v3 state init failed");
gf_msg(GF_NFS, GF_LOG_ERROR, ENOMEM, NFS_MSG_GFID_DICT_CREATE_FAIL,               "dict allocation failed");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,               "dict_set_str error");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,                   "dict_set_str error");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,                   "dict_set_str error");
gf_msg(GF_NFS, GF_LOG_ERROR, errno, NFS_MSG_LISTENERS_CREATE_FAIL,               "Unable to create listeners");
gf_msg(GF_MNT, GF_LOG_ERROR, ret, NFS_MSG_RECONF_FAIL,               "Options reconfigure failed");
gf_msg(GF_ACL, GF_LOG_ERROR, errno, NFS_MSG_STATE_MISSING,         \                   "NFSv3 state "                                              \                   "missing from RPC request");
\            gf_msg(GF_ACL, GF_LOG_ERROR, EINVAL, NFS_MSG_BAD_HANDLE,           \                   "Bad Handle");
\            gf_msg(GF_ACL, GF_LOG_ERROR, 0, NFS_MSG_FH_TO_VOL_FAIL,            \                   "Failed to map "                                            \                   "FH to vol: client=%s, exportid=%s, gfid=%s",               \                   trans->peerinfo.identifier, exportid, gfid);
\            gf_msg(GF_ACL, GF_LOG_ERROR, ESTALE, NFS_MSG_VOLUME_ERROR,         \                   "Stale nfs client %s must be trying to "                    \                   "connect to a deleted volume, please "                      \                   "unmount it.",                                              \                   trans->peerinfo.identifier);
\            gf_msg(GF_ACL, GF_LOG_ERROR, 0, NFS_MSG_VOL_DISABLE,               \                   "Volume is disabled: %s", vlm->name);
\            gf_msg(GF_ACL, GF_LOG_ERROR, cst->resolve_errno,                   \                   NFS_MSG_RESOLVE_FH_FAIL,                                    \                   "Unable to resolve "                                        \                   "FH: %s",                                                   \                   buf);
\            gf_msg(GF_ACL, GF_LOG_ERROR, 0, NFS_MSG_INIT_CALL_STAT_FAIL,       \                   "Failed to "                                                \                   "init call state");
\        gf_msg(GF_ACL, GF_LOG_ERROR, EINVAL, NFS_MSG_MNT_STATE_NOT_FOUND,               "mount state not found");
gf_msg(GF_ACL, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to get iobuf");
gf_msg(GF_ACL, GF_LOG_ERROR, errno, NFS_MSG_ENCODE_MSG_FAIL,               "Failed to encode message");
gf_msg(GF_ACL, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to get iobref");
gf_msg(GF_ACL, GF_LOG_ERROR, ENOMEM, NFS_MSG_NO_MEMORY,               "Failed to add iob to iobref");
gf_msg(GF_ACL, GF_LOG_ERROR, errno, NFS_MSG_REP_SUBMIT_FAIL,               "Reply submission failed");
gf_msg(GF_ACL, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Got NULL request!");
gf_msg(GF_ACL, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Invalid argument, frame->local NULL");
gf_msg(GF_ACL, GF_LOG_ERROR, aclcount, NFS_MSG_GET_USER_ACL_FAIL,                   "Failed to get USER ACL");
gf_msg(GF_ACL, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Invalid argument, frame->local NULL");
gf_msg(GF_ACL, GF_LOG_ERROR, aclcount, NFS_MSG_GET_DEF_ACL_FAIL,                   "Failed to get DEFAULT ACL");
gf_msg(GF_ACL, GF_LOG_ERROR, EINVAL, NFS_MSG_INVALID_ENTRY,               "Invalid argument, frame->local NULL");
gf_msg(GF_ACL, GF_LOG_ERROR, stat, NFS_MSG_OPEN_FAIL,               "unable to open_and_resume");
gf_msg(GF_ACL, GF_LOG_ERROR, errno, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_ACL, GF_LOG_ERROR, -ret, NFS_MSG_RESOLVE_ERROR,               "unable to resolve and resume");
gf_msg(GF_NLM, GF_LOG_ERROR, ENOMEM, NFS_MSG_GFID_DICT_CREATE_FAIL,               "dict allocation failed");
gf_msg(GF_ACL, GF_LOG_ERROR, stat, NFS_MSG_OPEN_FAIL,               "unable to open_and_resume");
gf_msg(GF_ACL, GF_LOG_ERROR, errno, NFS_MSG_ARGS_DECODE_ERROR,               "Error decoding args");
gf_msg(GF_ACL, GF_LOG_ERROR, -aclerrno, NFS_MSG_SET_USER_ACL_FAIL,               "Failed to set USER ACL");
gf_msg(GF_ACL, GF_LOG_ERROR, -aclerrno, NFS_MSG_SET_DEF_ACL_FAIL,               "Failed to set DEFAULT ACL");
gf_msg(GF_ACL, GF_LOG_ERROR, -ret, NFS_MSG_RESOLVE_ERROR,               "unable to resolve and resume");
gf_msg(GF_ACL, GF_LOG_ERROR, EINVAL, NFS_MSG_ACL_INIT_FAIL,               "ACL3 init failed");
gf_msg(GF_ACL, GF_LOG_ERROR, ENOMEM, NFS_MSG_GFID_DICT_CREATE_FAIL,               "dict allocation failed");
gf_msg(GF_ACL, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,               "dict_set_str error");
gf_msg(GF_ACL, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,                   "dict_set_str error");
gf_msg(GF_ACL, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,                   "dict_set_str error");
gf_msg(GF_ACL, GF_LOG_ERROR, errno, NFS_MSG_DICT_SET_FAILED,               "dict_set_str error");
gf_msg(GF_ACL, GF_LOG_ERROR, errno, NFS_MSG_LISTENERS_CREATE_FAIL,               "Unable to create listeners");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CACHE_MINMAX_SIZE_INVALID,               "%s", errstr);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY, "%s",                   errstr);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_QUOTA_GET_STAT_FAIL,               "failed to get the quota status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_QUOTA_DISABLED, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INCOMPATIBLE_VALUE,               "%s", errstr);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_DISPERSE, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_REPLICA, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY, "%s",               *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SUBVOLUMES_EXCEED, "%s.",               errstr);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY, "%s",               errstr);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_WRONG_OPTS_SETTING, "%s",               *op_errstr);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY, "%s",               *op_errstr);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_WRONG_OPTS_SETTING, "%s",               *op_errstr);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY, "%s",               *op_errstr);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY, "%s",               *op_errstr);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY, "%s",               *op_errstr);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY, "%s",               *op_errstr);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY, "%s",               *op_errstr);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY, "%s",               *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_STOP_FAIL,                       "Failed to "                       "stop brick %s:%s",                       brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_BRICK_DISCONNECTED, "Failed to start %s:%s",                           brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_STORE_FAIL,                   "Failed to write volinfo for volume %s", volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_DISCONNECTED,                       "Failed to "                       "connect to %s:%s",                       brickinfo->hostname, brickinfo->path);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_SNAPD_OBJ_GET_FAIL,               "Failed to get gfproxyd "               "object from gfproxyd service");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Failed to get volinfo from "               "from gfproxyd");
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Unable to allocate memory");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_NEW_GET_FAIL,               "event generation failed: %d", ret);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_INJECT_FAIL,               "Unable to inject event %d, "               "ret = %d",               event->event, ret);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_NEW_GET_FAIL,               "event generation failed: %d", ret);
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Unable to allocate memory");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_INJECT_FAIL,               "Unable to inject event %d, "               "ret = %d",               event->event, ret);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_IDGEN_FAIL,               "Failed to generate transaction id");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UUID_SET_FAIL,               "Failed to set originator_uuid.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_LOCK_FAIL,                   "Unable to acquire lock on localhost, ret: %d", ret);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCK_GET_FAIL,                   "Unable to acquire lock for %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_EVENT_INJECT_FAIL,               "Failed to acquire cluster"               " lock.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,                       "Unable to release lock for %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode lock "               "request received from peer");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_DICT_CREATE_FAIL,               "Unable to set new dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_EVENT_INJECT_FAIL,               "Failed to inject event GD_OP_EVENT_LOCK");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode stage "               "request received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_CTX_CREATE_FAIL,               "Failed to create req_ctx");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,                   "Unable to set transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_EVENT_INJECT_FAIL,               "Failed to inject event GD_OP_EVENT_STAGE_OP");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode commit "               "request received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "xdr decoding error");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "Failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HOSTNAME_NOTFOUND_IN_DICT,               "Failed to get hostname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PORT_NOTFOUND_IN_DICT,               "Failed to get port");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received from cli");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "Failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HOSTNAME_NOTFOUND_IN_DICT,               "Failed to get hostname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PORT_NOTFOUND_IN_DICT,               "Failed to get port");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FLAGS_NOTFOUND_IN_DICT,               "Failed to get flags");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received from cli");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received from cli");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FLAGS_NOTFOUND_IN_DICT,               "failed to get flags");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received from cli");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UUIDS_SAME_RETRY, "%s",               msg_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received from cli");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set uuid in "               "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLNAME_NOTFOUND_IN_DICT,               "%s", err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, errno,                   GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL, "%s",               "Failed to decode "               "request received from cli");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HOSTNAME_NOTFOUND_IN_DICT,               "%s", msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FLAGS_NOTFOUND_IN_DICT,                   "%s", msg);
gf_msg(this->name, GF_LOG_ERROR, 0,               GD_MSG_SYNC_FROM_LOCALHOST_UNALLOWED, "%s", msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received from client.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode unlock "               "request received from peer");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "No memory.");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received from friend");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received.");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_HOSTNAME_RESOLVE_FAIL,               "Unable to get the remote hostname");
gf_msg(THIS->name, GF_LOG_ERROR, 0,               GD_MSG_HOSTNAME_ADD_TO_PEERLIST_FAIL,               "Couldn't add address to the peer info");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEERINFO_CREATE_FAIL,                       "Could not create peerinfo from dict "                       "for prefix %s",                       key);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_PEER_INFO_UPDATE_FAIL,                       "Failed to "                       "update peer %s",                       peerinfo->hostname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEERINFO_CREATE_FAIL,                       "Failed to store peerinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode probe "               "request");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_UUIDS_SAME_RETRY,               "Peer uuid %s is same as "               "local uuid. Please check the uuid of both the peers "               "from %s/%s",               uuid_utoa(probe_req.uuid), GLUSTERD_DEFAULT_WORKDIR,               GLUSTERD_INFO_FILE);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_HOSTNAME_RESOLVE_FAIL,               "Unable to get the remote hostname");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_PEER_ADD_FAIL,                   "Failed to add peer %s", remote_hostname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received from cli");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLNAME_NOTFOUND_IN_DICT,               "%s", err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode mount "               "request received");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode umount"               "request");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set frame-timeout");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "failed to set ssl-enabled in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RPC_CREATE_FAIL,               "failed to create rpc for"               " peer %s",               peerinfo->hostname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEERINFO_CREATE_FAIL,                   "Failed to store peerinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEERINFO_CREATE_FAIL,                   "Failed to store peerinfo");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_NEW_GET_FAIL,               "Unable to get new event");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_INJECT_FAIL,               "Unable to inject event %d, "               "ret = %d",               event->event, ret);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CMDSTR_NOTFOUND_IN_DICT,                   "Failed to get "                   "command string");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_CMDSTR_NOTFOUND_IN_DICT,                   "Failed to get "                   "command string");
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Out of Memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received from cli");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize buffer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND, "%s",                   err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received from cli");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to unserialize req-buffer to"                   " dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CLI_REQ_EMPTY,               "Empty cli request.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLNAME_NOTFOUND_IN_DICT,               "%s", err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_NOT_FOUND,               "Invalid brickid");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received from cli");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,               "Failed to unserialize "               "request dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLNAME_NOTFOUND_IN_DICT,               "Volname not present in "               "dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLNAME_NOTFOUND_IN_DICT,               "%s", err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               FMTSTR_CHECK_VOL_EXISTS, volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to "                       "set %s in dictionary",                       key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to "                       "get %s in dictionary",                       key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to "                       "set %s in dictionary",                       key);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_UNKNOWN_KEY,                       "%s", err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Failed to set warning "                           "message in dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Failed"                           "to set %s in dictionary",                           key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Failed"                           " to set value for key %s in "                           "dictionary",                           key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Failed"                           " to set %s in dictionary",                           key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Failed"                           " to set value for key %s in "                           "dictionary",                           key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Failed to set %s in "                           "dictionary",                           key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Failed to set value for key "                           "%s in dictionary",                           key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Failed to set %s in "                           "dictionary",                           key);
gf_msg(this->name, GF_LOG_ERROR, 0,                               GD_MSG_DICT_SET_FAILED,                               "Failed to set %s in "                               " dictionary",                               key);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,                   "Failed to set count "                   "value in the dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_STATE_STR_GET_FAILED,                   "Failed to get status for snapshot: %s", snapinfo->snapname);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Unable to allocate memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RPC_FAILURE,               "Failed to retrieve rpc object");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Unable to allocate memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Couldn't get client count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get client hostname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get bytesread from client");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get byteswrite from client");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get client opversion");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",                   err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",                   err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to get the output path");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set output path");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_OPTS_IMPORT_FAIL,                       "Failed to "                       "fetch the value of all volume options "                       "for volume %s",                       volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STATE_STR_GET_FAILED,                   "Failed to get type for volume: %s", volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STATE_STR_GET_FAILED,                   "Failed to get status for volume: %s", volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STATE_STR_GET_FAILED,                   "Failed to get transport type for volume: %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STATE_STR_GET_FAILED,                   "Failed to get quorum status for volume: %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STATE_STR_GET_FAILED,                   "Failed to get rebalance status for volume: %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                       "statfs error: %s ", strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_CLIENTS_GET_STATE_FAILED,                       "Failed to get client details");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                       "Failed to get volinfo from "                       "brickid(%s)",                       brickid);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_STOP_FAIL,                           "Unable to stop %s:%s", brickinfo->hostname,                           brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                           "Failed to get volinfo from "                           "brickid(%s)",                           brickid);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_INJECT_FAIL,               "Unable to create event for removing peer %s",               peerinfo->hostname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HANDSHAKE_FAILED,                       "glusterd handshake failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, EEXIST, GD_MSG_VOL_ALREADY_EXIST, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_OP_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get 'force' flag");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set username for "               "volume %s",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set password for "               "volume %s",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL, "%s",               err_str);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               op_errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_OP_FAILED, "%s",               op_errstr);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get brick count "               "for volume %s",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume id of "               "volume %s",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UUID_PARSE_FAIL,               "Unable to parse volume id of"               " volume %s",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get bricks for "               "volume %s",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                           "Bricks check : Could"                           " not retrieve replica count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                           "Bricks check : Could"                           " not retrieve disperse count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BAD_BRKORDER,                       "Not creating the volume because of "                       "bad brick order. %s",                       msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESOLVE_BRICK_FAIL,                   FMTSTR_RESOLVE_BRICK, brick_info->hostname,                   brick_info->path);
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_BRICK_MOUNTDIR_GET_FAIL,                           "Failed to get brick mount_dir");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set local_brick_count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_STAGE_CREATE_VOL_FAIL,               "%s", msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               FMTSTR_CHECK_VOL_EXISTS, volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESOLVE_BRICK_FAIL,                   FMTSTR_RESOLVE_BRICK, brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_BRICK_MOUNTDIR_GET_FAIL,                           "Failed to get brick mount_dir");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set local_brick_count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_STAGE_START_VOL_FAIL,               "%s", msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_STAGE_DELETE_VOL_FAIL,               "%s", msg);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Unable to allocate memory for volinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get type of volume"               " %s",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get brick count of"               " volume %s",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get port");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get bricks for "               "volume %s",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set "                       "performance.client-io-threads to off");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get "                   "replica count for volume %s",                   volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Unable to get thin arbiter brick for "                       "volume %s",                       volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get "                   "disperse count for volume %s",                   volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get "                   "redundancy count for volume %s",                   volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNSUPPORTED_VERSION,                   "Disperse volume "                   "needs op-version 3.6.0 or higher");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get transport type of volume %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume-id of volume %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UUID_PARSE_FAIL,               "unable to parse uuid %s of volume %s", str, volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "unable to get internal username of volume %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "unable to get internal password of volume %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESOLVE_BRICK_FAIL,                   FMTSTR_RESOLVE_BRICK, brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "%s not present", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FAIL_DEFAULT_OPT_SET,               "Failed to set default "               "options on create for volume %s",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_SET_FAIL,               "Failed to store volinfo of "               "%s volume",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               FMTSTR_CHECK_VOL_EXISTS, volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                           "%s not present", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set nfs.disable for"                       "volume %s",                       volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_STOP_FAIL,                   "Failed to stop "                   "brick (%s)",                   brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_SET_FAIL,               "Failed to store volinfo of "               "%s volume",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_GRAPH_CHANGE_NOTIFY_FAIL,               "Failed to notify graph "               "change for %s volume",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               FMTSTR_CHECK_VOL_EXISTS, volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_STOP_FAILED,               "Failed to stop %s volume", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               FMTSTR_CHECK_VOL_EXISTS, volname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create logdir %s", logdir);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Failed to create volfile");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FAILED_INIT_QUOTASVC,                   "Failed to init "                   "gfproxyd service");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Failed to read volume "               "options");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_STOP_FAIL,                           "Couldn't stop gfproxyd for "                           "volume: %s",                           volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_CREATE_FAIL,                   "Couldn't create "                   "gfroxyd volfile for volume: %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_START_FAIL,                   "Couldn't stop "                   "gfproxyd for volume: %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_START_FAIL,                   "Couldn't start "                   "gfproxyd for volume: %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_STOP_FAIL,                   "Couldn't stop gfproxyd for volume: %s", volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,                   "Couldn't create "                   "gfproxyd volfile for volume: %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_START_FAIL,                       "Couldn't resolve gfproxyd for "                       "vol: %s on restart",                       volinfo->volname);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_FAILED_INIT_NFSSVC,                   "Failed to init nfs service");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_SVC_KILL_FAIL,                       "Unable to kill %s "                       "service, reason:%s",                       proc->name, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_PID_KILL_FAIL,                   "Unable to kill pid:%d, "                   "reason:%s",                   pid, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name, "               "while handling quota command");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get type of cmd, "               "while handling quota command");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_QUOTA_GET_STAT_FAIL,               "failed to get the quota status");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_OP_FAILED,               "failed to generate client volume file");
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_GLUSTERD_OP_FAILED,               "failed to create dir %s: %s", DEFAULT_QUOTA_CRAWL_LOG_DIRECTORY,               strerror(errno));
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_GLUSTERD_OP_FAILED,               "failed to create dir %s: %s", pid_dir, strerror(errno));
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set default "               "soft-limit into dict");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "dict set failed");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "dict set failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "dict set failed");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "setting quota-deem-statfs"               "in volinfo failed");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "dict set failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "dict set failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_QUOTA_CONF_CORRUPT,                   "quota.conf "                   "corrupted");
gf_msg(this->name, GF_LOG_ERROR, errno,                   GD_MSG_QUOTA_CONF_WRITE_FAIL,                   "write into quota.conf failed.");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                   "Failed to rename "                   "quota conf file");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CKSUM_COMPUTE_FAIL,                   "Failed to "                   "compute cksum for quota conf file");
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_QUOTA_CKSUM_VER_STORE_FAIL,                   "Failed to "                   "store quota version and cksum");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_QUOTA_CONF_CORRUPT,                   "quota.conf "                   "corrupted");
gf_msg(this->name, GF_LOG_ERROR, errno,                   GD_MSG_QUOTA_CONF_WRITE_FAIL,                   "write into quota.conf failed.");
gf_msg(this->name, GF_LOG_ERROR, errno,                           GD_MSG_QUOTA_CONF_WRITE_FAIL,                           "write into quota.conf failed. ");
gf_msg(this->name, GF_LOG_ERROR, errno,                           GD_MSG_QUOTA_CONF_WRITE_FAIL,                           "write into quota.conf failed. ");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CKSUM_COMPUTE_FAIL,                       "Failed to "                       "compute cksum for quota conf file");
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_VERS_CKSUM_STORE_FAIL,                       "Failed to "                       "store quota version and cksum");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch path");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch hard limit");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to fetch "                   "soft limit");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get gfid of path "               "%s",               path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch path");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get gfid of path "               "%s",               path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Option value absent.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to set option %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Unable to re-create "               "volfiles");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_SET_FAIL,                       "Failed to store volinfo for volume %s",                       volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get path");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESOLVE_BRICK_FAIL,                   FMTSTR_RESOLVE_BRICK, brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to place "                   "gfid of %s in dict",                   backend_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set count");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_UNKNOWN_KEY,               "Unknown option: %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Value not found for key %s", key);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_MOUNT_REQ_FAIL,               "Failed to create auxiliary "               "mount directory %s",               mountdir);
gf_msg(this->name, GF_LOG_ERROR, -ret, GD_MSG_MOUNT_REQ_FAIL,               "Failed to mount glusterfs "               "client. Please check the log file %s for more details",               logfile);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get hard-limit from dict");
gf_msg(this->name, GF_LOG_ERROR, errno,                           GD_MSG_CONVERSION_FAILED,                           "Failed to convert hard-limit "                           "string to value");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_STAGE_QUOTA_FAIL, "%s",               *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Failed to open dir %s", hooks_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_ADD_OP_ARGS_FAIL,                   "Failed to add "                   "command specific arguments");
gf_msg("glusterd", GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "cannot parse mount patterns %s", pdesc);
gf_msg(this->name, GF_LOG_ERROR, EPERM,                   GD_MSG_MNTBROKER_SPEC_MISMATCH,                   "Mountbroker spec mismatch!!! SET: %d "                   "COMPONENT: %d. Review the mount args passed",                   mspec->patterns[i].condition, i);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "'option mountbroker-root' "               "missing in glusterd vol file");
gf_msg(this->name, GF_LOG_ERROR, *op_errno, GD_MSG_MNTBROKER_LABEL_NULL,               "label is NULL (%s)", strerror(*op_errno));
gf_msg(this->name, GF_LOG_ERROR, *op_errno,                   GD_MSG_MNTBROKER_LABEL_MISS,                   "Missing mspec: Check the corresponding option "                   "in glusterd vol file for mountbroker user: %s",                   label);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_DICT_GET_FAILED,               "Dict get failed for the key 'volname'");
gf_msg(this->name, GF_LOG_ERROR, *op_errno, GD_MSG_MOUNT_REQ_FAIL,               "Either volume is not started or volinfo not found");
gf_msg(this->name, GF_LOG_ERROR, *op_errno, GD_MSG_SYSCALL_FAIL,               "Mountbroker User directory creation failed");
gf_msg(this->name, GF_LOG_ERROR, *op_errno, GD_MSG_SYSCALL_FAIL,               "stat on mountbroker user directory failed");
gf_msg(this->name, GF_LOG_ERROR, *op_errno, GD_MSG_MOUNT_REQ_FAIL,               "Incorrect mountbroker user directory attributes");
gf_msg(this->name, GF_LOG_ERROR, *op_errno, GD_MSG_SYSCALL_FAIL,               "Mountbroker mount directory creation failed");
gf_msg(this->name, GF_LOG_ERROR, *op_errno, GD_MSG_SYSCALL_FAIL,               "Mountbroker cookie file creation failed");
gf_msg(this->name, GF_LOG_ERROR, *op_errno, GD_MSG_SYSCALL_FAIL,               "symlink or rename failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_GET_FAIL,               "Failed to get the service");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "failed to set count in dictionary");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_OP_UNSUPPORTED,                   "invalid operation");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_NOT_FOUND,               "Could not find peerd %s(%s)", rsp.hostname,               uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_STALE_PEERINFO_REMOVE_FAIL,                   "Could not remove "                   "stale peerinfo with name %s",                   rsp.hostname);
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_HOSTNAME_ADD_TO_PEERLIST_FAIL,                   "Couldn't add hostname to peer list");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_NEW_FRIEND_SM_EVENT_GET_FAIL,               "Unable to get event");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_RES_DECODE_FAIL,               "error");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_RESP_FROM_UNKNOWN_PEER,               "received friend add response from"               " unknown peer uuid: %s",               uuid_utoa(rsp.uuid));
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_NEW_GET_FAIL,               "Unable to get event");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_EVENT_NEW_GET_FAIL,               "Unable to get glusterd probe context");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_RES_DECODE_FAIL,               "error");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_NEW_GET_FAIL,               "Unable to get event");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RES_DECODE_FAIL,               "Failed to serialize friend"               " update response");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_LOCK_RESP_FROM_PEER,               "Lock response is not "               "received from one of the peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RES_DECODE_FAIL,               "Failed to decode "               "cluster lock response received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_LOCK_FROM_UUID_REJCT,               "Received lock RJT from uuid: %s", uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_LOCK_RESP_FROM_PEER,               "Lock response is not "               "received from one of the peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RES_DECODE_FAIL,               "Failed to decode "               "mgmt_v3 lock response received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCK_FROM_UUID_REJCT,               "Received mgmt_v3 lock RJT from uuid: %s", uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CLUSTER_UNLOCK_FAILED,               "UnLock response is not received from one of the peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CLUSTER_UNLOCK_FAILED,               "Failed to decode mgmt_v3 unlock response received from"               "peer");
gf_msg(            this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FROM_UUID_REJCT,            "Received mgmt_v3 unlock RJT from uuid: %s", uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CLUSTER_UNLOCK_FAILED,               "UnLock response is not received from one of the peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CLUSTER_UNLOCK_FAILED,               "Failed to decode unlock response received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNLOCK_FROM_UUID_REJCT,               "Received unlock RJT from uuid: %s", uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RES_DECODE_FAIL,               "Failed to decode stage "               "response received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize rsp-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STAGE_FROM_UUID_REJCT,               "Received stage RJT from uuid: %s", uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RES_DECODE_FAIL,               "Failed to decode commit "               "response received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize rsp-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_FROM_UUID_REJCT,               "Received commit RJT from uuid: %s", uuid_utoa(rsp.uuid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_GET_FAIL,               "Failed to get txn_op_info "               "for txn_id = %s",               uuid_utoa(*txn_id));
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_NOT_FOUND,               "Could not find peer %s(%s)", event->peername,               uuid_utoa(event->peerid));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Unable to add hostname of the peer");
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_MISSED_SNAP_LIST_STORE_FAIL,                   "Unable to add list of missed snapshots "                   "in the peer_data dict for handshake");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_LIST_SET_FAIL,                   "Unable to add list of snapshots "                   "in the peer_data dict for handshake");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to add list of volumes "               "in the peer_data dict for handshake");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_NOT_FOUND,               "Could not find peer %s(%s)", event->peername,               uuid_utoa(event->peerid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_ID_GET_FAIL,               "Failed to get transaction id.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_ID_GET_FAIL,               "Failed to get transaction id.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_ID_GET_FAIL,               "Failed to get transaction id.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_ID_GET_FAIL,               "Failed to get transaction id.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RES_DECODE_FAIL,               "Failed to decode brick op "               "response received");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "Failed to "                   "unserialize rsp-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Error setting index on brick status rsp dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_SELECT_FAIL,               "Failed to select bricks "               "while performing brick op during 'Volume %s'",               gd_op_list[opinfo.op]);
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_BRICK_OP_PAYLOAD_BUILD_FAIL,                   "Failed to "                   "build op payload during "                   "'Volume %s'",                   gd_op_list[req_ctx->op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RPC_FAILURE,                   "Brick Op failed "                   "due to rpc failure.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create logdir %s", logdir);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_INIT_FAIL,                   "Failed to initialize "                   "snapd service for volume %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Failed to read volume "               "options");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_STOP_FAIL,                           "Couldn't stop snapd for "                           "volume: %s",                           volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_CREATE_FAIL,                   "Couldn't create "                   "snapd volfile for volume: %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_START_FAIL,                   "Couldn't start "                   "snapd for volume: %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_STOP_FAIL,                   "Couldn't stop snapd for volume: %s", volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_OBJ_GET_FAIL,               "Failed to get snapd object "               "from snapd service");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Failed to get volinfo from "               "from snapd");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,                   "Couldn't create "                   "snapd volfile for volume: %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PORTS_EXHAUSTED,               "All the ports in the range are exhausted, can't start "               "snapd for volume %s",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_START_FAIL,                       "Couldn't resolve snapd for "                       "vol: %s on restart",                       volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_GET_FAIL,               "Failed to get the service");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_OBJ_GET_FAIL,               "Failed to get the "               "snapd object");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Failed to get the "               "volinfo object");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Failed to create volfile");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BITD_INIT_FAIL,                   "Failed to init "                   "bitd service");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to"                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARY_VOL_PARSE_FAIL,               "Error in copying secondary: %s!", value->data);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARY_VOL_PARSE_FAIL,               "Error in parsing secondary: %s!", value->data);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SPAWNING_CHILD_FAILED,               "spawning child failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_READ_CHILD_DATA_FAILED,               "reading data from child failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SPAWNING_CHILD_FAILED,               "spawning child failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_READ_CHILD_DATA_FAILED,               "reading data from child failed");
gf_msg(this->name, GF_LOG_ERROR, ENOENT, GD_MSG_FILE_OP_FAILED,                   "Template config file (%s) missing.", temp_conf_path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Unable to allocate memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SPAWNING_CHILD_FAILED,               "spawning child failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GSYNCD_SPAWN_FAILED,                   "Unable to spawn "                   "gsyncd");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                       "%s", errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARY_VOL_PARSE_FAIL,               "Error in copying secondary: %s!", value->data);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARY_VOL_PARSE_FAIL,               "Error in parsing secondary: %s!", value->data);
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_SECONDARYINFO_FETCH_ERROR,                   "Unable to fetch secondary details. Error: %s", errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_SECONDARYINFO_FETCH_ERROR,                   "Unable to fetch secondary details.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_SECONDARY,               "Invalid secondary in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARY_VOL_PARSE_FAIL,                   "secondary_info becomes NULL!");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARY_VOL_PARSE_FAIL,                   "Error in copying secondary: %s!", value->data);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARY_VOL_PARSE_FAIL,                   "Error in parsing secondary: %s!", value->data);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_SECONDARYINFO_FETCH_ERROR,                       "Unable to fetch secondary details. Error: %s", errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_SECONDARYINFO_FETCH_ERROR,                       "Unable to fetch secondary details.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REMOTE_VOL_UUID_FAIL,                   "Unable to get remote volume uuid"                   "secondaryhost:%s secondaryvol:%s",                   secondary_host, secondary_vol);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REMOTE_VOL_UUID_FAIL,                   "Error in setting dict value"                   "new_value :%s",                   new_value);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REMOTE_VOL_UUID_FAIL,               "Error in updating"               "volinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_STORE_FAIL,                   "Error in storing"                   "volinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVOKE_ERROR,                   GEOREP                   " has already been invoked for "                   "the %s (primary) and %s (secondary) from a different "                   "machine",                   volinfo->volname, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REMOTE_VOL_UUID_FAIL,               "_get_secondary_idx_secondary_voluuid failed!");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED, "%s",               msg);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "%s statefile: %s", msg, statefile);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SESSION_CREATE_ERROR, "%s",               msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GSYNCD_SPAWN_FAILED, "%s",               msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Not able to create dict.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GET_CONFIG_INFO_FAILED,               "Unable to get configuration data "               "for %s(primary), %s(secondary)",               primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get state_file's name "               "for %s(primary), %s(secondary). Please check gsync "               "config file.",               primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STAT_FILE_READ_FAILED,               "Unable to read the status file for %s(primary), "               "%s(secondary)",               primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_PRIV_NOT_FOUND,               "priv of glusterd not present");
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_SECONDARYINFO_FETCH_ERROR,                   "Unable to fetch"                   " secondary details. Error: %s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_SECONDARYINFO_FETCH_ERROR,                   "Unable to fetch secondary details.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CONF_PATH_ASSIGN_FAILED,               "Unable to assign conf_path.");
gf_msg(THIS->name, GF_LOG_ERROR, 0,                   GD_MSG_SECONDARYINFO_FETCH_ERROR,                   "_get_secondary_satus failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VALIDATE_FAILED,               GEOREP " stop validation failed for %s & %s", volinfo->volname,               secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PIDFILE_NOT_FOUND, "%s",               msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_PRIV_NOT_FOUND,               "priv of glusterd not present");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARYINFO_FETCH_ERROR,               "Unable to fetch secondary or confpath details.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNSUPPORTED_VERSION,               "Op Version not supported.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get command from dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_CMD_ERROR, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_PRIV_NOT_FOUND,               "priv of glusterd not present");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNSUPPORTED_VERSION,               "Op Version not supported.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch host-uuid from dict.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to fetch filename from dict.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Unable to create new dict");
gf_msg(this->name, GF_LOG_ERROR, ENOENT, GD_MSG_FILE_OP_FAILED,                   "Template "                   "config file (%s) missing.",                   temp_conf_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GET_CONFIG_INFO_FAILED,                   "Unable to get configuration data "                   "for %s(primary), %s(secondary). "                   "Trying template config.",                   primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GET_CONFIG_INFO_FAILED,                   "Unable to get configuration data "                   "for %s(primary), %s(secondary) from "                   "template config",                   primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to get state_file's name. "                   "Trying template config.");
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_GET_STATEFILE_NAME_FAILED,                   "Unable to get state_file's "                   "name from template.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_PRIV_NOT_FOUND,               "priv of glusterd not present");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STATUSFILE_CREATE_FAILED,               "Creating status file failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARY_URL_INVALID,               "Invalid secondary url.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_SECONDARY,               "Not a valid secondary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_READ_ERROR,                   "Unable to read from %s", log_file_path);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARY_VOL_PARSE_FAIL,               "secondary_info format is wrong!");
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_SECONDARY_VOL_PARSE_FAIL,                       "Invalid secondary_host format!");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_SECONDARY_VOL_PARSE_FAIL,                           "Invalid secondary user length in %s",                           secondary_host);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_SECONDARY_VOL_PARSE_FAIL,                       "Invalid secondary_host!");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_ARG_FETCH_ERROR,               "Unable to fetch arguments");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNSUPPORTED_VERSION,               "Op Version not supported.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARYINFO_FETCH_ERROR,               "Unable to fetch secondary or confpath details.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_DISCONNECTED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_INVALID_SECONDARY,                           "%s is not a valid secondary "                           "volume. Error: %s",                           secondary, *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, ENOENT, GD_MSG_FILE_OP_FAILED,                       "%s", errmsg);
gf_msg(this->name, GF_LOG_ERROR, ENOENT, GD_MSG_FILE_OP_FAILED,                       "%s", errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REG_FILE_MISSING,                       "%s", errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STATEFILE_NAME_NOT_FOUND,               "%s", errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to store statefile path");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SESSION_ALREADY_EXIST, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REMOTE_VOL_UUID_FAIL, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set secondary volume uuid in the dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FORCE_CREATE_SESSION,                   "Session between"                   " %s and %s:%s is already created! "                   "Cannot create with new secondary:%s again!",                   volinfo->volname, secondary1.old_sechost, secondary_vol,                   secondary_host);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                       "Unable to allocate memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to set old_secondaryhost in the dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to set existing_session in the dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GSYNCD_SPAWN_FAILED, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARYINFO_FETCH_ERROR,               "Unable to fetch secondary or confpath details.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARY_URL_INVALID,                   "state_file entry missing in config file (%s)", conf_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to store statefile path");
gf_msg(this->name, GF_LOG_ERROR, ENOENT, GD_MSG_FILE_OP_FAILED,                   "%s. statefile = %s", errmsg, statefile);
gf_msg("glusterd", GF_LOG_ERROR, errno,                           GD_MSG_GEO_REP_START_FAILED,                           "Unable "                           "to open /dev/fuse (%s), "                           "geo-replication start failed",                           strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PIDFILE_NOT_FOUND, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GSYNCD_ERROR,               "gsyncd b/w %s & %s is not running", primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Pause/Resume Failed: Unable to fetch statefile path");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STAT_FILE_READ_FAILED,               "Pause/Resume Failed: "               "Unable to read status file for %s(primary)"               " %s(primary)",               primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_PID_KILL_FAIL,                       "Failed"                       " to pause gsyncd. Error: %s",                       strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_UPDATE_STATEFILE_FAILED,                       "Unable  to update state_file."                       " Error : %s",                       strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno,                           GD_MSG_PID_KILL_FAIL,                           "Resume back Failed. Error:"                           "%s",                           strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_UPDATE_STATEFILE_FAILED,                       "Resume Failed: Unable to update "                       "state_file. Error : %s",                       strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_PID_KILL_FAIL,                       "Resumed Failed: Unable to send"                       " SIGCONT. Error: %s",                       strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_STATUS_UPDATE_FAILED,                           "Updating status back to paused"                           " Failed. Error: %s",                           strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PIDFILE_NOT_FOUND, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GSYNCD_ERROR,               "gsyncd b/w %s & %s is not running", primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Not able to create dict.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GET_CONFIG_INFO_FAILED,               "Unable to get configuration data for %s(primary), "               "%s(secondary)",               primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get op_value for %s(primary), %s(secondary). "               "Please check gsync config file.",               primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_PRIV_NOT_FOUND,               "priv of glusterd not present");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch conf file path.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Unable to fetch secondary host.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Unable to fetch secondary volume name.");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                       "Unable to "                       "create %s. Error : %s",                       op_value, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FILE_OP_FAILED,               "Unable to read gsyncd status file %s", path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GSYNCD_ERROR,               "Status file of gsyncd is empty");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GSYNCD_ERROR,               "Status file of gsyncd is corrupt");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GET_CONFIG_INFO_FAILED,               "Unable to get configuration data for %s(primary), "               "%s(secondary)",               primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to get state_file's name "                   "for %s(primary), %s(secondary). "                   "Please check gsync config file.",                   primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to get geo-rep session's "                   "working directory name for %s(primary), "                   "%s(secondary). Please check gsync config file.",                   primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to get socket file's name "                   "for %s(primary), %s(secondary). "                   "Please check gsync config file.",                   primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Not able to create dict.");
gf_msg(this->name, GF_LOG_ERROR, ENOENT, GD_MSG_FILE_OP_FAILED,                   "Template "                   "config file (%s) missing.",                   temp_conf_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FETCH_CONFIG_VAL_FAILED,                   "Unable to fetch config values "                   "for %s(primary), %s(secondary). "                   "Trying default config template",                   primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FETCH_CONFIG_VAL_FAILED,                   "Unable to "                   "fetch config values for %s(primary), "                   "%s(secondary)",                   primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STAT_FILE_READ_FAILED,               "Unable to read the status file for %s(primary), "               "%s(secondary) statefile: %s",               primary, secondary, statefile);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "Out Of Memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GET_STATUS_DATA_FAIL,                   "Unable to get status data "                   "for %s(primary), %s(secondary), %s(brick)",                   primary, secondary, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Unable to set"                       " key:%s value:running in dict. But "                       "the config succeeded.",                       key);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Unable to create volfile for setting of marker "               "while '" GEOREP " start'");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GET_KEY_FAILED,               "failed to get key %s from volinfo", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch conf file path.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_PRIV_NOT_FOUND,               "priv of glusterd not present");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch conf file path.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SESSION_DEL_FAILED,               "gsyncd failed to delete session info for %s and "               "%s peers",               primary, secondary);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,                   "Unable to delete Geo Rep Dir(%s). Error: %s", geo_rep_dir,                   strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_PRIV_NOT_FOUND,               "priv of glusterd not present");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get command from dict");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "Unable to calloc. Errno = %s", strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Unable to get"                       " %s in dict",                       cmd_arg_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STRDUP_FAILED,                       "gf_strdup failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "output set "                       "failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "output_count "                       "set failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_PRIV_NOT_FOUND,               "priv of glusterd not present");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch filename from dict.");
gf_msg(this->name, GF_LOG_ERROR, ENOENT, GD_MSG_FILE_OP_FAILED,                   "%s", errmsg);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FILE_OP_FAILED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_READ_ERROR, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FILE_OP_FAILED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FILE_OP_FAILED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch secondary url.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch secondary hostname.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch secondary volume name.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch conf file path.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Unable to store conf_file_path.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to set key:%s"                   " value:running in the dict",                   key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REMOTE_VOL_UUID_FAIL,                   "Error in updating"                   " secondary volume uuid for old secondary info");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PAUSE_FAILED,                       GEOREP " Pause Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Unable to set "                       "key:%s value:running in dict",                       key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESUME_FAILED,                       GEOREP " Resume Failed");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_UPDATE_STATEFILE_FAILED,                           "Unable to update state_file. "                           "Error : %s",                           strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch secondary from dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARYINFO_FETCH_ERROR,               "Unable to fetch secondary details.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to store secondary IP.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to store secondary hostname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to store secondary volume name.");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_STRDUP_FAILED,               "Unable to gf_strdup. Error: %s", strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to store conf_path");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NORMALIZE_URL_FAIL,               "Failed to normalize url");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARY_URL_INVALID,                   "Invalid secondary url: %s", *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STRDUP_FAILED,                   "Failed to gf_strdup");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "Invalid secondary name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STRDUP_FAILED,                   "Failed to gf_strdup");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "Invalid secondary name");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_MODULE_ERROR,                   GEOREP " module not working as desired");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_MODULE_ERROR,                   GEOREP " module not working as desired");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_MODULE_ERROR,               GEOREP " module not working as desired");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Volinfo for %s (primary) not found", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARY_URL_INVALID,               "Invalid secondary url.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STRDUP_FAILED,               "Failed to gf_strdup");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set hooks_args in dict.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",               errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",                   errmsg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARYINFO_STORE_ERROR,               "%s", errmsg);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "failed to set peerinfo");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_AC_ERROR, "Received event %d ",           event->event);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_PEER_NOT_FOUND,               "Could not find peer %s(%s)", event->peername,               uuid_utoa(event->peerid));
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_NEW_GET_FAIL,               "Unable to get new new_event");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_INJECT_FAIL,               "Unable to inject new_event %d, "               "ret = %d",               new_event->event, ret);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_NOT_FOUND,               "Could not find peer %s(%s)", event->peername,               uuid_utoa(event->peerid));
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "failed to set peerinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_NOT_FOUND,               "Could not find peer %s(%s)", event->peername,               uuid_utoa(event->peerid));
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_NEW_GET_FAIL,                   "Unable to get event");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_NOT_FOUND,               "Could not find peer %s(%s)", event->peername,               uuid_utoa(event->peerid));
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "failed to set peerinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_NOT_FOUND,               "Could not find peer %s(%s)", event->peername,               uuid_utoa(event->peerid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set peerinfo");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_SVC_STOP_FAIL,                           "Failed "                           "to stop snapd daemon service");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_SVC_STOP_FAIL,                           "Failed "                           "to stop shd daemon service");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_SVC_STOP_FAIL,                           "Failed "                           "to stop gfproxyd daemon service");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_VOL_DELETE_FAIL,                       "Error deleting snapshots for volume %s",                       volinfo->volname);
gf_msg(THIS->name, GF_LOG_ERROR, 0,                       GD_MSG_STALE_VOL_REMOVE_FAIL,                       "Error deleting stale volume");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_SVC_STOP_FAIL,               "Failed to reconfigure all daemon services.");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_PEER_NOT_FOUND,               "Could not find peer %s(%s)", event->peername,               uuid_utoa(event->peerid));
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_PEER_DETACH_CLEANUP_FAIL,               "Cleanup returned: %d", ret);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_NOT_FOUND,               "Could not find peer %s(%s)", event->peername,               uuid_utoa(event->peerid));
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_MISSED_SNAP_LIST_STORE_FAIL,                       "Failed to import peer's "                       "missed_snaps_list.");
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_SNAP_COMPARE_CONFLICT,                       "Conflict in comparing peer's snapshots");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Out of Memory");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_HANDLER_RETURNED,                       "handler returned: "                       "%d",                       ret);
gf_msg("glusterd", GF_LOG_ERROR, 0,                       GD_MSG_EVENT_STATE_TRANSITION_FAIL,                       "Unable to transition"                       " state from '%s' to '%s' for event '%s'",                       glusterd_friend_sm_state_name_get(old_state),                       glusterd_friend_sm_state_name_get(                           state[event_type].next_state),                       glusterd_friend_sm_event_name_get(event_type));
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_PEER_NOT_FOUND,                       "Cannot find peer %s(%s)", event->peername,                       uuid_utoa(event->peerid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEERINFO_CREATE_FAIL,                       "Failed to store peerinfo");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "key or uuid is null.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to get %s locked_count = %d", name_buf,                   locked_count);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,                   "Failed to release lock for %s.", name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to get %s count = %d", name_buf, count);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCK_GET_FAIL,                   "Failed to acquire lock for %s %s "                   "on behalf of %s. Reversing "                   "this transaction",                   type, name, uuid_utoa(uuid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MULTIPLE_LOCK_RELEASE_FAIL,               "Failed to release multiple %s locks", type);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to fetch %sname", type);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,                   "Failed to release lock for %s %s "                   "on behalf of %s.",                   type, name, uuid_utoa(uuid));
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_MULTIPLE_LOCK_RELEASE_FAIL,                   "Failed to release all %s locks", type);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to fetch %sname", type);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCK_GET_FAIL,                   "Failed to acquire lock for %s %s "                   "on behalf of %s.",                   type, name, uuid_utoa(uuid));
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_MULTIPLE_LOCK_ACQUIRE_FAIL,                   "Failed to acquire all %s locks", type);
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_MULTIPLE_LOCK_RELEASE_FAIL, "Unable to unlock all %s",                   valid_types[i].type);
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_MULTIPLE_LOCK_ACQUIRE_FAIL, "Unable to lock all %s",                   valid_types[i].type);
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_MULTIPLE_LOCK_RELEASE_FAIL, "Unable to unlock all %s",                   valid_types[i].type);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "name or type is null.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CREATE_KEY_FAIL,               "Unable to create key");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set lock owner in mgmt_v3 lock");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set timer in mgmt_v3 lock");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CREATE_KEY_FAIL,               "Unable to create backtrace "               "key");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to get lock owner in mgmt_v3 lock");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "name is null.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CREATE_KEY_FAIL,               "Unable to create key");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to get mgmt lock key in mgmt_v3 lock");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CREATE_KEY_FAIL,               "Unable to create backtrace "               "key");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_CREATE_DIR_FAILED,               "Failed to create "               "directory %s",               defrag_path);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_UNIX_OP_BUILD_FAIL,               "Unix options build failed");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_RPC_CREATE_FAIL,               "Glusterd RPC creation failed");
gf_msg("glusterd", GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,               "Received rebalance on invalid"               " volname %s",               volname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_DISTRIBUTE,               "Volume %s is not a "               "distribute type or contains only 1 brick",               volname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_STOPPED,               "Received rebalance on stopped"               " volname %s",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(THIS->name, GF_LOG_ERROR, EINVAL, GD_MSG_BRICK_NOT_FOUND,               "Incorrect brick %s for "               "volume %s",               value->data, volinfo->volname);
gf_msg(THIS->name, GF_LOG_ERROR, EINVAL, GD_MSG_BRICK_NOT_FOUND,               "Incorrect brick %s for "               "volume %s",               value->data, volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set task-id for volume %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TASKID_GEN_FAIL,                           "Failed to generate task-id");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get "                       "command string");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OPCTX_GET_FAIL,                           "Failed to get op_ctx");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TASKID_GEN_FAIL,                           "Failed to generate task-id");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get "                       "command string");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OPCTX_GET_FAIL,                       "Failed to get op_ctx");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TASKID_GEN_FAIL,                       "Failed to set task-id");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get volname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_REBALANCE_PFX_IN_VOLNAME,               "volname received (%s) is not prefixed with rebalance.",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Failed to get volinfo for %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DEFRAG_STATUS_UPDATE_FAIL,               "Failed to update status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCK_GET_FAIL,               "Failed to acquire mgmt_v3 locks for %s", uuid_utoa(ctx->uuid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OPINFO_SET_FAIL,               "Unable to set transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_EVENT_LOCK_FAIL,               "Failed to inject event GD_OP_EVENT_LOCK");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode lock "               "request received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCK_GET_FAIL,                   "Failed to acquire mgmt_v3_locks");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCK_GET_FAIL,                   "Failed to acquire mgmt_v3_locks");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode pre validation "               "request received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALIDATION_FAIL,               "Pre Validation failed on operation %s", gd_op_list[op_req.op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_OP_RESP_FAIL,               "Failed to send Pre Validation "               "response for operation %s",               gd_op_list[op_req.op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode brick op "               "request received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_OP_FAIL,               "Brick Op failed on operation %s", gd_op_list[op_req.op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALD_RESP_FAIL,               "Failed to send brick op "               "response for operation %s",               gd_op_list[op_req.op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode commit "               "request received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,               "commit failed on operation %s", gd_op_list[op_req.op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_OP_RESP_FAIL,               "Failed to send commit "               "response for operation %s",               gd_op_list[op_req.op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode post commit "               "request received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_POST_COMMIT_OP_FAIL,               "post commit failed on operation %s", gd_op_list[op_req.op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_OP_RESP_FAIL,               "Failed to send post commit "               "response for operation %s",               gd_op_list[op_req.op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode post validation "               "request received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_POST_VALIDATION_FAIL,               "Post Validation failed on operation %s", gd_op_list[op_req.op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_OP_RESP_FAIL,               "Failed to send Post Validation "               "response for operation %s",               gd_op_list[op_req.op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,               "Failed to release mgmt_v3 locks for %s", uuid_utoa(ctx->uuid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_EVENT_UNLOCK_FAIL,               "Failed to inject event GD_OP_EVENT_UNLOCK");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode unlock "               "request received from peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,                   "Failed to release mgmt_v3_locks");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,                   "Failed to release mgmt_v3_locks");
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "couldn't open the file %s", GANESHA_HA_CONF);
gf_msg(THIS->name, GF_LOG_ERROR, errno,                   GD_MSG_GET_CONFIG_INFO_FAILED, "Parsing %s failed at key %s",                   GANESHA_HA_CONF, key);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_UNRECOGNIZED_SVC_MNGR,           "Could not %s NFS-Ganesha.Service manager for distro"           " not recognized.",           action);
gf_msg("glusterd-ganesha", GF_LOG_ERROR, errno,                       GD_MSG_DICT_GET_FAILED, "Unable to get volume name");
gf_msg("glusterd-ganesha", GF_LOG_ERROR, 0,               GD_MSG_NFS_GNS_OP_HANDLE_FAIL,               "Handling NFS-Ganesha"               " op failed.");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "value not present.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NFS_GNS_START_FAIL,                   "Could not start NFS-Ganesha");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Couldn't get key in global option set");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Couldn't get value in global option set");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NFS_GNS_SETUP_FAIL,               "Initial NFS-Ganesha set up failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_FAIL,               "Failed to store options");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "invalid value.");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,               FMTSTR_CHECK_VOL_EXISTS, volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_EXPORT_FILE_CREATE_FAIL,                   "Failed to create"                   "export file for NFS-Ganesha\n");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name, "               "while handling bitrot command");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get type of cmd, "               "while handling bitrot command");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get scrub value.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get scrub value.");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to fetch scrub-"               "throttle value");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Failed to set option %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SCRUBSVC_RECONF_FAIL,               "Failed to reconfigure scrub "               "services");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to fetch scrub-"               "freq value");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Failed to set option %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SCRUBSVC_RECONF_FAIL,               "Failed to reconfigure scrub "               "services");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch scrub"               "value");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Failed to set option %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SCRUBSVC_RECONF_FAIL,               "Failed to reconfigure scrub "               "services");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get bitrot expiry"               " timer value.");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Failed to set option %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BITDSVC_RECONF_FAIL,               "Failed to reconfigure bitrot"               "services");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get bitrot signer thread count.");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Failed to set option %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BITDSVC_RECONF_FAIL,                   "Failed to reconfigure bitrot services");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "dict set failed");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Failed to set option "               "features.scrub value");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "dict set failed");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Failed to set "               "features.scrub value");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get type from "               "dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Unable to re-create "               "volfiles");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get type for "               "operation");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,                       "Unable to "                       "get scrub-value");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_STAGE_BITROT_FAIL, "%s",               *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_CREATE_DIR_FAILED,                   "Unable to create logdir %s", logdir);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Failed to create volfile");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_SHD_OBJ_GET_FAIL,                       "Failed to get shd object "                       "from shd service");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                       "Failed to get volinfo from "                       "from shd");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_FAILED_INIT_SHDSVC,               "Failed to init shd service");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_SHD_OBJ_GET_FAIL,               "Failed to get shd object "               "from shd service");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Failed to get volinfo from "               "from shd");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                   "Failed to attach shd svc(volume=%s) to pid=%d",                   volinfo->volname, glusterd_proc_get_pid(&svc->proc));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SHD_START_FAIL,                       "Couldn't start shd for "                       "vol: %s on restart",                       volinfo->volname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_SHD_OBJ_GET_FAIL,               "Failed to get shd object "               "from shd service");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Failed to get volinfo from "               "from shd");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_STOP_FAIL,                   "shd service is failed to detach volume %s from pid %d",                   volinfo->volname, glusterd_proc_get_pid(&svc->proc));
\        gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Out of memory, cannot link xlators %s <- %s", pxl->name,               cxl->name);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_GRAPH_ENTRY_ADD_FAIL,               "failed to add graph entry %s", xl->name);
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_NO_MEMORY,               "failed to set xlator opt: %s[%s] = %s", xl->name, key, value);
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Out of memory");
gf_msg("glusterd", GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "value for %s option is not valid", key);
gf_msg(THIS->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                       "Out of memory");
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_ERROR_ENCOUNTERED,               "Some error occurred during keyword hinting");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,                       "%s is not"                       " a global option",                       vme->key);
gf_msg(THIS->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                   "Unknown "                   "transport type");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_FILTER_RUN_FAILED,                   "failed to run filter %s", entry->d_name);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "file creation failed");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "fclose on the file %s "               "failed",               ftmp);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,           "failed to create volfile %s", filename);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DEFAULT_OPT_INFO,               "Failed to get auth-path from server graph");
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "read-only and worm cannot be set together");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_INCOMPATIBLE_VALUE,               "read-only and worm cannot be set together");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_BUILD_GRAPH_FAILED,                   "Builing graph "                   "failed for server graph table entry: %d",                   i);
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,                   "could not get both"                   " translator name and loglevel for log level request");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_XML_TEXT_WRITE_FAIL,               "Could not end an "               "xmlElement");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_XML_TEXT_WRITE_FAIL,               "Could not end an "               "xmlDocument");
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Error creating the xml "               "buffer");
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               " Error creating the xml "               "writer");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_XML_DOC_START_FAIL,               "Error While starting the "               "xmlDoc");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_XML_ELE_CREATE_FAIL,               "Could not create an "               "xmlElement");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_XML_ELE_CREATE_FAIL,               "Could not create an "               "xmlElemetnt");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_XML_ELE_CREATE_FAIL,               "Could not create an "               "xmlElemetnt");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_XML_ELE_CREATE_FAIL,               "Could not create an "               "xmlElemetnt");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_XML_ELE_CREATE_FAIL,               "Could not create an "               "xmlElemetnt");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_XML_ELE_CREATE_FAIL,               "Could not end an "               "xmlElemetnt");
gf_msg("glusterd", GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "Wrong entry found in  "               "glusterd_volopt_map entry %s",               vme->key);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLUME_INCONSISTENCY,               "volume inconsistency: brick count is 0");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLUME_INCONSISTENCY,               "volume inconsistency: "               "total number of bricks (%d) is not divisible with "               "number of bricks per cluster (%d) in a multi-cluster "               "setup",               volinfo->brick_count, volinfo->dist_leaf_count);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLUME_INCONSISTENCY,               "volume inconsistency: actual number of bricks (%d) "               "differs from brick count (%d)",               i, volinfo->brick_count);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_XLATOR_LINK_FAIL,               "failed to link the "               "snapview-client to distribute");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_XLATOR_LINK_FAIL,               "failed to link the "               "snapview-client to snapview-server");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_REMOTE_HOST_GET_FAIL,               "Failed to get remote-host "               "from client %s",               xl->name);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_REMOTE_HOST_GET_FAIL,               "Failed to get remote-host "               "from client %s",               xl->name);
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "nufa and switch cannot be set together");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLUME_INCONSISTENCY,                   "volume inconsistency: "                   "unrecognized clustering type");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GRAPH_FEATURE_ADD_FAIL,                   "Failed to add "                   "read-only feature to the graph of %s "                   "snapshot with %s origin volume",                   volname, volinfo->parent_volname);
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Out of memory");
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "Out of memory");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_NO_MEMORY,                   "Out of memory");
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "Out of memory");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                   "failed to create "                   "%s",                   tstamp_file);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TSTAMP_SET_FAIL,                           "Unable to set atime and mtime"                           " of %s as of %s",                           tstamp_file, parent_tstamp_file);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                   "failed to unlink "                   "%s",                   tstamp_file);
gf_msg(THIS->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                   "Received invalid transport-type.");
gf_msg(THIS->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                   "Received invalid transport-type");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Failed to create rebalance volfile for %s", volinfo->volname);
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,                   "could not get both"                   " translator name and loglevel for log level "                   "request");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Could not generate volfiles for bricks");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Could not generate trusted client volfiles");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Could not generate client volfiles");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "failed to delete file: %s", filename);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_UNSUPPORTED, "%s",                   err_str);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Failed to set volume name");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "Invalid path: %s", volpath);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "Invalid path: %s", volpath);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_NOT_FOUND,               "Failed to "               "fetch snap %s",               snapname);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                       "Invalid "                       "volname (%s)",                       volfile_token);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_INFO_FAIL,                       "Failed to "                       "fetch snap volume from volname (%s)",                       vol);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_INFO_FAIL,                   "Failed to "                   "fetch snap volume from parent "                   "volname (%s)",                   volname_token);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                   "Couldn't find volinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                   "Couldn't find volinfo for volid=%s", volid_ptr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Couldn't set pidfile in dict for volid=%s", volid_ptr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_INFO_FAIL,                   "Failed to get snap"                   " volinfo from path (%s)",                   volume_id);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                   "Couldn't find volinfo");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "strdup failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                   "Couldn't find volinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_MEMORY,                   "failed to get volinfo path");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,               "Failed to unserialize request dictionary");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get client-min-op-version");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get client-max-op-version");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_NOT_FOUND,               "Unable to find the snap with snap_uuid %s",               missed_snapinfo->snap_uuid);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Unable to find the snap_vol(%s) "               "for snap(%s)",               snap_opinfo->snap_vol_id, snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_STATUS_NOT_PENDING,               "The snap status of the missed "               "brick(%s) is not pending",               brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_GET_INFO_FAIL,               "Getting device name for the"               "brick %s:%s failed",               brickinfo->hostname, snap_opinfo->brick_path);
gf_msg(this->name, GF_LOG_ERROR, ENXIO,               GD_MSG_SNAP_DEVICE_NAME_GET_FAIL,               "cannot copy the snapshot "               "device name (volname: %s, snapname: %s)",               snap_vol->volname, snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, ENXIO,               GD_MSG_SNAP_DEVICE_NAME_GET_FAIL,               "cannot copy the device_path "               "(device_path: %s)",               brickinfo->device_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRK_MOUNTOPTS_FAIL,               "Failed to update "               "mount options for %s brick",               brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPSHOT_OP_FAILED,               "Failed to take snapshot of %s", snap_opinfo->brick_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_SET_INFO_FAIL,               "Failed to update "               "file-system label for %s brick",               brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_CREATION_FAIL,               "Failed to "               " create and mount the brick(%s) for the snap %s",               snap_opinfo->brick_path, snap_vol->snapshot->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_STORE_FAIL,               "Failed to store snapshot "               "volinfo (%s) for snap %s",               snap_vol->volname, snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0,                               GD_MSG_MISSED_SNAP_CREATE_FAIL,                               "Failed to create "                               "missed snap for %s",                               brick_name);
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_MISSED_SNAP_LIST_STORE_FAIL,                   "Failed to update missed_snaps_list");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode the message");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_NAME_TOO_LONG,               "volume name too long (%s)", volume);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "peerinfo->volname %s truncated or error occurred: "               "(ret: %d)",               peerinfo->volname, ret);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get args from dict");
gf_msg(this->name, GF_LOG_ERROR, 0,               GD_MSG_RPC_TRANSPORT_GET_PEERNAME_FAIL,               "Failed to get the peername");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "failed to set peer_host in dict");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                   "Unable to stat %s (%s)", filename, strerror(errno));
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                   "Unable to open %s (%s)", filename, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MISSED_SNAP_CREATE_FAIL,                   "Failed to take missing brick snapshots");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MOUNT_REQ_FAIL,               "Failed to mount the volume");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "Failed to unserialize req");
gf_msg("glusterd", GF_LOG_ERROR, EINVAL, GD_MSG_OP_UNSUPPORTED,                   "Unknown op received in event "                   "notify");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_VERSION_MISMATCH,               "operating version %d is more than the maximum "               "supported (%d) on the machine (as per peer request "               "from %s)",               cluster_op_version, GD_OP_VERSION_MAX, peerid);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_VERS_ADJUST_FAIL,               "cannot reduce operating version to %d from current "               "version %d as volumes exist (as per peer request from "               "%s)",               cluster_op_version, conf->op_version, peerid);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HANDSHAKE_REQ_REJECTED,                   "Request from "                   "peer %s has an entry in peerinfo, but uuid "                   "does not match",                   req->trans->peerinfo.identifier);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HANDSHAKE_REQ_REJECTED,               "Rejecting management "               "handshake request from unknown peer %s",               req->trans->peerinfo.identifier);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLOBAL_OP_VERSION_SET_FAIL,               "Failed to store op-version");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode management handshake response");
gf_msg("glusterd", GF_LOG_ERROR, EINVAL,                   GD_MSG_DICT_UNSERIALIZE_FAIL,                   "Failed to unserialize dictionary");
gf_msg("glusterd", GF_LOG_ERROR, EINVAL, GD_MSG_DICT_GET_FAILED,               "Failed to retrieve volname");
gf_msg("glusterd", GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,               "Error getting snapshot volume names and uuids : %s", volname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_NEW_GET_FAIL,               "Unable to get new event");
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Memory not available");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_PEER_NOT_FOUND,               "Could not find peer %s(%s)", peerctx->peername,               uuid_utoa(peerctx->peerid));
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_EVENT_INJECT_FAIL,               "Unable to inject "               "EVENT_CONNECTED ret = %d",               ret);
gf_msg(frame->this->name, GF_LOG_ERROR, 0, GD_MSG_NO_HANDSHAKE_ACK,               "%s", msg);
gf_msg(this->name, GF_LOG_ERROR, op_errno, GD_MSG_VERS_GET_FAIL,               "failed to get the 'versions' from peer (%s)",               req->conn->trans->peerinfo.identifier);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_VERSION_MISMATCH,               "failed to validate the operating version of peer (%s)",               peerinfo->hostname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set operating version in dict");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "failed to set peer ID in dict");
gf_msg(frame->this->name, GF_LOG_ERROR, 0, GD_MSG_VERS_GET_FAIL, "%s",               msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VERSION_UNSUPPORTED, "%s",               msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg("glusterd", GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY, "%s",               msg);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "volname not found");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "rotate key not found");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_BRICK_NOT_FOUND,               "cannot get brickinfo from brick");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                   "Unable to open pidfile: %s", pidfile);
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                   "Unable to read pidfile: %s", pidfile);
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_PID_KILL_FAIL,                   "Unable to SIGHUP to %d", pid);
gf_msg(this->name, GF_LOG_ERROR, EPERM,                       GD_MSG_BRICK_VALIDATE_FAIL, "%s", *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, EPERM,                       GD_MSG_BRICK_VALIDATE_FAIL, "%s", *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, EPERM,                       GD_MSG_BRICK_VALIDATE_FAIL, "%s", *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_VALIDATE_FAIL, "%s",               *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_MOUNTDIR_GET_FAIL,                   "Failed to get brick mount_dir");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set brick.mount_dir");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set local_brick_count.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get src brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to get dst brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RB_BRICKINFO_GET_FAIL,                   "Unable to get "                   "reset brick "                   "destination brickinfo");
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_GLUSTER_SERVICES_STOP_FAIL,                   "Unable to stop gluster services, ret: %d", ret);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RBOP_STATE_STORE_FAIL,                   "Couldn't store"                   " reset brick operation's state.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_LOCK_FAIL,               "Unable to get lock"               " for uuid: %s, lock held by: %s",               uuid_utoa_r(uuid, new_owner_str), uuid_utoa_r(owner, owner_str));
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_LOCK_FAIL,               "Cluster lock not held!");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_LOCK_FAIL,               "Cluster lock held by %s ,"               "unlock req from %s!",               uuid_utoa_r(owner, owner_str), uuid_utoa_r(uuid, new_owner_str));
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_UNLOCK_FAIL,               "Unable to clear cluster "               "lock");
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Failed to get iobuf");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_ENCODE_FAIL,               "Failed to encode message");
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "out of memory");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_SERIALIZE_MSG_FAIL,               "Failed to serialize reply");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_REPLY_SUBMIT_FAIL,               "Reply submission failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_SET_FAIL,               "not able to create the "               "duplicate volinfo for the volume %s",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CANONICALIZE_FAIL,               "Failed to canonicalize "               "brick path");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_ID_GEN_FAILED,                   "Unable to generate brick ID");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HOSTNAME_TO_UUID_FAIL,               "Failed to convert hostname %s to uuid", hostname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HOSTNAME_TO_UUID_FAIL,                   "Failed to convert hostname %s to uuid", hostname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_SVC_KILL_FAIL,                       "Unable to kill %s "                       "service, reason:%s",                       service, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_PID_KILL_FAIL,                   "Unable to kill pid:%d, "                   "reason:%s",                   pid, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_SVC_KILL_FAIL,                       "Unable to kill %s "                       "service, reason:%s",                       service, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_PID_KILL_FAIL,                       "Unable to find pid:%d, "                       "must be dead already. Ignoring.",                       pid);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_PID_KILL_FAIL,                       "Unable to kill pid:%d, "                       "reason:%s",                       pid, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_CREATE_DIR_FAILED,               "Failed to create rundir");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PORTS_EXHAUSTED,               "All the ports in the range are exhausted, can't start "               "brick %s for volume %s",               brickinfo->path, volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PORTS_EXHAUSTED,                   "All rdma ports in the "                   "range are exhausted, can't start brick %s for "                   "volume %s",                   rdma_brick_path, volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICKPROC_NEW_FAILED,               "Failed to create "               "new brick process instance");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_DISCONNECTED,               "Failed to connect to brick %s:%s on %s", brickinfo->hostname,               brickinfo->path, socketpath);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICKPROC_NEW_FAILED,                       "Failed to create "                       "new brick process instance");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_STOP_FAIL,                       "Failed to send"                       " detach request for brick %s",                       brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_STOP_FAIL,                       "Failed to kill"                       " the brick %s",                       brickinfo->path);
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_READIN_FILE_FAILED, "%s",               strerror(errno));
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Unable to open %s,"               " errno: %d",               cksum_path, errno);
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                   "Could not generate "                   "temp file, reason: %s for volume: %s",                   strerror(errno), volinfo->volname);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_FILE_OP_FAILED,                   "sorting info file "                   "failed");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_CKSUM_GET_FAIL,                   "unable to get "                   "checksum for path: %s",                   sort_filepath);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_CKSUM_GET_FAIL,                   "unable to get "                   "checksum for path: %s",                   filepath);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_CKSUM_GET_FAIL,               "unable to get checksum for path: %s", filepath);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_CKSUM_COMPUTE_FAIL,               "Failed to compute checksum "               "for volume %s",               volinfo->volname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "option add for %s%d %s", ctx->key_name, ctx->opt_count, key);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "option add for %s%d %s", ctx->val_name, ctx->opt_count,               value->data);
gf_msg("glusterd", GF_LOG_ERROR, 0,                           LG_MSG_PAIRS_LESS_THAN_COUNT,                           "less than count data pairs found!");
gf_msg("glusterd", GF_LOG_ERROR, 0, LG_MSG_NULL_PTR,                           "pair->key is null!");
gf_msg("glusterd", GF_LOG_ERROR, 0, LG_MSG_NULL_PTR,                           "pair->value is null!");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CKSUM_VERS_MISMATCH,               "Version of Cksums %s differ. local cksum = %u, remote "               "cksum = %u on peer %s",               volinfo->volname, volinfo->cksum, cksum, hostname);
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_QUOTA_CONFIG_CKSUM_MISMATCH,                   "Cksums of "                   "quota configuration of volume %s differ. local"                   " cksum = %u, remote  cksum = %u on peer %s",                   volinfo->volname, volinfo->quota_conf_cksum, quota_cksum,                   hostname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_IMPORT_PRDICT_DICT, "%s",               msg);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_OPTS_IMPORT_FAIL, "%s",               msg);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_BRICK_IMPORT_FAIL, "%s",               msg);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_BRICK_IMPORT_FAIL, "%s",               msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CKSUM_COMPUTE_FAIL,                   "Failed to compute checksum");
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_QUOTA_CKSUM_VER_STORE_FAIL,                   "Failed to save quota version and checksum");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_SNAP_DETAILS_IMPORT_FAIL,               "Failed to import snapshot "               "details for volume %s",               volname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Only one volume op-version found");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLINFO_IMPORT_FAIL, "%s",               msg);
gf_msg("glusterd", GF_LOG_ERROR, 0,                           GD_MSD_BRICK_DISCONNECT_FAIL,                           "Failed to "                           "disconnect %s:%s",                           brickinfo->hostname, brickinfo->path);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_BRICK_STOP_FAIL,                       "Failed to stop"                       " brick %s:%s",                       old_brickinfo->hostname, old_brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_STORE_FAIL,               "Failed to store "               "volinfo for volume %s",               new_volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLOBAL_OPT_IMPORT_FAIL,               "Failed to import"               " global options");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLOBAL_OPT_IMPORT_FAIL,               "Importing global "               "options failed");
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Out Of Memory");
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                   "Failed to remove %s"                   " error: %s",                   sockfpath, strerror(errno));
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_PMAP_UNSET_FAIL,               "De-register MOUNTV3 is unsuccessful");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_PMAP_UNSET_FAIL,               "De-register MOUNTV1 is unsuccessful");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_PMAP_UNSET_FAIL,               "De-register NFSV3 is unsuccessful");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_PMAP_UNSET_FAIL,               "De-registration of NLM v4 failed");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_PMAP_UNSET_FAIL,               "De-registration of NLM v1 failed");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_PMAP_UNSET_FAIL,               "De-registration of ACL v3 failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Failed to get volinfo"               " from brick(%s) so  pidfile copying/unlink will fail",               other_brick->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Failed to get volinfo"               " from brick(%s) so  pidfile copying/unlink will fail",               brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "Could not copy file %s to %s", pidfile1, pidfile2);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_SET_FAIL,                   "Failed to store volinfo of "                   "%s volume",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,                   "Unable to set cluster.brick-graceful-cleanup key");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_BRICKPROC_ADD_BRICK_FAILED,                           "Adding brick %s:%s to brick "                           "process failed",                           brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESOLVE_BRICK_FAIL,                   FMTSTR_RESOLVE_BRICK, brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_BRICKPROC_ADD_BRICK_FAILED,                       "Adding brick %s:%s to brick process "                       "failed.",                       brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_DISCONNECTED,               "Unable to start brick %s:%s", brickinfo->hostname,               brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_STORE_FAIL,                       "Failed to "                       "write volinfo for volume %s",                       volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_STORE_FAIL,                       "Failed to "                       "write volinfo for volume %s",                       volinfo->volname);
gf_msg(this1->name, GF_LOG_ERROR, 0, GD_MSG_SECONDARYINFO_FETCH_ERROR,               "Unable to fetch secondary details.");
gf_msg(this1->name, GF_LOG_ERROR, 0, GD_MSG_STAT_FILE_READ_FAILED,               "Unable to read the status");
gf_msg(this1->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to set key:%s"                   " value:running in the dict",                   key1);
gf_msg(this1->name, GF_LOG_ERROR, 0,                   GD_MSG_STATUSFILE_CREATE_FAILED,                   "Unable to create status file"                   ". Error : %s",                   strerror(errno));
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_MNTENTRY_GET_FAIL,               "realpath () failed for path %s", mnt_pt);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_BRICKPATH_ROOT_GET_FAIL,               "Failed to get mount point "               "for %s brick",               brick_path);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_MNTENTRY_GET_FAIL,               "Failed to get mnt entry "               "for %s mount path",               mnt_pt);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "statfs error: %s ", strerror(errno));
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to get all "               "volume names for status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESOLVE_BRICK_FAIL,                   FMTSTR_RESOLVE_BRICK, brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_VALIDATE_FAIL, "%s",               op_errstr);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_RB_SRC_BRICKS_MISMATCH,               "Replace brick src bricks differ");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_RB_DST_BRICKS_MISMATCH,               "Replace brick dst bricks differ");
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_PATH_ALREADY_PART_OF_VOL,               "%s", msg);
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Could not allocate memory.");
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "Could not allocate memory.");
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Could not allocate memory.");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,                   "Failed to "                   "regenerate brick volfiles for %s",                   volinfo->volname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,                   "Failed to "                   "regenerate trusted client volfiles for %s",                   volinfo->volname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,                   "Failed to "                   "regenerate client volfiles for %s",                   volinfo->volname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_WRONG_OPTS_SETTING,               "Both upgrade and downgrade"               " options are set. Only one should be on");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_RESOLVE_BRICK_FAIL,                   "Cannot resolve brick %s:%s", brickinfo->hostname,                   brickinfo->path);
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Unable to open pidfile: %s", pidfile_path);
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Unable to get pid of brick process");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_BRK_STATEDUMP_FAIL,                   "error while parsing the statedump "                   "options");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Unable to open pidfile: %s", pidfile_path);
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Unable to get pid of brick process");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_BRK_STATEDUMP_FAIL,               "error while parsing the statedump "               "options");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Unable to open pidfile: %s", pidfile_path);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Unable to get pid of quotad "               "process");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRK_STATEDUMP_FAIL,               "error while parsing "               "statedump options");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_STOP_FAIL,                           "Failed "                           "to stop snapd daemon service");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_STOP_FAIL,                           "Failed "                           "to stop shd daemon service");
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_STALE_VOL_REMOVE_FAIL,                       "Error deleting stale volume");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_STOP_FAIL,               "Failed to reconfigure all daemon services.");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_REBALANCE_START_FAIL,                           "Failed to initialize  defrag."                           "Not starting rebalance process for "                           "%s.",                           volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REBALANCE_START_FAIL,                   "Unknown defrag status (%d)."                   "Not starting rebalance process for %s.",                   volinfo->rebal.defrag_status, volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TASKID_GEN_FAIL,                   "Failed to generate task-id");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get volume id for "               "volume %s",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UUID_PARSE_FAIL,               "Failed to parse volume id "               "for volume %s",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_ID_MISMATCH,               "Volume ids of volume %s - %s"               " and %s - are different. Possibly a split brain among "               "peers.",               volinfo->volname, volid_str, uuid_utoa(volinfo->volume_id));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "fopen() on file: %s failed "               "(%s)",               filename1, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "fopen() on file: %s failed "               "(%s)",               filename2, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "stat on file: %s failed "               "(%s)",               filename1, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "stat on file: %s failed "               "(%s)",               filename2, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MODULE_NOT_INSTALLED,               "libxml not present in the system");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get command "               "string");
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "Out Of Memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set %s", key);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_OPCTX_GET_FAIL,                   "Operation Context is not present");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Unable to store conf path.");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_OPCTX_GET_FAIL,                   "Operation Context is not present");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_MOUNDIRS_AGGR_FAIL,                   "Failed to "                   "aggregate brick mount dirs");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_OPCTX_GET_FAIL,               "Operation Context is not present");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set key: %s in dict", key);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get remote task count");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to copy tasks"                   "to ctx_dict.");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TASKS_COUNT_MISMATCH,               "Local tasks count (%d) and "               "remote tasks count (%d) do not match. Not aggregating "               "tasks status.",               local_count, remote_count);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get task typpe from rsp dict");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get task status from rsp dict");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get task id from rsp dict");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get local task-id");
gf_msg(THIS->name, GF_LOG_ERROR, 0,                           GD_MSG_TASKS_COUNT_MISMATCH,                           "Could not find matching local "                           "task for task %s",                           remote_task_id);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get local task status");
gf_msg(THIS->name, GF_LOG_ERROR, 0,                       GD_MSG_TASK_STATUS_UPDATE_FAIL,                       "Failed to "                       "update task status");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Maximum supported op-version not set in destination "               "dictionary");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get maximum supported op-version from source");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set max op-version");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Unable to find volinfo for volume: %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to get count value");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set count in dictonary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set bitrot log file location");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set scrubber log file location");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Unable to find volinfo for volume: %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set node-uuid");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OPCTX_GET_FAIL,               "Operation Context is not present");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to get index from rsp dict");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set count");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_EMPTY,               "Source or Destination "               "dict is empty.");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to fetch %s", output_name);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to set %s", output_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get quota opcode");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get the count of "               "gfids from the rsp dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get gfid "                   "from rsp dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set gfid "                   "from rsp dict into req dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set aggregated "               "count in req dict");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get heal_op");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Couldn't get node index");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Couldn't get node index");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Couldn't set fuse-count");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Couldn't set gfapi-count");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Couldn't set rebalance-count");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Couldn't set glustershd-count");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Couldn't set quotad-count");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Couldn't set snapd-count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set file count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set size of xfer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set lookedup file count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set failure count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set skipped count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set run-time");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get the cmd");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set count");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set node-uuid");
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "failed to set time left");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set originator_uuid.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set %s in dict", key);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Error setting uuid in dict with key %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNSUPPORTED_VERSION, "%s",               msg);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get opcode");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get quota opcode");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get path");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get count");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get key '%s'", key);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get key "                   "'%s'",                   key);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set gfid");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_ITER_FAIL,               "Failed to iterate through %d"               " entries in the req dict",               count);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_LAZY_UMOUNT_FAIL,               "umount on %s failed, "               "reason : %s",               mountdir, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,                       "Failed to set option '" NFS_DISABLE_MAP_KEY                       "' on volume "                       "%s",                       volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, errno,                           GD_MSG_DICT_SET_FAILED,                           "Failed to set option "                           "'features.quota-deem-statfs' "                           "on volume %s",                           volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, errno,                           GD_MSG_DICT_SET_FAILED,                           "failed to set transport."                           "address-family on %s",                           volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,                   "Failed to set option 'storage.fips-mode-rchecksum' "                   "on volume %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,                   "Failed to set option 'cluster.granular-entry-heal' "                   "on volume %s",                   volinfo->volname);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_BRICKPATH_ROOT_GET_FAIL,               "getting the root "               "of the brick (%s) failed ",               brick_path);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_MNTENTRY_GET_FAIL,               "getting the mount entry for "               "the brick (%s) failed",               brick_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GET_KEY_FAILED,               "Failed to get %s key from "               "volume option entry",               vme->key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_XLATOR_VOLOPT_DYNLOAD_ERROR,               "xlator_volopt_dynload error "               "(%d)",               ret);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get max-opversion value from"               " dictionary");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set %s in "               "dictionary",               GLUSTERD_MAX_OP_VERSION_KEY);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set %s for key %s in dictionary", def_val,               GLUSTERD_MAX_OP_VERSION_KEY);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get option key from dictionary");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_UNKNOWN_KEY, "%s",                   err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set %s in dictionary", allvolopt);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set %s for key %s in dictionary", def_val,                   allvolopt);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set count in dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to "                   "set %s in dictionary",                   vme->key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to "                   "set %s for key %s in dictionary",                   def_val, vme->key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set count "               "in dictionary");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_MODULE_NOT_INSTALLED,                   "Libxml not present");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_MODULE_NOT_INSTALLED,               "Libxml not present");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_MODULE_NOT_INSTALLED,               "Libxml not present");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNSUPPORTED_VERSION,               "Client %s is running with min_op_version as %d and "               "max_op_version as %d and don't support the required "               "op-version %d",               xprt->peerinfo.identifier, xprt->peerinfo.min_op_version,               xprt->peerinfo.max_op_version, op_version);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0,                   (*gd_op == GD_OP_REPLACE_BRICK)                       ? GD_MSG_RB_CMD_FAIL                       : GD_MSG_RESET_BRICK_CMD_FAIL,                   "Unable to open /dev/"                   "fuse (%s), %s command failed",                   strerror(errno), gd_rb_op_to_str(*op));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get src brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get dest brick.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BAD_FORMAT,               "dst brick %s is not of "               "form <HOSTNAME>:<export-dir>",               *dst_brick);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Returning %d. adding values to dict failed", ret);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "failed to allocate memory");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "failed to allocate memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,                   "Unable to find volume: %s", *volname);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_HOSTNAME_RESOLVE_FAIL,                       "unable to resolve host name for addr %s",                       brickinfo->hostname);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                       "failed to allocate "                       "memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Bricks check : Could not "                   "retrieve bricks list");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Bricks check : Could not "                   "retrieve brick count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HOSTNAME_RESOLVE_FAIL,                   "unable to resolve host name for addr %s", brick_addr);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "failed to allocate "                   "memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BAD_BRKORDER_CHECK_FAIL,           "Failed bad brick order check");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Unable to find volume: %s", volname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,                   "Unable to set new auth.allow list");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,                   "Unable to set old auth.allow list");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Unable to find volume: %s", volname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Unable to replace auth.allow list");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_FAILED_INIT_SHDSVC,                       "Failed to init shd "                       "service");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_SHD_OBJ_GET_FAIL,                   "Failed to get shd object "                   "from shd service");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                   "Failed to get volinfo from "                   "from shd");
gf_msg(frame->this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "iov is NULL");
gf_msg(frame->this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "XDR decoding error");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_ATTACH_FAIL,               "svc %s of volume %s failed to attach to pid %d", svc->name,               volinfo->volname, glusterd_proc_get_pid(&svc->proc));
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_PARAM_NULL,               "called with null rpc");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_ATTACH_FAIL,                   "Unable to stat %s (%s)", path, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_ATTACH_FAIL,                   "read failed on path %s. File size=%" GF_PRI_SIZET                   "read size=%d",                   path, file_len, ret);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set pidfile %s in dict", svc->proc.pidfile);
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_PEERINFO_DELETE_FAIL,               "Deleting peer info failed");
gf_msg(this->name, GF_LOG_ERROR, ret, GD_MSG_GETADDRINFO_FAIL,               "error in getaddrinfo: %s\n", gai_strerror(ret));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set key %s in dict", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set key %s in dict", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set key %s in dict", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set key %s in dict", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Key %s not present in "               "dictionary",               key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_ADD_ADDRESS_TO_PEER_FAIL,               "Could not add address to peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Key %s not present in "               "dictionary",               key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Key %s not present "                   "in dictionary",                   key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_ADD_ADDRESS_TO_PEER_FAIL,                   "Could not add address to peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEERINFO_CREATE_FAIL,               "Could not create peerinfo "               "object");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Key %s not present in "               "dictionary",               key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FS_LABEL_UPDATE_FAIL,               "Failed to save "               "snap detils of brick %s",               brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_PORT_STORE_FAIL,               "failed to store the snapd "               "port of volume %s",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "failed to create the "               "temporary file for the snapd store handle of volume "               "%s",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_PORT_STORE_FAIL,               "failed to write snapd port "               "info to store handle (volume: %s",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_HANDLE_CREATE_FAIL,               "failed to create store "               "handle for snapd (volume: %s)",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_INFO_STORE_FAIL,               "failed to store snapd info "               "of the volume %s",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPINFO_WRITE_FAIL,               "Failed to write snap details"               " for volume %s",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_VALS_WRITE_FAIL,               "Unable to write volume "               "values for %s",               volinfo->volname);
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_CREATE_DIR_FAILED,               "Failed to create snaps dir "               "%s",               snapdirpath);
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Couldn't rename "               "temporary file(s)");
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Couldn't rename "               "temporary file(s)");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_SNAPDIR_CREATE_FAIL,               "Failed to create snap dir");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_SNAPINFO_CREATE_FAIL,               "Failed to create snap info "               "file");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_SNAPINFO_WRITE_FAIL,               "Failed to write snap info");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_AUTOMIC_UPDATE_FAIL,               "Failed to do automic update");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_CREATE_DIR_FAILED,               "Failed to create trash "               "directory");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Failed to rename volume "               "directory for volume %s",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_CREATE_DIR_FAILED,               "Failed to create trash "               "directory");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Failed to rename snap "               "directory %s to %s",               pathname, delete_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_HANDLE_GET_FAIL,                   "Unable to get store handle");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "chmod error for %s", GLUSTERD_INFO_FILE);
gf_msg(this->name, GF_LOG_ERROR, 0,               GD_MSG_GLUSTERD_GLOBAL_INFO_STORE_FAIL,               "Failed to store glusterd global-info");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_HANDLE_GET_FAIL,               "Unable to get store handle");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "chmod error for %s", GLUSTERD_UPGRADE_FILE);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_VERS_STORE_FAIL,               "Storing op-version failed ret = %d", ret);
gf_msg(this->name, GF_LOG_ERROR, 0,               GD_MSG_GLUSTERD_GLOBAL_INFO_STORE_FAIL,               "Failed to store max op-version");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_UNSUPPORTED_VERSION,                   "wrong op-version (%d) retrieved", op_version);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HANDLE_NULL,               "volinfo handle is NULL");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_ITER_GET_FAIL,               "Failed to get new store "               "iter");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_ITER_GET_FAIL,               "Failed to get next store "               "iter");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_ITER_DESTROY_FAIL,               "Failed to destroy store iter");
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                   GD_MSG_STORE_ITER_GET_FAIL,                   "Unable to iterate "                   "the store for brick: %s",                   path);
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                           GD_MSG_PARSE_BRICKINFO_FAIL,                           "brick hostname truncated: %s", brickinfo->hostname);
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                           GD_MSG_PARSE_BRICKINFO_FAIL,                           "brick path truncated: %s", brickinfo->path);
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                           GD_MSG_PARSE_BRICKINFO_FAIL,                           "real_path truncated: %s", brickinfo->real_path);
gf_msg(this->name, GF_LOG_ERROR, EINVAL,                           GD_MSG_INCOMPATIBLE_VALUE,                           "Failed to convert "                           "string to integer");
gf_msg(this->name, GF_LOG_ERROR, EINVAL,                           GD_MSG_INCOMPATIBLE_VALUE,                           "Failed to convert "                           "string to integer");
gf_msg(this->name, GF_LOG_ERROR, EINVAL,                           GD_MSG_INCOMPATIBLE_VALUE,                           "Failed to convert "                           "string to integer");
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                           GD_MSG_PARSE_BRICKINFO_FAIL,                           "device_path truncated: %s", brickinfo->device_path);
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                           GD_MSG_PARSE_BRICKINFO_FAIL,                           "mount_dir truncated: %s", brickinfo->mount_dir);
gf_msg(this->name, GF_LOG_ERROR, EINVAL,                           GD_MSG_INCOMPATIBLE_VALUE,                           "Failed to convert "                           "string to integer");
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                           GD_MSG_PARSE_BRICKINFO_FAIL, "fstype truncated: %s",                           brickinfo->fstype);
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                           GD_MSG_PARSE_BRICKINFO_FAIL,                           "mnt_opts truncated: %s", brickinfo->mnt_opts);
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                           GD_MSG_PARSE_BRICKINFO_FAIL,                           "brickinfo->vg truncated: %s", brickinfo->vg);
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                           GD_MSG_PARSE_BRICKINFO_FAIL,                           "brick_id truncated: %s", brickinfo->brick_id);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,                           "%s "                           "is not a valid uint64_t value",                           value);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNKNOWN_KEY,                       "Unknown key: %s", key);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                   GD_MSG_PARSE_BRICKINFO_FAIL,                   "Error parsing brickinfo: "                   "op_errno=%d",                   op_errno);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_ITER_DESTROY_FAIL,               "Failed to destroy store iter");
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                       GD_MSG_STORE_ITER_GET_FAIL,                       "Unable to iterate "                       "the store for brick: %s",                       path);
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                               GD_MSG_PARSE_BRICKINFO_FAIL,                               "brick hostname truncated: %s",                               ta_brickinfo->hostname);
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                               GD_MSG_PARSE_BRICKINFO_FAIL,                               "brick path truncated: %s", ta_brickinfo->path);
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                               GD_MSG_PARSE_BRICKINFO_FAIL,                               "real_path truncated: %s",                               ta_brickinfo->real_path);
gf_msg(this->name, GF_LOG_ERROR, EINVAL,                               GD_MSG_INCOMPATIBLE_VALUE,                               "Failed to convert "                               "string to integer");
gf_msg(this->name, GF_LOG_ERROR, EINVAL,                               GD_MSG_INCOMPATIBLE_VALUE,                               "Failed to convert "                               "string to integer");
gf_msg(this->name, GF_LOG_ERROR, EINVAL,                               GD_MSG_INCOMPATIBLE_VALUE,                               "Failed to convert "                               "string to integer");
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                               GD_MSG_PARSE_BRICKINFO_FAIL,                               "brick_id truncated: %s",                               ta_brickinfo->brick_id);
gf_msg(this->name, GF_LOG_ERROR, 0,                               GD_MSG_INVALID_ENTRY,                               "%s "                               "is not a valid uint64_t value",                               value);
gf_msg(this->name, GF_LOG_ERROR, EINVAL,                               GD_MSG_INCOMPATIBLE_VALUE,                               "Failed to convert "                               "string to integer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNKNOWN_KEY,                           "Unknown key: %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_ITER_DESTROY_FAIL,               "Failed to destroy store iter");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_ITER_DESTROY_FAIL,               "Failed to destroy store iter");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                       "Failed to strdup value string");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Error setting data in rebal "                       "dict.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_ITER_DESTROY_FAIL,               "Failed to destroy store iter");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HANDLE_NULL,               "volinfo handle is NULL");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_ITER_GET_FAIL,               "Failed to get new store "               "iter");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_ITER_GET_FAIL,               "Failed to get next store "               "iter");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Error in "                       "dict_set_str");
gf_msg("glusterd", GF_LOG_ERROR, op_errno,                       GD_MSG_PARSE_BRICKINFO_FAIL,                       "parent_volname truncated: %s", volinfo->parent_volname);
gf_msg(this->name, GF_LOG_ERROR, 0,                               GD_MSG_DICT_SET_FAILED,                               "Error in "                               "dict_set_str");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_ITER_DESTROY_FAIL,               "Failed to destroy store iter");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_UPDATE_FAIL,               "Failed to update volinfo "               "for %s volume",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                   "Parent volinfo "                   "not found for %s volume",                   volname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Unable to open dir %s", path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,                   "Failed to stat entry %s : %s", path, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_RESTORE_FAIL,                   "Unable to restore "                   "volume: %s",                   entry->d_name);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "Invalid brick path(%s)", brick_path);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_SNAP_ACTIVATE_FAIL,               "Failed to activate %s.", brickinfo->device_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_MOUNT_FAIL,               "Failed to mount lvm snapshot.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRK_MNTPATH_GET_FAIL,                   "Failed to find brick_mount_path for %s", brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, errno,                           GD_MSG_CREATE_DIR_FAILED, "Failed to create %s. ",                           brick_mount_path);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                       "Brick Path(%s) not valid. ", brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRK_MNTPATH_MOUNT_FAIL,                   "Failed to mount brick_mount_path");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESOLVE_BRICK_FAIL,                       "resolve brick failed in restore");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HANDLE_NULL,               "snap handle is NULL");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_ITER_GET_FAIL,               "Failed to get new store "               "iter");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_ITER_GET_FAIL,               "Failed to get next store "               "iter");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_ITER_DESTROY_FAIL,               "Failed to destroy store iter");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_OBJECT_STORE_FAIL,               "Failed to create "               " snap object");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPSHOT_UPDATE_FAIL,               "Failed to update snapshot "               "for %s snap",               snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_VOL_RETRIEVE_FAIL,               "Failed to retrieve "               "snap volumes for snap %s",               snapname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                   "Failed to open %s. ", path);
gf_msg(this->name, GF_LOG_ERROR, store_errno,                   GD_MSG_MISSED_SNAP_GET_FAIL,                   "Failed to fetch data from "                   "missed_snaps_list.");
gf_msg(this->name, GF_LOG_ERROR, EINVAL,                   GD_MSG_INVALID_MISSED_SNAP_ENTRY,                   "Invalid missed_snap_entry");
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_MISSED_SNAP_LIST_STORE_FAIL,                   "Failed to store missed snaps_list");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,                   "Unable to open dir %s", path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_RESTORE_FAIL,                       "Unable to restore snapshot: %s", entry->d_name);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_MISSEDSNAP_INFO_SET_FAIL,                       "Failed to write missed snapinfo");
gf_msg(this->name, GF_LOG_ERROR, 0,               GD_MSG_MISSED_SNAP_LIST_STORE_HANDLE_GET_FAIL,               "Unable to obtain "               "missed_snaps_list store handle.");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Failed to create tmp file");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MISSED_SNAP_CREATE_FAIL,               "Failed to write missed snaps to disk");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Failed to rename the tmp file");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TMP_FILE_UNLINK_FAIL,                   "Failed to unlink the tmp file");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Unable to open dir %s", path);
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_ADD_ADDRESS_TO_PEER_FAIL,                           "Could not add address to peer");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNKNOWN_KEY,                       "Unknown key: %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRK_MNT_RECREATE_FAIL,                   "Failed to recreate brick mounts "                   "for %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_BRK_MNT_RECREATE_FAIL,                           "Failed to recreate brick "                           "mounts for %s",                           snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Failed to create dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_REMOVE_FAIL,                       "Failed to remove the snapshot %s", snap->snapname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_RESOLVE_BRICK_FAIL,                       "Failed to resolve brick %s with host %s of volume %s"                       " in restore",                       brickinfo->path, brickinfo->hostname, volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_RESOLVE_BRICK_FAIL,                   "resolving the snap bricks"                   " failed for snap: %s",                   snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CLEANUP_FAIL,               "Failed to perform "               "a cleanup of the snapshots");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_BRK_MNT_RECREATE_FAIL,               "Failed to recreate "               "all snap brick mounts");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_HANDLE_GET_FAIL,               "Unable to get store handle "               "for %s",               cksum_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CKSUM_STORE_FAIL,               "Failed to store quota cksum and version");
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create rundir %s", rundir);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_NOT_FOUND,                   "Volfile %s is not present", svc->proc.volfile);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_GET_FAIL,               "Failed to get the service");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_GET_FAIL,               "Failed to get the svc proc data");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_GET_FAIL,               "Failed to get the service");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_OP_FAIL, "%s",               op_err);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,                       "Replace-brick commit failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,                       "Add-brick commit failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,                       "Volume start commit failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,                       "Volume stop commit failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,                       "Remove-brick commit failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,                       "Reset-brick commit failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,                       "Commit failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,                       "commit failed for volume profile operation.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,                       "Rebalance Commit Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_POST_COMMIT_OP_FAIL,                       "Add-brick post commit failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_POST_COMMIT_OP_FAIL,                       "Replace-brick post commit failed.");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Unable to get"                       " volume name");
gf_msg("glusterd", GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,                       "Unable to "                       "allocate memory");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Unable to get"                       " volume name");
gf_msg("glusterd", GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,                       "Unable to "                       "allocate memory");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Unable to get"                       " volume name");
gf_msg("glusterd", GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,                       "Unable to "                       "allocate memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCK_GET_FAIL,               "Failed to acquire mgmt_v3 locks on localhost");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCK_GET_FAIL,                   "%s", *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALIDATION_FAIL,                       "Failed to aggregate prevalidate "                       "response dictionaries.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALIDATION_FAIL,                       "Failed to aggregate prevalidate "                       "response dictionaries.");
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_BRICK_MOUNDIRS_AGGR_FAIL,                       "Failed to "                       "aggregate brick mount dirs");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALIDATION_FAIL,                       "Failed to aggregate prevalidate "                       "response dictionaries.");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                   "Invalid op (%s)", gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESP_AGGR_FAIL, "%s",               "Failed to aggregate response from "               " node/brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Failed to create response dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SERVER_QUORUM_NOT_MET,                   "Server quorum not met. Rejecting operation.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALIDATION_FAIL,               "Pre Validation failed for "               "operation %s on local node",               gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALIDATION_FAIL,                   "%s",                   "Failed to aggregate response from "                   " node/brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALIDATION_FAIL,               "Pre Validation failed on peers");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESP_AGGR_FAIL, "%s",               "Failed to aggregate response from "               " node/brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Failed to create response dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_OP_FAIL,               "Brick ops failed for "               "operation %s on local node",               gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_OP_FAIL,               "Brick ops failed on peers");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESP_AGGR_FAIL, "%s",               "Failed to aggregate response from "               " node/brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Failed to create response dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,               "Commit failed for "               "operation %s on local node",               gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESP_AGGR_FAIL, "%s",               "Failed to aggregate response from "               " node/brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,               "Commit failed on peers");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESP_AGGR_FAIL, "%s",               "Failed to aggregate response from "               " node/brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Failed to create response dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_POST_COMMIT_OP_FAIL,               "Post commit failed for "               "operation %s on local node",               gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESP_AGGR_FAIL, "%s",               "Failed to aggregate response from "               " node/brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_POST_COMMIT_OP_FAIL,               "Post commit failed on peers");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Failed to create response dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_POST_VALIDATION_FAIL,               "Post Validation failed for "               "operation %s on local node",               gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_POST_VALIDATION_FAIL,               "Post Validation failed on peers");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,               "Unlock failed on peers");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set originator_uuid.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set synctasked flag.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Unable to create dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCKDOWN_FAIL,               "mgmt_v3 lockdown failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_PAYLOAD_BUILD_FAIL,               LOGSTR_BUILD_PAYLOAD, gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALIDATION_FAIL,               "Pre Validation Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,               "Commit Op Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_POST_VALIDATION_FAIL,               "Post Validation Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,                   "Failed to release mgmt_v3 locks on localhost");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set originator_uuid.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set synctasked flag.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Unable to create dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCKDOWN_FAIL,               "mgmt_v3 lockdown failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_PAYLOAD_BUILD_FAIL,               LOGSTR_BUILD_PAYLOAD, gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALIDATION_FAIL,               "Pre Validation Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,               "Commit Op Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_POST_COMMIT_OP_FAIL,               "Post commit Op Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_POST_VALIDATION_FAIL,               "Post Validation Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,                   "Failed to release mgmt_v3 locks on localhost");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Volname not present in "               "dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Volume %s not found ", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set barrier op "               "in request dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set barrier op "               "in volume option dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Failed to create volfiles");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set originator_uuid.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set synctasked flag.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Unable to create dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCKDOWN_FAIL,               "mgmt_v3 lockdown failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_PAYLOAD_BUILD_FAIL,               LOGSTR_BUILD_PAYLOAD, gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALIDATION_FAIL,               "Pre Validation Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set "               "operation-type in dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_OP_FAIL,               "Brick Ops Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,               "Commit Op Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set "               "operation-type in dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_OP_FAIL,               "Brick Ops Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_POST_VALIDATION_FAIL,               "Post Validation Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,                   "Failed to release mgmt_v3 locks on localhost");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_UUID_GEN_STORE_FAIL,               "Unable to generate and save new UUID");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UUID_STORE_FAIL,               "Unable to store the generated uuid %s", uuid_utoa(priv->uuid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VERS_STORE_FAIL,               "Unable to store version");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Memory accounting init"               " failed");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_MODULE_NOT_WORKING,                   GEOREP " module not working as desired");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_MODULE_NOT_WORKING,                   GEOREP                   " module not "                   "working as desired");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_MODULE_NOT_WORKING,               GEOREP               " module not "               "working as desired");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "cannot access mountbroker-root directory %s", mountbroker_root);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DIR_PERM_LIBERAL,               "permissions on mountbroker-root directory %s are "               "too liberal",               mountbroker_root);
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,                   "error while checking mountbroker-root ancestors "                   "%d (%s)",                   errno, strerror(errno));
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DIR_PERM_LIBERAL,                   "permissions on ancestors of mountbroker-root "                   "directory are too liberal");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_CREATE_DIR_FAILED,               "failed to set up mountbroker-root directory %s",               mountbroker_root);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_MOUNT_SPEC_INSTALL_FAIL,           "adding %smount spec failed: label: %s desc: %s",           georep ? GEOREP " " : "", label, pdesc ? pdesc : "");
gf_msg(this->name, GF_LOG_ERROR, 0,               GD_MSG_GLUSTERD_SOCK_LISTENER_START_FAIL,               "Failed to start glusterd "               "unix domain socket listener.");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "stat fails on %s, exiting. (errno = %d)", GLUSTERD_VAR_RUN_DIR,               errno);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "stat fails on %s, exiting. (errno = %d)", abs_path, errno);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_STR_TO_BOOL_FAIL,                   "upgrade option "                   "%s is not a valid boolean type",                   type);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_STR_TO_BOOL_FAIL,                   "downgrade option "                   "%s is not a valid boolean type",                   type);
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_CREATE_DIR_FAILED,               "Unable to create log dir %s", logdir);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "stat fails on %s, exiting. (errno = %d)", workdir, errno);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RPC_INIT_FAIL,               "failed to init rpc");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RPCSVC_REG_NOTIFY_RETURNED,               "rpcsvc_register_notify returned %d", ret);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "failed to set ssl-enabled in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get transport type");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RPC_TRANSPORT_COUNT_GET_FAIL,               "failed to get total number of available tranpsorts");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RPC_LISTENER_CREATE_FAIL,               "creation of listener failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RPC_LISTENER_CREATE_FAIL,               "creation of %d listeners failed, continuing with "               "succeeded transport",               (total_transport - ret));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_VERS_RESTORE_FAIL,               "Failed to restore op_version");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TSTAMP_SET_FAIL,                   "Unable to set atime and mtime of %s as of %s",                   vol_tstamp_file, snap_tstamp_file);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_NEW_INFO_FAIL,                   "Failed to create "                   "new brickinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_SET_INFO_FAIL,                   "Failed to dup "                   "brickinfo");
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_MISSEDSNAP_INFO_SET_FAIL,                       "Failed to add missed snapshot info "                       "for %s:%s in the rsp_dict",                       brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Failed to regenerate volfiles");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TSTAMP_SET_FAIL,               "Geo-rep: marker.tstamp's timestamp restoration failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_STATUS_FAIL,               "Failed to set snap_status for %s:%s", brickinfo->hostname,               brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snap_device for %s:%s", brickinfo->hostname,               brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set fstype for %s:%s", brickinfo->hostname,               brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRK_MOUNTOPTS_FAIL,               "Failed to set mnt_opts for %s:%s", brickinfo->hostname,               brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to set mount_dir for %s:%s", brickinfo->hostname,               brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set %s for volume"               "%s",               key, volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to set %s "                   "for volume %s",                   key, volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set %s for volume"               "%s",               key, volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set %s for volume"               "%s",               key, volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Unable to set %s", name_buf);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set missed_snap_count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to add snap:%s volume:%s "                   "to peer_data dict for handshake",                   snap->snapname, volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to add quota conf for "                       "snap:%s volume:%s to peer_data "                       "dict for handshake",                       snap->snapname, volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set host_bricks for snap %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set volcount for snap %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set snapname for snap %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set snap_id for snap %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to set description for snap %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set time_stamp for snap %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set snap_restored for snap %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set snap_status for snap %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to add snap(%s) to the "                   " peer_data dict for handshake",                   snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snap_count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "%s missing in payload", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "%s missing in payload", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "%s missing in payload", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "%s missing in payload", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "%s missing in payload", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "%s missing in payload "               "for %s",               key, volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "%s missing in payload "               "for %s",               key, volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "%s missing in payload "               "for %s",               key, volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Unable to create dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_REMOVE_FAIL,                       "Failed to remove snap");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                           "Could not get volinfo of %s", parent_volname);
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_SNAP_RESTORE_FAIL,                           "Failed to restore snap for %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0,                               GD_MSG_SNAP_REMOVE_FAIL,                               "Failed to remove LVM backend");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_SNAP_CLEANUP_FAIL,                           "Failed to perform snapshot restore "                           "cleanup for %s volume",                           parent_volname);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                   "Invalid missed snap entry");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_SNAPSHOT_OP_FAILED,                           "Failed to perform missed snap op");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MISSED_SNAP_LIST_STORE_FAIL,               "Failed to add missed snaps to list");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPSHOT_OP_FAILED,               "Failed to perform snap operations");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MISSED_SNAP_LIST_STORE_FAIL,               "Failed to update missed_snaps_list");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "failed to get "                   "version of snap volume = %s",                   peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                   "Failed to get snap "                   "volinfo %s",                   snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_SET_FAIL,               "Failed to store snapshot "               "volinfo (%s) for snap %s",               snap_vol->volname, peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "generating the brick volfiles for the "               "snap %s failed",               peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "generating the trusted client volfiles for "               "the snap %s failed",               peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "generating the client volfiles for the "               "snap %s failed",               peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Parent volinfo "               "not found for %s volume of snap %s",               snap_vol->volname, peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_SET_FAIL,               "Failed to store snap volinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,               "Could not create "               "the snap object for snap %s",               peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Failed to create dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,                   "Saving the Snapshot Description Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get time_stamp for snap %s", peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get snap_restored for snap %s", peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get snap_status for snap %s", peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volcount for snap %s", peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPDIR_CREATE_FAIL,               "Failed to create snap dir");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_SET_FAIL,                   "Failed to import snap volinfo for "                   "snap %s",                   peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,                   "Failed to generate snap vol files "                   "for snap %s",                   peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_BRK_MNT_RECREATE_FAIL,                       "Failed to recreate brick mounts"                       " for %s",                       snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_STORE_FAIL,                       "Failed to "                       "write volinfo for volume %s",                       snap_vol->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_UMOUNT_FAIL,                       "Failed to unmounts for %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_QUOTA_CONFIG_IMPORT_FAIL,                   "Failed to import quota conf "                   "for snap %s",                   peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch snapname from peer: %s", peername);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch snap_id from peer: %s", peername);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volcount for snap %s", peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch host_bricks from peer: %s "               "for %s",               peername, peer_snap_name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CONFLICT,               "Conflict in snapshot %s with peer %s", peer_snap_name,               peername);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to fetch snap_count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to fetch peername");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to fetch snapname from peer: %s", peername);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to fetch snap_id from peer: %s", peername);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,                       "Unable to create dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MISSED_SNAP_PRESENT,                       "Snapshot %s from peer %s missing on "                       "localhost",                       peer_snap_name, peername);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_REMOVE_FAIL,                       "Failed to remove snap %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_IMPORT_FAIL,                       "Failed to import snap %s from peer %s", peer_snap_name,                       peername);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to fetch snap_count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPSHOT_OP_FAILED,                   "Failed to compare snapshots with peer %s", peername);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set peername into the dict");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_EMPTY,               "Source or Destination "               "dict is empty.");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to get config-command type");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Unable to set snap_max_hard_limit");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Unable to get snap_max_soft_limit");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Unable to set snap_max_soft_limit");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Unable to get voldisplaycount");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Unable to set voldisplaycount");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                           "Unable to get %s", buf);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Unable to set %s", buf);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                           "Unable to get %s", buf);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Unable to set %s", buf);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                           "Unable to get %s", buf);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Unable to set %s", buf);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                           "Unable to get %s", buf);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Unable to set %s", buf);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_EMPTY,               "Source or Destination "               "dict is empty.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "unable to get the type of "               "the snapshot command");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to "               "get the volume count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get brick order (%s)", snapbrckord);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "failed to "                       "get the brick status (%s)",                       key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "failed to "                       "set the brick status (%s)",                       key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_EMPTY,               "Source or Destination "               "dict is empty.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_SET_INFO_FAIL,               "failed to merge brick "               "status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to get snap UUID");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snap uuid in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set "                   "soft_limit_flag");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to fetch %s", name_buf);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to set %s", name_buf);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set dst_missed_snap_count");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_EMPTY,               "Source or Destination "               "dict is empty.");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "unable to get the type of "               "the snapshot command");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_RSP_DICT_USE_FAIL,                       "Unable to use rsp dict");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_RSP_DICT_USE_FAIL,                       "Unable to use rsp dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_MOUNT_FAIL,               "mounting the snapshot "               "logical device %s failed (error: %s)",               brickinfo->device_path, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_DISCONNECTED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_SERVER_QUORUM_NOT_MET, "%s", err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "failed to "                   "get snapname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_NOT_FOUND,                   "failed to "                   "get the snapshot %s",                   snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to get "               "volcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "failed to "                   "get clonename");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_NOT_FOUND,                           "failed to get snap volume "                           "for snap %s",                           snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,                       "failed to find the volume %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "failed to "                   "get snapname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_NOT_FOUND,                   "failed to "                   "get the snapshot %s",                   snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to get "               "volcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "failed to "                   "get volname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_NOT_FOUND,                       "failed to get snap volume %s "                       "for snap %s",                       volname, snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,                       "failed to find the volume %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "unable to get the type of "               "the snapshot command");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRK_MNTPATH_GET_FAIL,                   "Failed to find brick_mount_path for %s", brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_UMOUNT_FAIL,                   "umount failed "                   "for path %s (brick: %s): %s. Retry(%d)",                   brick_mount_path, brickinfo->path, strerror(errno),                   retry_count);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_GLUSTERD_UMOUNT_FAIL,               "umounting %s failed (%s)", path, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "%s not found", source);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Unable to open file %s", source);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FILE_OP_FAILED,               "Unble to open a file %s", destination);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                   "Error reading file "                   "%s",                   source);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FILE_OP_FAILED,                   "Writing in "                   "file %s failed with error %s",                   destination, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Unable to open %s", source);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "Could not copy "                   "%s to %s",                   src_path, dest_path);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to "               "get value for key %s",               secondary_key);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Failed to copy %s in %s", src_path, dest_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FILE_NOT_FOUND,               "%s not found", src_path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Failed to copy %s in %s", src_path, dest_path);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Stat on %s failed with %s", src_path, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "Failed to copy %s in %s", src_path, dest_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FILE_OP_FAILED,                   "Failed to open %s", dest ? src_path : dest_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Unable to fetch "               "volinfo for volname %s",               origin_volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GEOREP_GET_FAILED,                   "Failed to get geo-rep session");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DIR_OP_FAILED,                   "Could not copy "                   "%s to %s",                   src_path, dest_path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Failed to copy %s in %s", src_path, dest_path);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get 'features.uss'"               " from dict for volume %s",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to "                   "set soft limit exceed flag in "                   "response dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REQ_DECODE_FAIL,               "Failed to decode "               "request received from cli");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED, "%s",                   msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_NOT_PERMITTED,               "replace-brick is not permitted on distribute only "               "volumes");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SERVER_QUORUM_NOT_MET,               "Server quorum not met. Rejecting operation.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_VALIDATE_FAIL, "%s",               *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_BRICK_NOT_FOUND,                   "%s", *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_BRICK_MOUNTDIR_GET_FAIL,                       "Failed to get brick mount_dir");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set brick.mount_dir");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set local_brick_count");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_STATVFS_FAILED,                   "Failed to fetch disk utilization "                   "from the brick (%s:%s). Please check the health of "                   "the brick. Error code was %s",                   new_brickinfo->hostname, new_brickinfo->path,                   strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno,                   GD_MSG_BRICK_MOUNTDIR_GET_FAIL,                   "brick1.mount_dir not present");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get src brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get dst brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Unable to allocate memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RB_BRICKINFO_GET_FAIL,               "Unable to get "               "replace brick destination brickinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTER_SERVICES_STOP_FAIL,               "Unable to stop gluster services, ret: %d", ret);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RBOP_STATE_STORE_FAIL,               "Couldn't store"               " replace brick operation's state");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set originator_uuid.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set synctasked flag to true.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_CREATE_FAIL,               "Unable to create dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCKDOWN_FAIL,               "mgmt_v3 lockdown failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_PAYLOAD_BUILD_FAIL,               LOGSTR_BUILD_PAYLOAD, gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALIDATION_FAIL,               "Pre Validation Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,               "Commit Op Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,                   "Failed to release mgmt_v3 locks on "                   "localhost.");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "device is NULL");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "snapname is NULL");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_VG_GET_FAIL,               "Failed to get volume group "               "for device %s",               device);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_VG_GET_FAIL,               "Failed to get volume group "               "for snap %s",               snapname);
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_MISSED_SNAP_CREATE_FAIL,                           "Failed to add missed snapshot "                           "info for %s:%s in the "                           "rsp_dict",                           brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Creating directory %s failed", snap_session_dir);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Failed to allocate memory for regular expression");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REG_COMPILE_FAILED,               "Failed to compile the regular expression");
gf_msg(this->name, GF_LOG_ERROR, ENOENT, GD_MSG_FILE_OP_FAILED,               "Session files not present "               "in %s",               georep_session_dir);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "Could not copy file %s of session %s", files[i]->d_name,                   session);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Failed to create trash directory, reason : %s",               strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "Failed to rename snap "               "directory %s to %s",               pathname, delete_path);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Failed to create origin "               "volume directory (%s), reason : %s",               pathname, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,                   "Failed to rename directory %s to %s", delete_path,                   pathname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Creating directory %s failed", snapgeo_dir);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GEOREP_GET_FAILED,                   "Failed to get geo-rep session");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FILE_OP_FAILED,                   "Failed to copy files"                   " related to session %s",                   session);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get snap name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_NOT_FOUND, "%s",               *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,                   "Could not get volinfo of %s", snap_volinfo->parent_volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set snap "                   "uuid in response dictionary for %s snapshot",                   snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set snap "                   "uuid in response dictionary for %s snapshot",                   snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set snap "                   "uuid in response dictionary for %s snapshot",                   snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MISSED_SNAP_GET_FAIL,                       "Failed to find missed snap restores");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRK_MNT_RECREATE_FAIL,                   "Failed to recreate brick mounts for %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_RESTORE_FAIL,                   "Failed to restore "                   "snap for %s",                   snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get "               "snap name");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_NOT_FOUND, "%s",               *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPSHOT_OP_FAILED, "%s",               *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set "               "snap name(%s)",               snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get volume count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to "                   "get volume name");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND, "%s",                   *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPSHOT_OP_FAILED, "%s",                   *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_OP_FAILED,                   "Failed to backup "                   "volume backend files for %s volume",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPSHOT_OP_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HARD_LIMIT_SET_FAIL,                   "snap-max-hard-limit validation failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Unable to set hold_vol_locks value "                           "as _gf_false");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HARD_LIMIT_SET_FAIL,                       "snap-max-limit "                       "display commit failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_CLI_RESP,                       "Failed to send cli "                       "response");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_COMMAND_NOT_FOUND,                   "Unknown config type");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to "               "get the volume count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get brick order");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Unable to fetch snap_device");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "failed to "                       "get the brick status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "failed to "                       "set the brick status");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "Source or Destination "               "dict is empty.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,               "Source or Destination "               "dict is empty.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "unable to get the type of "               "the snapshot command");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Unable to use "                       "rsp dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RSP_DICT_USE_FAIL,                       "Unable to use "                       "rsp dict");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "key prefix is NULL");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set %s", key_prefix);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_TPOOL_GET_FAIL,               "Failed to get thin pool "               "name for device %s",               device);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_TPOOL_GET_FAIL,               "Failed to get pool name "               "for device %s",               device);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "Failed to validate "               "snapname or volume information");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRK_MOUNTOPTS_FAIL,                   "Failed to "                   "update mount options for %s brick",                   brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "failed to "                   "add brick status to dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set %s", key);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Failed to get snap "               "volinfo %s",               snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch snap_volid");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALIDATION_FAIL,               "Failed to pre validate");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set volcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get flags");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to fetch snap_volid");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PRE_VALIDATION_FAIL,                   "Failed to pre validate");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set volcount");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_LOCK_INIT_FAILED,                   "Failed initiating"                   " snap lock");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,               "brickinfo NULL");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNOUNT_FAILED,               "umount failed for "               "path %s (brick: %s): %s.",               mount_pt, brickinfo->path, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_REMOVE_FAIL,               "removing snapshot of the "               "brick (%s:%s) of device %s failed",               brickinfo->hostname, brickinfo->path, snap_device);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_GET_INFO_FAIL,                   "Failed to find brick_mount_path for %s", brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_MISSED_SNAP_CREATE_FAIL,                           "Failed to add missed snapshot "                           "info for %s:%s in the "                           "rsp_dict",                           brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_REMOVE_FAIL,                   "Failed to "                   "remove the snapshot %s (%s)",                   brickinfo->path, brickinfo->device_path);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                       "Invalid brick %s", brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,                       "Failed to rmdir: %s, err: %s", brick_dir,                       strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,                   "Failed to remove "                   "%s directory : error : %s",                   snap_path, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,                   "Failed to get "                   "parent volinfo %s  for volume  %s",                   snap_vol->parent_volname, snap_vol->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set "               "volume name in dictionary: %s",               key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_MEMORY,               "Failed to set "               "volume id in dictionary: %s",               key);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                   "Invalid volume status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set volume status"               " in dictionary: %s",               key);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,               "failed to get the parent "               "volinfo for the volume %s",               snap_vol->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set available snaps");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Could not save snapcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set parent "               "volume name in dictionary: %s",               key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set "               "snap name in dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set "               "snap id in dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set "               "snap time stamp in dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set "                   "snap description in dictionary");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                   "Invalid snap status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snap status "               "in dictionary");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_DICT_GET_FAILED,                   "Failed to "                   "get volume detail %s for snap %s",                   snap_vol->volname, snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to "                   "get volume detail %s for snap %s",                   snap_vol->volname, snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get "                   "snapdetail for snap %s",                   snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snapcount");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set available snaps");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set parent "               "volume name in dictionary: %s",               value);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get "                   "snapdetail for snap %s",                   snap_vol->snapshot->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snapcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get type "               "of snapshot info");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get info of all snaps");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get snap name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set snapcount");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_NOT_FOUND,                       "%s", err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_NOT_FOUND,                       "Failed to get snap detail of snap "                       "%s",                       snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,                       "Failed to get volname");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,                       "Failed to get volume info of volume "                       "%s",                       volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snap-driven");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_CLI_RESP,               "Failed to send cli "               "response");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "strdup failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snapcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to "                   "set %s",                   key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snapcount");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_LIST_GET_FAIL,                   "Failed to get snapshot list");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND, "%s",                   err_str);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_LIST_GET_FAIL,                   "Failed to get snapshot list for volume %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_CLI_RESP,               "Failed to send cli "               "response");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to "               "get the volume count");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "Invalid volume count %" PRId64 " supplied", volcount);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to get the snapname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set snap-time");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to update "                   "snap-name");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Out Of Memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set snap-id");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set snap "                   "username for volume %s",                   volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set snap "                   "password for volume %s",                   volname);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "Out Of Memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to set snap_volid");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to set snap volname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_INIT_FAIL,               "Failed to initiate snap "               "phases");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_INIT_FAIL,               "Failed to initiate "               "snap phases");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to "               "get the clone name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set clone "               "name for volume locking");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to get the snapname");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Out Of Memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set clone-id");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get snapname name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set clone "               "username for volume %s",               clonename);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set clone "               "password for volume %s",               clonename);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Out Of Memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set clone_volid");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set snap volname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_INIT_FAIL,               "Failed to initiate "               "snap phases");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to "               "get snapname");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_NOT_FOUND, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Could not set "                   "parent volume name %s in the dict",                   snap_volinfo->parent_volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Could not save volume count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_INIT_FAIL,               "Failed to initiate snap phases");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch snapname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch snap_id");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch snap-time");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "Invalid time-stamp: %" PRId64, time_stamp);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,                   "Found duplicate snap %s (%s)", snap->snapname,                   uuid_utoa(snap->snap_id));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,               "Could not create "               "the snap object for snap %s",               snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,                   "Saving the Snapshot Description Failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set missed_snap_entry (%s) "               "in the rsp_dict.",               missed_snap_entry);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set missed_snap_count for %s "               "in the rsp_dict.",               missed_snap_entry);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_GET_INFO_FAIL,               "getting device name for "               "the brick %s failed",               origin_brick_path);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_LVCREATE_FAIL,               "Failed to run lvcreate help");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,               "taking snapshot of the "               "brick (%s) of device %s failed",               origin_brick_path, origin_device);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "creating the brick directory"               " %s for the snapshot %s(device: %s) failed",               snap_brick_mount_path, snap_volinfo->volname,               brickinfo->device_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_LVM_MOUNT_FAILED,               "Failed to mount lvm snapshot.");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_SET_XATTR_FAIL,               "Failed to set "               "extended attribute %s on %s. Reason: "               "%s, snap: %s",               GF_XATTR_VOL_ID_KEY, brickinfo->path, strerror(errno),               snap_volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_NEW_INFO_FAIL,               "initializing the brick for the snap "               "volume failed (snapname: %s)",               snap_vol->snapshot->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MISSEDSNAP_INFO_SET_FAIL,                   "Failed to add missed"                   " snapshot info for %s:%s in the rsp_dict",                   original_brickinfo->hostname, original_brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_NOT_FOUND,               "Unable to fetch "               "snap device (%s). Leaving empty",               key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_CANONICALIZE_FAIL,               "Failed to canonicalize path");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FS_LABEL_UPDATE_FAIL,               "Failed to change "               "filesystem label of %s brick to %s",               brickinfo->path, label);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "Device path is empty "               "brick %s:%s",               brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,               "Failed to take snapshot of "               "brick %s:%s",               brickinfo->hostname, origin_brick_path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FS_LABEL_UPDATE_FAIL,               "Failed to update "               "file-system label for %s brick",               brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_CREATION_FAIL,                   "not able to "                   "create the brick for the snap %s, volume %s",                   snap_vol->snapshot->snapname, snap_vol->volname);
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,                   "dict set failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get %s for "               "snap %s",               key, snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get %s for "               "snap %s",               key, snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch snap_volid");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_OP_FAILED,               "Failed to duplicate volinfo "               "for the snapshot %s",               snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get %s "                   "for snap %s",                   key, snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_LIST_SET_FAIL,                   "could not add the "                   "snap volume %s to the list",                   snap_vol->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_OP_FAILED,                   "Failed to copy "                   "geo-rep config and status files for volume %s",                   origin_vol->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_ADD_FAIL,                   "Failed to add the snap brick for "                   "%s:%s to the snap volume",                   brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_EXPORT_FILE_CREATE_FAIL,                       "Failed to create"                       "export file for NFS-Ganesha\n");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_EXPORT_FILE_CREATE_FAIL,                   "Dynamic export addition/deletion failed."                   " Please see log file for details. Clone name = %s",                   clonename);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_SET_FAIL,               "Failed to store snapshot "               "volinfo (%s) for snap %s",               snap_vol->volname, snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_VOL_CONFIG_FAIL,               "Failed to copy quota "               "config and cksum for volume %s",               origin_vol->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_OP_FAILED,                   "Failed to clear quota "                   "option for the snap %s (volume: %s)",                   snap->snapname, origin_vol->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "generating the brick "               "volfiles for the snap %s (volume: %s) failed",               snap->snapname, origin_vol->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "generating the trusted "               "client volfiles for the snap %s (volume: %s) failed",               snap->snapname, origin_vol->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "generating the client "               "volfiles for the snap %s (volume: %s) failed",               snap->snapname, origin_vol->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_OP_FAILED,                   "Failed to reset quota "                   "option for the snap %s (volume: %s)",                   snap->snapname, origin_vol->volname);
gf_msg(this->name, GF_LOG_ERROR, 0,                               GD_MSG_EXPORT_FILE_CREATE_FAIL,                               "Failed to create"                               "export file for NFS-Ganesha\n");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_EXPORT_FILE_CREATE_FAIL,                           "Dynamic export addition/deletion failed."                           " Please see log file for details. Clone name = %s",                           clonename);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,               "input parameters NULL");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Getting the snap name "               "failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to get flags");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOLINFO_GET_FAIL,               "Unable to fetch snap_volinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get "               "volume name");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,               "Failed to get volinfo of "               "volume %s",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_LIST_GET_FAIL,               "Failed to get snapshot list for volume %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Could not save "                   "snap name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Could not save snapcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get snapname");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_NOT_FOUND, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "strdup failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set "                   "volume name in dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set volcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_INIT_FAIL,               "Failed to initiate snap "               "phases");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMAND_NOT_FOUND,               "Failed to get sub-cmd");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_REMOVE_FAIL,                       "Failed to handle "                       "snapshot delete for type SNAP");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_REMOVE_FAIL,                       "Failed to handle "                       "snapshot delete for type ALL");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_REMOVE_FAIL,                       "Failed to handle "                       "snapshot delete for type VOL");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                   "Wrong snapshot delete type");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_CLI_RESP,                   "Failed to send cli "                   "response");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,               "input parameters NULL");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Getting the snap name "               "failed");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_NOT_FOUND,               "Snapshot (%s) does not exist", snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snap "               "uuid in response dictionary for %s snapshot",               snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,               "Input dict is NULL");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Could not fetch status cmd");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Could not fetch snapname");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_NOT_FOUND,                       "Snapshot (%s) does not exist", snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Could not fetch volname");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,                       "Volume "                       "%s not present",                       volname);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_COMMAND_NOT_FOUND,                   "Invalid command");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,               "input parameters NULL");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Getting the snap name "               "failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get flags");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_NOT_FOUND,               "Snapshot (%s) does not exist", snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Unable to fetch snap_volinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_CREATION_FAIL,                   "not able to "                   "create the brick for the snap %s, volume %s",                   snap_volinfo->snapshot->snapname, snap_volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_ACTIVATE_FAIL,               "Failed to activate snap volume %s of the snap %s",               snap_volinfo->volname, snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snap "               "uuid in response dictionary for %s snapshot",               snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,               "input parameters NULL");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Getting the snap name "               "failed");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_NOT_FOUND,               "Snapshot (%s) does not exist", snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Unable to fetch snap_volinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_DEACTIVATE_FAIL,               "Failed to deactivate"               "snap %s",               snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_UMOUNT_FAIL,               "Failed to unmounts for %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Failed to remove "               "%s directory : error : %s",               snap_path, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snap "               "uuid in response dictionary for %s snapshot",               snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,               "input parameters NULL");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Getting the snap name "               "failed");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_NOT_FOUND,               "Snapshot (%s) does not exist", snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snap uuid in "               "response dictionary for %s snapshot",               snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_OBJECT_STORE_FAIL,               "Failed to "               "store snap object %s",               snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                   "Unable to fetch snap_volinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MISSED_SNAP_GET_FAIL,                   "Failed to find missed snap deletes");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_REMOVE_FAIL,               "Failed to remove snap %s", snapname);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Strdup failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set the snapname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,               "input parameters NULL");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get"               " volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "getting the snap "               "name failed (volume: %s)",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MISSEDSNAP_INFO_SET_FAIL,               "Failed to add missed snaps to list");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MISSEDSNAP_INFO_SET_FAIL,               "Failed to update missed_snaps_list");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,               "Failed to "               "take backend snapshot for brick "               "%s:%s volume(%s)",               snap_args->brickinfo->hostname, snap_args->brickinfo->path,               snap_args->snap_vol->volname);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to "               "add %s to dict",               key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0,                               GD_MSG_DICT_SET_FAILED,                               "failed to add %s to "                               "dict",                               key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,                       "Failed to "                       "spawn task for snapshot create");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "failed to "                   "add %s to dict",                   key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,               "Failed to create snapshot");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch clonename");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch clone_id");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_OBJ_NEW_FAIL,               "Could not create "               "the snap object for snap %s",               snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch clonename");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Out of memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set clonename in rsp_dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to get snap name");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_NOT_FOUND,               "Failed to "               "fetch snap %s",               volname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,               "Failed to get snap "               "volinfo %s",               snap_parent->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_OBJ_NEW_FAIL,               "creating the"               "snap object %s failed",               snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set volcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_BACKEND_MAKE_FAIL,               "Failed to take backend "               "snapshot %s",               snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snap "               "uuid in response dictionary for %s snapshot",               snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to "               "get the volume count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch snapname");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,               "Out of memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to set snapname in rsp_dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,               "creating the"               "snap object %s failed",               snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "failed to get volume name");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,                   "failed to get the volinfo for "                   "the volume %s",                   volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPSHOT_OP_FAILED,                       "Failed to "                       "check soft limit exceeded or not, "                       "for volume %s ",                       origin_vol->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set volcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,               "Failed to take backend "               "snapshot %s",               snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snap "               "uuid in response dictionary for %s snapshot",               snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_SET_FAIL,                       "Failed to store snap volinfo %s", snap_vol->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get flags");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_ACTIVATE_FAIL,                   "Failed to activate snap volume %s of the "                   "snap %s",                   snap_vol->volname, snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to store "                   "%s in the options",                   GLUSTERD_STORE_KEY_SNAP_MAX_HARD_LIMIT);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_FAIL,                   "Failed to store "                   "options");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPSHOT_OP_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMAND_NOT_FOUND,               "failed to get config-command type");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HARD_LIMIT_SET_FAIL,                   "snap-max-hard-limit set commit failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to save %s in the dictionary",                   GLUSTERD_STORE_KEY_SNAP_MAX_SOFT_LIMIT);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Could not "                   "save auto-delete value in conf->opts");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Could not save "                   "snap-activate-on-create value in conf->opts");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "Invalid option");
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_GLOBAL_OP_VERSION_GET_FAIL,                   "Failed to get next global opt-version");
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_GLOBAL_OP_VERSION_SET_FAIL,                   "Failed to set next global opt-version");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_STORE_FAIL,                   "Failed to store options");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_GET_INFO_FAIL,               "Getting device name for "               "the brick %s:%s failed",               brickinfo->hostname, brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_LVS_FAIL,               "Could not perform lvs action");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Could not save vgname ");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Could not save data percent ");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Could not save meta data percent ");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Unable to store "               "brick_path %s",               brickinfo->path);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Could not save vgname ");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Could not save brick status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Could not save brick status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Could not save pid %d", pid);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Could not save vgname ");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_GET_INFO_FAIL,               "Failed to get "               "brick LVM details");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_STATUS_FAIL,                       "Getting "                       "single snap status failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Could not save brick count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Could not save volcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Could not save "               "snap name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Could not save "               "snap UUID");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_STATUS_FAIL,               "Could not get single snap status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Could not save volcount");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,               "Failed to get volinfo of "               "volume %s",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Could not save "                   "snap name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to save snapcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Could not save "                   "snap name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Could not save snapcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get status cmd type");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Could not save status cmd in rsp dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_STATUS_FAIL,                       "Unable to "                       "get snapshot status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Unable to "                       "get snap name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL,                       "Unable to "                       "get snap volinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_STATUS_FAIL,                       "Unable to "                       "get status of snap");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Unable to "                       "set snapcount to 1");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Unable to"                       " get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_STATUS_FAIL,                       "Function :"                       " glusterd_get_snap_status_of_volume "                       "failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to get the volcount");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "failed to get the "                   "volname");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,                   "volinfo for %s "                   "not found",                   volname);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_SNAP_OBJECT_STORE_FAIL,                       "could "                       "not store snap object %s",                       snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch "               "clonename");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "unable to find clone "               "%s volinfo",               clonename);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_NOT_FOUND,               "Snapshot volume is null");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to fetch "               "snapname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_NOT_FOUND,               "unable to find snap "               "%s",               snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,               "Failed to "               "create snapshot");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get volname.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,                   "Failed to get volinfo.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMAND_NOT_FOUND,               "unable to get the type of "               "the snapshot command");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CREATION_FAIL,                       "Failed to "                       "create snapshot");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CLONE_FAILED,                       "Failed to "                       "clone snapshot");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CONFIG_FAIL,                       "snapshot config failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_REMOVE_FAIL,                       "Failed to "                       "delete snapshot");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                           "Failed to get snapname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_STATUS_FAIL,                       "Failed to "                       "show snapshot status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMAND_NOT_FOUND,               "unable to get the type of "               "the snapshot command");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to fetch "                       "operation type");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "Failed to "                           "set barrier value as enable in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                           "Failed to "                           "set barrier value as disable in "                           "dict");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                       "Invalid op_type");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                           "Unable to get volname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMAND_NOT_FOUND,               "unable to get the type of "               "the snapshot command");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,                   "Failed to lstat "                   "backup dir (%s)",                   delete_path);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Failed to remove "               "backup dir (%s)",               delete_path);
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Failed to remove "               "backup dir");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Failed to remove "               "%s directory",               pathname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,               "Failed to rename folder "               "from %s to %s",               trash_path, pathname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_OP_FAILED,               "Failed to load restored "               "%s volume",               volinfo->volname);
gf_msg(THIS->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,               "Could not get volinfo of "               "%s",               snap_volinfo->parent_volname);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_RESTORE_REVERT_FAIL,               "Failed to revert snapshot "               "restore operation for %s volume",               volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "getting the snap "               "name failed (volume: %s)",               name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_NOT_FOUND,               "Snapshot (%s) does not exist", name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "failed to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Volume (%s) does not exist ", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "getting the snap "               "name failed (volume: %s)",               volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_SNAP_NOT_FOUND,               "snap %s is not found", name);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_CLEANUP_FAIL,                   "Failed to perform "                   "snapshot restore cleanup for %s volume",                   volname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED,                       "Failed to remove backup dir");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_RESTORE_REVERT_FAIL,                   "Failed to revert "                   "restore operation for %s volume",                   volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_OBJECT_STORE_FAIL,                   "Could not store snap object for %s snap", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_UMOUNT_FAIL,                       "Failed to unmounts for %s", snap->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMAND_NOT_FOUND,               "unable to get the type of "               "the snapshot command");
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_MISSED_SNAP_LIST_STORE_FAIL,                       "Failed to "                       "update missed snaps list");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_RESTORE_FAIL,                       "Failed to "                       "update missed snaps list");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_RESTORE_FAIL,                       "Failed to "                       "perform snapshot restore post-op");
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_FILE_OP_FAILED,               "stat fails on %s, exiting. (errno = %d (%s))", lvm_cmd, errno,               strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,               "request dict length is %d", cli_req.dict.dict_len);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNSUPPORTED_VERSION,               "%s (%d < %d)", err_str, conf->op_version, GD_OP_VERSION_3_6_0);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMAND_NOT_FOUND, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMAND_NOT_FOUND, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_COMMAND_NOT_FOUND,                   "Unknown snapshot request "                   "type (%d)",                   type);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MISSED_SNAP_CREATE_FAIL,               "Failed to create new missed snap object.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MISSED_SNAP_CREATE_FAIL,                   "Failed to create missed snapinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MISSED_SNAP_CREATE_FAIL,                   "Failed to update existing missed snap entry.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to fetch %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_INVALID_MISSED_SNAP_ENTRY,                   "Invalid missed_snap_entry");
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_MISSED_SNAP_LIST_STORE_FAIL,                   "Failed to store missed snaps_list");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FILE_OP_FAILED,               "Could not store snap "               "object for %s snap of %s volume",               snap_vol->volname, snap_vol->parent_volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_STOP_FAILED,               "Failed to stop "               "snap volume");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_OP_FAILED,               "Failed to create volinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_RESTORE_FAIL,               "Failed to restore snap");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAP_RESTORE_FAIL,               "Failed to restore "               "quota files for snap %s",               snap_vol->snapshot->snapname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_OP_FAILED,               "Failed to store volinfo");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,               "Failed to get volinfo of volume %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set "                   "snap name in dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set "                   "snap id in dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set "                   "snap id in dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set snapcount");
gf_msg(THIS->name, GF_LOG_ERROR, 0,                       GD_MSG_BRICK_MOUNDIRS_AGGR_FAIL,                       "Failed to "                       "aggregate brick mount dirs");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_PEER_NOT_FOUND,               "Could not find peer with "               "ID %s",               uuid_utoa(*peerid));
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_PEER_NOT_FOUND,               "Could not find peer with "               "ID %s",               uuid_utoa(*peerid));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESP_AGGR_FAIL, "%s",                       "Failed to aggregate response from "                       " node/brick");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Error setting index on brick status"                   " rsp dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get "                   "opcode");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESP_AGGR_FAIL, "%s",                       "Failed to aggregate response from "                       " node/brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_LOCK_FAIL,                   "Failed to acquire lock");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESP_AGGR_FAIL, "%s",                   "Failed to aggregate response from node/brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VALIDATE_FAILED,               LOGSTR_STAGE_FAIL, gd_op_list[op], hostname,               (*op_errstr) ? ":" : " ", (*op_errstr) ? *op_errstr : " ");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GFID_VALIDATE_SET_FAIL,                   "Failed to validate and set gfid");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get "                   "opcode");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESP_AGGR_FAIL, "%s",                   "Failed to aggregate "                   "response from node/brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,               LOGSTR_COMMIT_FAIL, gd_op_list[op], hostname,               (*op_errstr) ? ":" : " ", (*op_errstr) ? *op_errstr : " ");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_UNLOCK_FAIL,               "Failed to unlock "               "on some peer(s)");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_MGMTV3_UNLOCK_FAIL,                           "Unable to release lock for %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_OP_FAIL, "%s",               (*op_errstr) ? *op_errstr                            : "Brick op failed. Check "                              "glusterd log file for more details.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RPC_FAILURE,                       "Brick Op failed "                       "due to rpc failure.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get volume "               "operation");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_IDGEN_FAIL,               "Failed to generate transaction id");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UUID_SET_FAIL,               "Failed to set originator_uuid.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_LOCK_FAIL,                   "Unable to acquire lock");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCK_GET_FAIL,                   "Unable to acquire lock for %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCK_GET_FAIL,                   "Unable to acquire lock for %s", global);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_LOCK_FAIL,                   "Locking Peers Failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_OP_PAYLOAD_BUILD_FAIL,               LOGSTR_BUILD_PAYLOAD, gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_CLEAR_FAIL,                   "Unable to clear transaction's "                   "opinfo for transaction ID : %s",                   uuid_utoa(*txn_id));
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "dict set failed for setting operations");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Failed to create volfile");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SCRUB_INIT_FAIL,                   "Failed to init "                   "scrub service");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set transaction id.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_ID_GET_FAIL,               "Empty transaction id received.");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, ENOENT, GD_MSG_FILE_OP_FAILED, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_SHARED_STORAGE_DOES_NOT_EXIST, "%s", errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_ALREADY_EXIST, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_PEER_COUNT_GET_FAIL, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INSUFFICIENT_UP_NODES, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNSUPPORTED_VERSION,                       "%s", errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Count(dict),not set in Volume-Set");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MODULE_NOT_INSTALLED,                   "libxml not present in the system");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_OPTIONS_GIVEN,               "No options received ");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,                   FMTSTR_CHECK_VOL_EXISTS, volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "invalid key,value pair in 'volume set'");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,                   "Option with name: %s does not exist", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY, "%s",                       errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VERSION_UNSUPPORTED,                       "%s", errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VERSION_UNSUPPORTED,                       "%s", errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set key-op-version in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Failed to get key-op-version from dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_VERSION_MISMATCH,                       "%s, required op-version = %" PRIu32                       ", available op-version = %" PRIu32,                       errstr, key_op_version, local_key_op_version);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_SHARED_STRG_VOL_OPT_VALIDATE_FAIL,                       "Failed to validate shared storage volume options");
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_LOCALTIME_LOGGING_VOL_OPT_VALIDATE_FAIL,                       "Failed to validate localtime logging volume options");
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_DAEMON_LOG_LEVEL_VOL_OPT_VALIDATE_FAIL,                       "Failed to validate daemon-log-level volume options");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_SET_FAIL,                       "Unable to set the options in 'volume set': %s", errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_SET_FAIL,                       "Unable to set the options in 'volume set': %s", errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_SET_FAIL,                               "Unable to set the options in 'volume set': %s",                               errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_SET_FAIL,                               "Unable to set the options in 'volume set': %s",                               errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to set the options in 'volume set'");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,                   "Could not create temp volfile, some option failed: %s",                   *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set new-op-version in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set check-op-version in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get option key");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_STAGE_RESET_VOL_FAIL,               "%s", msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_STARTED, "%s",                   msg);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_OP_STAGE_STATS_VOL_FAIL,               "%s", msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FAIL_DEFAULT_OPT_SET,                   "Failed to set "                   "default options on reset for volume %s",                   volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_FAIL_DEFAULT_OPT_SET,                   "Failed to set "                   "default value for option '%s' on reset for "                   "volume %s",                   key, volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Unable to create volfile for"               " 'volume reset'");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get key");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,                   "Option %s does not "                   "exist",                   key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get option key");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               FMTSTR_CHECK_VOL_EXISTS, volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,               "volinfo dict inconsistency: option %s not found", key);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_DISCONNECTED,                       "Failed to start %s:%s for %s", brickinfo->hostname,                       brickinfo->path, volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,                       "Failed to set "                       "option ' NFS_DISABLE_MAP_KEY ' on "                       "volume %s",                       volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, errno,                           GD_MSG_DICT_SET_FAILED,                           "failed to set transport."                           "address-family on %s",                           volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "invalid key,value pair in 'volume set'");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNKNOWN_KEY,               "Invalid key %s", key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SHARED_STRG_SET_FAIL,               "Failed to set shared storage option");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_MX_SET_FAIL,               "Failed to set brick multiplexing option");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GRACEFUL_CLEANUP_SET_FAIL,               "Failed to set brick graceful option");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_VOLFILE_CREATE_FAIL,                           "Unable to create volfile for"                           " 'volume set'");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_RESTART_FAIL,                           "Unable to restart "                           "services");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_VERS_STORE_FAIL,                       "Failed to store op-version.");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Setting value for max-opversion to dict failed");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DIR_OP_FAILED, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_CREATE_DIR_FAILED, "%s",               errstr);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Failed to set"               " hooks_args in dict.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Count(dict),not set in Volume-Set");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               FMTSTR_CHECK_VOL_EXISTS, volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to get new op-version from dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "invalid key,value pair in 'volume set'");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                       "Invalid value in key-value pair.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_SET_FAIL,                   "Unable to set the options in 'volume set'");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_OPTIONS_GIVEN,               "No options received ");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_VERS_STORE_FAIL,                   "Failed to store op-version");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,                   "Unable to create volfile for"                   " 'volume set'");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_RESTART_FAIL,                       "Unable to restart services");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,                       "Unable to create volfile for"                       " 'volume set'");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SVC_RESTART_FAIL,                           "Unable to restart services");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,                   "Volume with name: %s "                   "not exists",                   volname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set the volume %s "               "option %s value %s",               volinfo->volname, VKEY_DIAG_LAT_MEASUREMENT, "on");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "failed to set the volume %s "               "option %s value %s",               volinfo->volname, VKEY_DIAG_CNT_FOP_HITS, "on");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "volume name get failed");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "volume profile op get failed");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,                   "Invalid profile op: %d", stats_op);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Unable to create volfile for"               " 'volume set'");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get brick count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set brick count in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to get %s", brick_key);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to add brick to dict");
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_ADD_REMOVE_BRICK_FAIL,                       "Failed to add remove bricks to dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_TASK_ID,                   "%s operation doesn't have a"                   " task_id",                   gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Error setting task type in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Error setting task id in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Error setting task status in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to add task details to dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Error setting tasks count in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLNAMES_GET_FAIL,                       "failed to get all volume "                       "names for status");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Volume with name: %s "               "does not exist",               volname);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                           "failed to set peerinfo");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_CLUSTER_UNLOCK_FAILED,                           "Unlocking failed for operation"                           " volume %s on peer %s",                           gd_op_list[opinfo.op], peerinfo->hostname);
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_CLUSTER_UNLOCK_FAILED,                           "Unlocking failed for operation"                           " volume %s on peer %s",                           gd_op_list[opinfo.op], peerinfo->hostname);
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_CLUSTER_UNLOCK_FAILED,                           "Unlocking failed for operation"                           " volume %s on peer %s",                           gd_op_list[opinfo.op], peerinfo->hostname);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to acquire volname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCK_GET_FAIL,                       "Unable to acquire lock for %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_LOCK_GET_FAIL,                       "Unable to acquire lock for %s", globalname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to acquire volname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,                       "Unable to release lock for %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,                       "Unable to release lock for %s", globalname);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_OPTIONS_GIVEN,                   "Null Context for "                   "op %d",                   op);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Failed to get volume"                   " operation");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Failed to set port in "                       "dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                       "Status command not present "                       "in op ctx");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_DICT_CREATE_FAIL,               "Failed to create rsp_dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_OP_PAYLOAD_BUILD_FAIL,               LOGSTR_BUILD_PAYLOAD, gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VALIDATE_FAILED,               LOGSTR_STAGE_FAIL, gd_op_list[op], "localhost",               (op_errstr) ? ":" : " ", (op_errstr) ? op_errstr : " ");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "failed to "                       "set peerinfo");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "Error setting hostname %s to dict", hostname);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_DEFRAG_STATUS_UPDATE_FAIL,                       "Failed to reset defrag status for fix-layout");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_OP_PAYLOAD_BUILD_FAIL,               LOGSTR_BUILD_PAYLOAD, gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,               LOGSTR_COMMIT_FAIL, gd_op_list[op], "localhost",               (op_errstr) ? ":" : " ", (op_errstr) ? op_errstr : " ");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                       "failed to set peerinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNKNOWN_RESPONSE,               "unknown response received ");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RBOP_START_FAIL,                   "Couldn't start "                   "replace-brick operation.");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_MGMTV3_UNLOCK_FAIL,                       "Unable to release lock for %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NO_CLI_RESP,               "Responding to cli failed, "               "ret: %d",               ret);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_CLEAR_FAIL,               "Unable to clear transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_DICT_CREATE_FAIL,               "Failed to get new dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VALIDATE_FAILED,               "Stage failed on operation"               " 'Volume %s', Status : %d",               gd_op_list[req_ctx->op], status);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set transaction id.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COMMIT_OP_FAIL,               "Commit of operation "               "'Volume %s' failed: %d",               gd_op_list[req_ctx->op], status);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,               "Failed to set transaction id.");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,                   "Unknown op %s", gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,                   "Unknown op %s", gd_op_list[op]);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               FMTSTR_CHECK_VOL_EXISTS, volname);
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Unable to allocate memory");
gf_msg("glusterd", GF_LOG_ERROR, -ret, GD_MSG_DICT_GET_FAILED,               "Unable to get count");
gf_msg("glusterd", GF_LOG_ERROR, -ret, GD_MSG_DICT_GET_FAILED,               "Unable to get command");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to get brick");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "volume name get failed");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "volume profile op get failed");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_NFS_SERVER_NOT_RUNNING,                           "NFS server"                           " is not running");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_NFS_SERVER_NOT_RUNNING,                           "NFS server"                           " is not running");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_INVALID_ENTRY,                   "Invalid profile op: %d", stats_op);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get"               " volname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REPLICA_INDEX_GET_FAIL,                   "Could not find the "                   "replica index for per replica type command");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to"                   "set the dictionary for shd status msg");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Unable to"                   " set dictionary for shd status msg");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OPCTX_NULL,                           "Received "                           "empty ctx.");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_SHD_STATUS_SET_FAIL,                           "Unable to "                           "fill the shd status for the local "                           "bricks");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OPCTX_NULL,                           "Received "                           "empty ctx.");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_SHD_STATUS_SET_FAIL,                           "Unable to "                           "fill the shd status for the local"                           " bricks.");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "volume name get failed");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "heal op invalid");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_XLATOR_COUNT_GET_FAIL,               "Could not determine the"               "translator count");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "volume name get failed");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get status type");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get volname");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,                   "Unable to get brick");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_NFS_SERVER_NOT_RUNNING,                   "NFS server is not running");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SELF_HEALD_DISABLED,                   "Self-heal daemon is not running");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_QUOTAD_NOT_RUNNING,                   "Quotad is not "                   "running");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BITROT_NOT_RUNNING,                   "Bitrot is not "                   "running");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SCRUBBER_NOT_RUNNING,                   "Scrubber is not "                   "running");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_SNAPD_NOT_RUNNING,                   "snapd is not "                   "running");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "failed to allocate "                   "memory for pending node");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                       "Unable to allocate memory");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Unable to get"               " volname");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND, "%s",               msg);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_DICT_GET_FAILED,               "Failed to get volname");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Failed to find volume %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0,                   GD_MSG_BRICK_OP_PAYLOAD_BUILD_FAIL, LOGSTR_BUILD_PAYLOAD,                   gd_op_list[op]);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_UNKNOWN_RESPONSE,               "unknown response received ");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TRANS_OPINFO_SET_FAIL,               "Unable to set "               "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_LOCK_FAIL,               "lock failed due to %s", strerror(lock_err));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_HANDLER_RETURNED,                       "handler returned: %d", ret);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_EVENT_STATE_TRANSITION_FAIL,                       "Unable to transition"                       "state from '%s' to '%s'",                       glusterd_op_sm_state_name_get(opinfo.state.state),                       glusterd_op_sm_state_name_get(                           state[event_type].next_state));
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_TRANS_OPINFO_CLEAR_FAIL,                           "Unable to clear "                           "transaction's opinfo");
gf_msg(this->name, GF_LOG_ERROR, 0,                               GD_MSG_TRANS_OPINFO_SET_FAIL,                               "Unable to set "                               "transaction's opinfo");
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_FAILED_INIT_QUOTASVC,                   "Failed to init "                   "quotad service");
gf_msg(THIS->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                       "%s", err_str);
gf_msg(THIS->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY,                       "%s", err_str);
gf_msg(THIS->name, GF_LOG_ERROR, EINVAL,                           GD_MSG_INVALID_ENTRY, "%s", err_str);
gf_msg(THIS->name, GF_LOG_ERROR, EPERM, GD_MSG_OP_NOT_PERMITTED,                   "%s", err_str);
gf_msg(this->name, GF_LOG_ERROR, errno,                   GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLINFO_GET_FAIL, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Failed to get flag");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_REPLICA,                   "%s", err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_COUNT_VALIDATE_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "failed to set the replica-count in dict");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,                   "failed to set the new type in dict");
gf_msg(this->name, GF_LOG_ERROR, errno,                   GD_MSG_DICT_UNSERIALIZE_FAIL,                   "failed to "                   "unserialize req-buffer to dictionary");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED, "%s",               err_str);
gf_msg(this->name, GF_LOG_ERROR, EPERM, GD_MSG_OP_NOT_PERMITTED_AC_REQD,               "%s", err_str);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_INVALID_ENTRY, "%s",                   err_str);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,                   "%s", err_str);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_BRICK_NOT_FOUND,                   "%s", err_str);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_GLUSTERD_OP_FAILED, "%s",               err_str);
gf_msg("glusterd", GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                   "Failed to gf_strdup");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Unable to store secondary");
gf_msg("glusterd", GF_LOG_ERROR, 0,                   GD_MSG_SECONDARY_CONFPATH_DETAILS_FETCH_FAIL, "%s", *errmsg);
gf_msg("glusterd", GF_LOG_ERROR, 0,                   GD_MSG_SECONDARY_CONFPATH_DETAILS_FETCH_FAIL,                   "Unable to fetch secondary or confpath details.");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_GSYNC_VALIDATION_FAIL,               "gsync running validation failed.");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_GSYNC_RESTART_FAIL,               "Unable to restart gsync session.");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,                       "%s not present", key);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_STATVFS_FAILED,                       "Failed to fetch disk utilization "                       "from the brick (%s:%s). Please check the health of "                       "the brick. Error code was %s",                       brickinfo->hostname, brickinfo->path, strerror(errno));
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set "                   "performance.client-io-threads to off");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_GLUSTER_SERVICES_STOP_FAIL,                           "Failed to stop shd for %s.", volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,                       "Failed to create volfile.");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_RESOLVE_BRICK_FAIL,                       FMTSTR_RESOLVE_BRICK, brickinfo->hostname,                       brickinfo->path);
gf_msg(THIS->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_STOP_FAIL,                   "Unable to stop "                   "glusterfs, ret: %d",                   ret);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Unable to find volume: %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_VERSION_MISMATCH,                   "%s", msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_ADD_FAIL, "%s",                   msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_ADD_FAIL, "%s",                       msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_ADD_FAIL, "%s",                   msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BAD_BRKORDER,                   "Not adding brick because of "                   "bad brick order. %s",                   msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_ADD_FAIL, "%s",                       msg);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,                   "Unable to get count");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,                   "Unable to get bricks");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRKPATH_TOO_LONG, "%s",                   msg);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_NOT_FOUND,                   "Add-brick: Unable"                   " to get brickinfo");
gf_msg(this->name, GF_LOG_ERROR, 0,                           GD_MSG_BRICK_MOUNTDIR_GET_FAIL,                           "Failed to get brick mount_dir");
gf_msg(this->name, GF_LOG_ERROR, errno,                           GD_MSG_DICT_SET_FAILED, "Failed to set %s", key);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Failed to set local_brick_count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OP_VERSION_MISMATCH, "%s",               msg);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND,               "Volume %s does not exist", volname);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get brick command");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get brick count");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_USE_THE_FORCE, "%s",                       errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_STARTED,                       "%s", errstr);
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_OLD_REMOVE_BRICK_EXISTS,                       "Earlier remove-brick"                       " task exists for volume %s.",                       volinfo->volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_OIP_RETRY_LATER,                       "%s", errstr);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_TASKID_GEN_FAIL,                           "Failed to generate task-id");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg("glusterd", GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,               "Unable to allocate memory");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get count");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get bricks");
gf_msg("glusterd", GF_LOG_ERROR, 0, GD_MSG_BRICK_ADD_FAIL,               "Unable to add bricks");
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(THIS->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,               "Unable to allocate memory");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get command");
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_REMOVE_BRICK_ID_SET_FAIL,                       "Failed to set remove-brick-id");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set task-id for volume %s", volname);
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_BRICK_ADD_FAIL,               "Unable to get volume name");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, GD_MSG_VOL_NOT_FOUND,               "Unable to allocate memory");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get command");
gf_msg(this->name, GF_LOG_ERROR, 0,                       GD_MSG_REMOVE_BRICK_ID_SET_FAIL,                       "Failed to set remove-brick-id");
gf_msg("glusterd", GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Unable to get count");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,                   "Failed to save remove-brick count");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,                   "Unable to get %s", key);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, GD_MSG_NO_MEMORY,                       "Failed to duplicate brick name");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,                       "Failed to add brick to dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_DICT_SET_FAILED,                   "Failed to set "                   "performance.client-io-threads to on");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_REBALANCE_START_FAIL,                   "failed to start the rebalance");
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Volname not present in "               "dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND, "%s",               *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED, "%s",               *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED,               "Volname not present in "               "dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOL_NOT_FOUND, "%s",               *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_GET_FAILED, "%s",               *op_errstr);
gf_msg(this->name, GF_LOG_ERROR, errno, GD_MSG_DICT_SET_FAILED,               "Failed to set barrier op in"               " volume option dict");
gf_msg(this->name, GF_LOG_ERROR, 0, GD_MSG_VOLFILE_CREATE_FAIL,               "Failed to create volfiles");
gf_msg(this->name, GF_LOG_ERROR, op_errno, AFR_MSG_LK_HEAL_DOM,               "%s: Failed to acquire %s on %s",               uuid_utoa(local->fd->inode->gfid), AFR_LK_HEAL_DOM,               priv->children[i]->name);
gf_msg(this->name, GF_LOG_ERROR, op_errno, AFR_MSG_LK_HEAL_DOM,               "%s: Failed to release %s on %s", local->loc.path,               AFR_LK_HEAL_DOM, priv->children[i]->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_LK_HEAL_DOM,           "%s: Failed to add lock to healq",           uuid_utoa(local->fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_LK_HEAL_DOM,               "%s: Failed to remove lock from healq",               uuid_utoa(local->fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, AFR_MSG_LK_HEAL_DOM,               "Failed to heal lock on child %d for %s", i,               uuid_utoa(local->fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, op_errno, AFR_MSG_LK_HEAL_DOM,               "Failed getlk for %s", uuid_utoa(local->fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_LK_HEAL_DOM,                       "Event gen mismatch: skipped healing lock on child %d "                       "for %s.",                       i, uuid_utoa(info->fd->inode->gfid));
gf_msg(frame->this->name, GF_LOG_ERROR, ENOTCONN,                   AFR_MSG_LK_HEAL_DOM,                   "Aborting processing of lk_healq."                   "Healing will be reattempted on next child up for locks "                   "that are still in quorum.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, AFR_MSG_LK_HEAL_DOM,               "Failed to launch lock heal synctask");
gf_msg(this->name, GF_LOG_ERROR, 0,                   AFR_MSG_SPLIT_BRAIN_CHOICE_ERROR,                   "Failed to get inode_ctx for %s", loc->name);
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_DICT_SET_FAILED,                   "Error setting gfid-heal-msg dict");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Failed to populate thin-arbiter loc for: %s.", loc.name);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Failed to lookup/create thin-arbiter id file.");
gf_msg(this->name, GF_LOG_ERROR, op_errno, AFR_MSG_UNLOCK_FAIL,               "%s: Failed to unlock %s on %s "               "with lk_owner: %s",               uuid_utoa(gfid), gf_fop_list[local->op],               priv->children[child_index]->name,               lkowner_utoa(&frame->root->lk_owner));
gf_msg(this->name, GF_LOG_ERROR, op_errno, AFR_MSG_UNLOCK_FAIL,               "gfid=%s: unlock failed on subvolume %s "               "with lock owner %s",               uuid_utoa(local->fd->inode->gfid),               priv->children[child_index]->name,               lkowner_utoa(&frame->root->lk_owner));
gf_msg(this->name, GF_LOG_ERROR, op_errno, AFR_MSG_UNLOCK_FAIL,               "gfid=%s: unlock failed on subvolume %s "               "with lock owner %s",               uuid_utoa(local->fd->inode->gfid),               priv->children[child_index]->name,               lkowner_utoa(&frame->root->lk_owner));
gf_msg(frame->this->name, GF_LOG_ERROR, op_errno, AFR_MSG_LK_HEAL_DOM,               "%s: Lock healing supported only for replica 3 volumes.",               uuid_utoa(local->fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_TIMER_CREATE_FAIL,               "Cannot create timer for delayed initialization");
"        gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SUBVOLS_DOWN,               "All subvolumes are down. Going "               "offline until at least one of them "               "comes back up.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, AFR_MSG_THIN_ARB,               "Failed to create ta_frame");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, AFR_MSG_THIN_ARB,               "Failed to release "               "AFR_TA_DOM_NOTIFY lock.");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_INVALID_CHILD_UP,               "Received child_up from invalid subvolume");
gf_msg("TEST", GF_LOG_ERROR, -ret, AFR_MSG_DICT_GET_FAILED,                       "Failed to get the node_uuid of brick "                       "%d",                       i);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,                   "Failed to get "                   "AFR_TA_DOM_NOTIFY lock on %s.",                   loc->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Failed to get AFR_TA_DOM_MODIFY lock on %s.", loc->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Failed to unlock AFR_TA_DOM_MODIFY lock.");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Failed to unlock AFR_TA_DOM_NOTIFY lock.");
gf_msg(this->name, GF_LOG_ERROR, 0,                               AFR_MSG_DICT_SET_FAILED,                               "Error setting gfid-"                               "heal-msg dict");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, AFR_MSG_DICT_SET_FAILED,                   "Error setting dictionary");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, AFR_MSG_DICT_SET_FAILED,                   "Error setting dictionary");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,                   "Cannot set node_uuid key in dict");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,                   "Cannot set xattr cookie key");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,                   "Cannot set pathinfo key in dict");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,                   "Cannot set xattr cookie key");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,                   "Cannot set pathinfo key in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SPLIT_BRAIN_STATUS,                   "Failed to create"                   " synctask. Unable to fetch split-brain status"                   " for %s.",                   loc->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Failed to populate loc for thin-arbiter.");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Failed to unlock AFR_TA_DOM_NOTIFY lock.");
gf_msg(this->name, GF_LOG_ERROR, op_errno, AFR_MSG_THIN_ARB,           "Failing %s for gfid %s. Fop state is:%d", gf_fop_list[local->op],           uuid_utoa(local->inode->gfid), local->fop_state);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Failed to populate loc for thin-arbiter.");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Post-op on thin-arbiter id file %s failed for gfid %s.",               priv->pending_key[THIN_ARBITER_BRICK_INDEX],               uuid_utoa(local->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, EIO, AFR_MSG_THIN_ARB,               "Post-op on thin-arbiter id file %s for gfid %s invalidated due "               "to event-gen mismatch.",               priv->pending_key[THIN_ARBITER_BRICK_INDEX],               uuid_utoa(local->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, AFR_MSG_THIN_ARB,               "Failed to create ta_frame");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, AFR_MSG_THIN_ARB,               "Failed to launch post-op on thin arbiter for gfid %s",               uuid_utoa(local->inode->gfid));
gf_msg(THIS->name, GF_LOG_ERROR, 0, AFR_MSG_DICT_SET_FAILED,                   "%s/%s: Could not set %s key during xattrop",                   uuid_utoa(local->loc.pargfid), local->loc.name, key);
gf_msg(THIS->name, GF_LOG_ERROR, 0, AFR_MSG_DICT_SET_FAILED,                       "%s/%s: Could not set %s key during "                       "xattrop",                       uuid_utoa(local->newloc.pargfid), local->newloc.name,                       key);
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_INVALID_SUBVOL,                   "%s not a subvolume", read_subvol->name);
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_INVALID_SUBVOL,                   "%d not a subvolume-index", index);
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_CHILD_MISCONFIGURED,               "replicate translator needs more than one "               "subvolume defined.");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_INVALID_SUBVOL,                   "%s not a subvolume", read_subvol->name);
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_INVALID_SUBVOL,                   "%d not a subvolume-index", read_subvol_index);
gf_msg(this->name, GF_LOG_ERROR, ENOSYS,                       AFR_MSG_LOCK_XLATOR_NOT_LOADED,                       "subvolume does not support locking. "                       "please load features/locks xlator on server");
gf_msg(this->name, GF_LOG_ERROR, ENOSYS,                       AFR_MSG_LOCK_XLATOR_NOT_LOADED,                       "subvolume does not support "                       "locking. please load features/locks"                       " xlator on server");
gf_msg(this->name, GF_LOG_ERROR, op_errno, AFR_MSG_LK_HEAL_DOM,               "Failed getlk for %s", uuid_utoa(local->fd->inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_GET_FAILED,                       "Failed to get whether reopen is allowed or not on fd "                       "for file %s on subvolume %s.",                       local->loc.path, priv->children[i]->name);
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SELF_HEAL_FAILED,               "Invalid ia_type (%d) or gfid(%s). source brick=%d, "               "pargfid=%s, name=%s",               iatt->ia_type, iatt_uuid_str, source,               uuid_utoa_r(dir->gfid, dir_uuid_str), name);
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SPLIT_BRAIN,                       "Skipping conservative merge on the "                       "file.");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SPLIT_BRAIN,                   "Type mismatch detected "                   "for <gfid:%s>/%s>, %s on %s and %s on %s. "                   "Skipping conservative merge on the file.",                   uuid_utoa(pargfid), bname,                   gf_inode_type_to_str(replies[i].poststat.ia_type),                   priv->children[i]->name,                   gf_inode_type_to_str(replies[src_idx].poststat.ia_type),                   priv->children[src_idx]->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Failed lookup on file %s.", loc->name);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, AFR_MSG_DICT_GET_FAILED,               "Failed to create dict.");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Xattrop failed on %s.", loc->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Failed to populate thin-arbiter loc for: %s.", loc->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_GET_FAILED,                   "Error getting value "                   "of pending key %s",                   priv->pending_key[i]);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Xattrop failed.");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Failed to populate thin-arbiter loc for: %s.", loc.name);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_GET_FAILED,               "xl does not have id");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,               "Could not add statistics_healed_count to output");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,               "Could not add statistics_split_brain_count to output");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,               "Could not add statistics_crawl_type to output");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,               "Could not add statistics_healed_failed_count to output");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,               "Could not add statistics_crawl_start_time to output");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,               "Could not add statistics_crawl_end_time to output");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,               "Could not add statistics_inprogress to output");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,               "Could not increment the counter.");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_GET_FAILED,               "xl does not have id");
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,               "%s: Could not add to output", path);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,                   "%s: Could not set time", path);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_DICT_SET_FAILED,               "Could not increment count");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SPLIT_BRAIN,               "All the bricks should be up to resolve the gfid split "               "barin");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_DICT_SET_FAILED,                       "Error setting"                       " gfid-heal-msg dict");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SPLIT_BRAIN,                       SNO_BIGGER_FILE);
gf_msg(this->name, GF_LOG_ERROR, 0,                               AFR_MSG_DICT_SET_FAILED,                               "Error"                               " setting gfid-heal-msg dict");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SPLIT_BRAIN,                       SNO_DIFF_IN_MTIME);
gf_msg(this->name, GF_LOG_ERROR, 0,                               AFR_MSG_DICT_SET_FAILED,                               "Error"                               "setting gfid-heal-msg dict");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SPLIT_BRAIN,                       "Error getting the source "                       "brick");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SPLIT_BRAIN,                       SERROR_GETTING_SRC_BRICK);
gf_msg(this->name, GF_LOG_ERROR, 0,                               AFR_MSG_DICT_SET_FAILED,                               "Error"                               " setting gfid-heal-msg dict");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SPLIT_BRAIN,                       "No majority to resolve "                       "gfid split brain");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SPLIT_BRAIN,               "Gfid mismatch detected for <gfid:%s>/%s>, %s on %s and"               " %s on %s.",               uuid_utoa(pargfid), bname,               uuid_utoa_r(replies[child_idx].poststat.ia_gfid, g1),               priv->children[child_idx]->name,               uuid_utoa_r(replies[src_idx].poststat.ia_gfid, g2),               priv->children[src_idx]->name);
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SBRAIN_FAV_CHILD_POLICY,                   "Cannot perform selfheal on %s. "                   "Size policy is not applicable to directories.",                   uuid_utoa(inode->gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SPLIT_BRAIN,               "No bigger file");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SBRAIN_FAV_CHILD_POLICY,               "No child selected by favorite-child policy.");
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SBRAIN_FAV_CHILD_POLICY,               "Invalid child (%d) "               "selected by policy %s.",               fav_child, policy_str);
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_SPLIT_BRAIN,                   "TYPE mismatch %d vs %d on %s for gfid:%s",                   (int)first.ia_type, (int)replies[i].poststat.ia_type,                   priv->children[i]->name,                   uuid_utoa(replies[i].poststat.ia_gfid));
gf_msg(this->name, GF_LOG_ERROR, 0, AFR_MSG_INVALID_DATA,                       "%s has gfid: %s", priv->anon_inode_name,                       uuid_utoa(local->replies[i].poststat.ia_gfid));
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Failed xattrop for gfid %s on %s",               uuid_utoa(local->inode->gfid),               priv->children[query_child]->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "Failed to populate thin-arbiter loc for: %s.", loc.name);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "gfid:%s: Failed to get AFR_TA_DOM_MODIFY lock on %s.",               uuid_utoa(local->inode->gfid),               priv->pending_key[THIN_ARBITER_BRICK_INDEX]);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "gfid:%s: Failed xattrop on %s.", uuid_utoa(local->inode->gfid),               priv->pending_key[THIN_ARBITER_BRICK_INDEX]);
gf_msg(this->name, GF_LOG_ERROR, EIO, AFR_MSG_THIN_ARB,               "Failing read for gfid %s since good brick %s is down",               uuid_utoa(local->inode->gfid),               priv->children[possible_bad_child]->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, AFR_MSG_THIN_ARB,               "gfid:%s: Failed to unlock AFR_TA_DOM_MODIFY lock on "               "%s.",               uuid_utoa(local->inode->gfid),               priv->pending_key[THIN_ARBITER_BRICK_INDEX]);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, AFR_MSG_THIN_ARB,               "Failed to create ta_frame");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, AFR_MSG_THIN_ARB,               "Failed to launch "               "afr_ta_read_txn synctask for gfid %s.",               uuid_utoa(local->inode->gfid));
gf_msg(fop->xl->name, GF_LOG_ERROR, 0, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,               "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, EBADF, EC_MSG_FD_BAD,                   "Failing %s on %s", gf_fop_list[GF_FOP_FLUSH],                   fd->inode ? uuid_utoa(fd->inode->gfid) : "");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, EBADF, EC_MSG_FD_BAD,                   "Failing %s on %s", gf_fop_list[GF_FOP_FSYNC],                   fd->inode ? uuid_utoa(fd->inode->gfid) : "");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_INODE_REF_FAIL,                           "Failed to reference an inode.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, ENOMEM,                           EC_MSG_LOOKUP_REQ_PREP_FAIL,                           "Unable to prepare "                           "lookup request");
gf_msg(fop->xl->name, GF_LOG_ERROR, -err,                       EC_MSG_LOOKUP_REQ_PREP_FAIL,                       "Unable to prepare lookup "                       "request");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, 0,                           EC_MSG_FILE_DESC_REF_FAIL,                           "Failed to reference a "                           "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, EC_MSG_INVALID_REQUEST,               "Invalid index %d in readdirp request", client_id);
gf_msg(fop->xl->name, GF_LOG_ERROR, fop->error,                       EC_MSG_INVALID_REQUEST, "EC is not winding readdir: %s",                       ec_msg_str(fop));
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, EC_MSG_INVALID_REDUNDANCY,               "Invalid redundancy (must be between "               "1 and %d)",               (ec->nodes - 1) / 2);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, EC_MSG_TOO_MANY_SUBVOLS,               "Too many subvolumes");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,               "Allocation of xlator list failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,               "Memory accounting initialization "               "failed.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_TIMER_CREATE_FAIL,               "Cannot create timer "               "for delayed initialization");
gf_msg(ec->xl->name, GF_LOG_ERROR, 0, EC_MSG_XLATOR_INIT_FAIL,                   "In read-mask \"%s\" id %s is not a valid integer",                   read_mask_str, id_str);
gf_msg(ec->xl->name, GF_LOG_ERROR, 0, EC_MSG_XLATOR_INIT_FAIL,                   "In read-mask \"%s\" id %d is not in range [0 - %d]",                   read_mask_str, id, ec->nodes - 1);
gf_msg(ec->xl->name, GF_LOG_ERROR, 0, EC_MSG_XLATOR_INIT_FAIL,               "read-mask \"%s\" should contain at least %d ids", read_mask_str,               ec->fragments);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,               "Failed to allocate private memory.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,               "Failed to create memory pools.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_XLATOR_INIT_FAIL,               "Failed to initialize xlator");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, EC_MSG_XLATOR_PARSE_OPT_FAIL,               "Failed to parse xlator options");
gf_msg(this->name, GF_LOG_ERROR, -err, EC_MSG_MATRIX_FAILED,               "Failed to initialize matrix management");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_SUBVOL_BUILD_FAIL,               "Failed to build subvol "               "dictionary");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_SUBVOL_ID_DICT_SET_FAIL,               "Failed to build subvol-id "               "dictionary");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                           "Failed to reference a "                           "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Failed to duplicate a string.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                           "Failed to reference a "                           "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Failed to duplicate a string.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0,                           EC_MSG_FILE_DESC_REF_FAIL,                           "Failed to reference a "                           "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                           "Failed to duplicate a "                           "vector list.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_BUF_REF_FAIL,                           "Failed to reference a "                           "buffer.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, 0, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, EC_MSG_XLATOR_MISMATCH,               "Mismatching xlators between request "               "and answer (req=%s, ans=%s).",               fop->xl->name, this->name);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, EC_MSG_FRAME_MISMATCH,               "Mismatching frames between request "               "and answer (req=%p, ans=%p).",               fop->frame, frame);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, EC_MSG_FOP_MISMATCH,               "Mismatching fops between request "               "and answer (req=%d, ans=%d).",               fop->id, id);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,               "Failed to allocate memory for an "               "answer.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,               "Failed to allocate memory for a "               "request.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,               "Failed to create a private frame "               "for a request");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_INVALID_INODE,               "Trying to lock based on an invalid "               "inode");
gf_msg(xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_INVALID_CONFIG,                   "Invalid or corrupted config");
gf_msg(xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_INVALID_CONFIG,                   "Unsupported config "                   "(V=%u, A=%u, W=%u, "                   "N=%u, R=%u, S=%u)",                   config->version, config->algorithm, config->gf_word_size,                   config->bricks, config->redundancy, config->chunk_size);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                   EC_MSG_VER_XATTR_GET_FAIL, "Unable to get version xattr. %s",                   ec_msg_str(fop));
gf_msg(this->name, GF_LOG_ERROR, op_errno,                           EC_MSG_SIZE_XATTR_GET_FAIL,                           "Unable to get size xattr. %s", ec_msg_str(fop));
gf_msg(this->name, GF_LOG_ERROR, op_errno,                           EC_MSG_CONFIG_XATTR_GET_FAIL,                           "Unable to get config xattr. %s", ec_msg_str(fop));
gf_msg(this->name, GF_LOG_ERROR, EINVAL,                           EC_MSG_CONFIG_XATTR_INVALID, "Invalid config xattr");
gf_msg(fop->xl->name, GF_LOG_ERROR, -err, EC_MSG_SIZE_VERS_UPDATE_FAIL,           "Unable to update version and size. %s", ec_msg_str(fop));
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Failed to duplicate a string.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg("ec", GF_LOG_ERROR, EINVAL, EC_MSG_UNSUPPORTED_VERSION,               "Trying to store an unsupported config "               "version (%u)",               config->version);
gf_msg("ec", GF_LOG_ERROR, EINVAL, EC_MSG_UNSUPPORTED_VERSION,               "Found an unsupported config version (%u)", config->version);
gf_msg(xl->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                       "Unable to duplicate path '%s'", loc->path);
gf_msg(xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_INVALID_LOC_NAME,                       "Invalid name '%s' in loc", loc->name);
gf_msg(xl->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Unable to duplicate path '%s'", loc->path);
gf_msg(xl->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Unable to duplicate path '%s'", dirname(str));
gf_msg(xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_LOC_PARENT_INODE_MISSING,               "Parent inode missing for loc_t");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Failed to duplicate a string.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Failed to duplicate a string.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Failed to duplicate a "                   "vector list.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_BUF_REF_FAIL,                   "Failed to reference a "                   "buffer.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(THIS->name, GF_LOG_ERROR, err, EC_MSG_DYN_CREATE_FAILED,               "Unable to create a temporary file for the ec dynamic "               "code");
gf_msg(THIS->name, GF_LOG_ERROR, err, EC_MSG_DYN_CREATE_FAILED,               "Unable to resize the file for the ec dynamic code");
gf_msg(THIS->name, GF_LOG_ERROR, err, EC_MSG_DYN_CREATE_FAILED,               "Unable to map the executable area for the ec dynamic "               "code");
gf_msg(THIS->name, GF_LOG_ERROR, err, EC_MSG_DYN_CREATE_FAILED,               "Unable to map the writable area for the ec dynamic "               "code");
gf_msg(THIS->name, GF_LOG_ERROR, error, EC_MSG_DYN_CODEGEN_FAILED,               "Failed to generate dynamic code");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Failed to duplicate a string.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Failed to duplicate a string.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Failed to duplicate a string.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Failed to duplicate a string.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Failed to duplicate a string.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_LOC_COPY_FAIL,                   "Failed to copy a location.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, EC_MSG_NO_MEMORY,                   "Failed to duplicate a string.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                       "Failed to reference a "                       "dictionary.");
gf_msg(fop->xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_UNHANDLED_STATE,                   "Unhandled state %d for %s", state, ec_fop_name(fop->id));
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_FILE_DESC_REF_FAIL,                   "Failed to reference a "                   "file descriptor.");
gf_msg(this->name, GF_LOG_ERROR, 0, EC_MSG_DICT_REF_FAIL,                   "Failed to reference a "                   "dictionary.");
gf_msg(xl->name, GF_LOG_ERROR, EINVAL, EC_MSG_INVALID_FORMAT,           "Invalid concat format");
gf_msg(cbk->fop->xl->name, GF_LOG_ERROR, -err,                   EC_MSG_STIME_COMBINE_FAIL, "STIME combination failed");
gf_msg(cbk->fop->xl->name, GF_LOG_ERROR, -err,                   EC_MSG_DICT_COMBINE_FAIL, "Dictionary combination failed");
gf_msg(this->name, GF_LOG_ERROR, DHT_MSG_NO_MEMORY, ENOMEM,                       "insufficient memory");
gf_msg(this->name, GF_LOG_ERROR, DHT_MSG_DICT_SET_FAILED, 0,                   "Failed to set key %s in dictionary",                   GF_PROTECT_FROM_EXTERNAL_WRITES);
gf_msg(this->name, GF_LOG_ERROR, 0,                   DHT_MSG_HASHED_SUBVOL_GET_FAILED,                   "Failed to get mds subvol for path %s", local->loc.path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_SET_INODE_CTX_FAILED,                   "Failed to set hashed subvol for %s on inode vol is %s",                   local->loc.path,                   local->hashed_subvol ? local->hashed_subvol->name : "NULL");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_FILE_TYPE_MISMATCH,               "path %s exists as a file on one subvolume "               "and directory on another. "               "Please fix it manually",               local->loc.path);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                       DHT_MSG_DIR_XATTR_HEAL_FAILED,                       "xattr heal failed for "                       "directory  gfid is %s ",                       gfid_local);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_SET_INODE_CTX_FAILED,                   "Failed to set mds subvol on inode ctx"                   " %s for %s ",                   prev->name, local->loc.path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,                   "dict_new failed");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_SET_INODE_CTX_FAILED,                   "Failed to set hashed subvol for %s vol is %s",                   local->loc.path, prev->name);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DIR_XATTR_HEAL_FAILED,               "No gfid exists for path %s "               "so healing xattr is not possible",               local->loc.path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM,                   DHT_MSG_DIR_XATTR_HEAL_FAILED,                   "Memory allocation failed "                   "for path %s gfid %s ",                   local->loc.path, gfid_local);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM,                       DHT_MSG_DIR_XATTR_HEAL_FAILED,                       "Synctask creation failed to heal xattr "                       "for path %s gfid %s ",                       local->loc.path, gfid_local);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_SET_INODE_CTX_FAILED,                   "%s: Failed to set mds (%s)", local->loc.path, prev->name);
gf_msg(this->name, GF_LOG_ERROR, 0,                           DHT_MSG_SET_INODE_CTX_FAILED,                           "Failed to set MDS subvol for %s vol is %s",                           local->loc.path, prev->name);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                       DHT_MSG_UNLINK_FAILED,                       "Could not unlink the linkto file as "                       "either fd is open and/or linkto xattr "                       "is set for %s",                       ((path == NULL) ? "null" : path));
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_FILE_TYPE_MISMATCH,               "path %s (gfid = %s)exists as a file on one "               "subvolume and directory on another. "               "Please fix it manually",               local->loc.path, gfid);
gf_msg(this->name, GF_LOG_ERROR, DHT_MSG_NO_MEMORY, 0,                       "dictionary creation failed");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,                       "dictionary set array failed ");
gf_msg(this->name, GF_LOG_ERROR, op_errno, DHT_MSG_GET_XATTR_FAILED,               "Subvolume %s returned -1", this->name);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                       DHT_MSG_GET_XATTR_FAILED, "failed to get node-uuid");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_GET_FAILED,                   "Failed to get %s", local->xsel);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_UUID_PARSE_ERROR,                       "Failed to parse uuid for %s", prev->name);
gf_msg(this->name, GF_LOG_ERROR, op_errno,                       DHT_MSG_GET_XATTR_FAILED, "getxattr err for dir");
gf_msg(this->name, GF_LOG_ERROR, op_errno, DHT_MSG_DICT_SET_FAILED,                   "alloc or fill failure");
gf_msg(this->name, GF_LOG_ERROR, op_errno, DHT_MSG_GET_XATTR_FAILED,               "vgetxattr: Subvolume %s returned -1", prev->name);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_NO_MEMORY,               "Allocation or fill failure");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_LAYOUT_NULL,               "Layout is NULL");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_NO_MEMORY,                   "Failed to copy node uuid key");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_NO_MEMORY,                   "Failed to copy node uuid key");
gf_msg(this->name, GF_LOG_ERROR, 0,                   DHT_MSG_HASHED_SUBVOL_GET_FAILED,                   "Failed to get hashed subvol for %s", loc->path);
gf_msg(this->name, GF_LOG_ERROR, 0,                   DHT_MSG_CACHED_SUBVOL_GET_FAILED,                   "Failed to get cached subvol for %s", loc->path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_LAYOUT_NULL,               "Layout is NULL");
gf_msg(this->name, GF_LOG_ERROR, 0,                   DHT_MSG_HASHED_SUBVOL_GET_FAILED,                   "cannot determine MDS, fetching xattr %s "                   " randomly from a subvol for gfid %s ",                   key, gfid);
gf_msg(this->name, GF_LOG_ERROR, 0,                   DHT_MSG_HASHED_SUBVOL_GET_FAILED,                   "Failed to get mds subvol for fd %p"                   "gfid is %s ",                   fd, gfid_local);
gf_msg(this->name, GF_LOG_ERROR, 0,                   DHT_MSG_HASHED_SUBVOL_GET_FAILED,                   "%s: Failed to get mds subvol. (gfid is %s)", loc->path,                   gfid_local);
gf_msg(this->name, GF_LOG_ERROR, DHT_MSG_NO_MEMORY, 0,                   "dictionary creation failed for path %s "                   "for gfid is %s ",                   local->loc.path, gfid_local);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,                   "dictionary set array failed for path %s "                   "for gfid is %s ",                   local->loc.path, gfid_local);
gf_msg(this->name, GF_LOG_ERROR, 0,                   DHT_MSG_HASHED_SUBVOL_GET_FAILED,                   "Failed to get hashed subvol for %s", loc->path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_REBALANCE_START_FAILED,                   "%s: failed to create a new rebalance synctask", loc->path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_OPERATION_NOT_SUP,               "wrong 'directory-spread-count' value (%s)", value);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_DICT_SET_FAILED,                   "Failed to "                   "set dictionary key %s for %s",                   DHT_IATT_IN_XDATA_KEY, loc->path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_DICT_SET_FAILED,                   "Failed to "                   "set dictionary key %s for fd=%p",                   DHT_IATT_IN_XDATA_KEY, fd);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,                           "Failed to set dictionary"                           " value :key = %s, ret:%d",                           GF_READDIR_SKIP_DIRS, ret);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,                           "Failed to set dictionary value"                           ":key = %s",                           GF_READDIR_SKIP_DIRS);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,                       "Memory allocation failed ");
gf_msg(this->name, GF_LOG_ERROR, 0,                               DHT_MSG_DICT_SET_FAILED,                               "Failed to set "                               "dictionary value: "                               "key = %s",                               GF_READDIR_SKIP_DIRS);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_HASHED_SUBVOL_GET_FAILED,               "no subvolume in "               "layout for path=%s",               local->loc.path);
gf_msg("DHT", GF_LOG_ERROR, 0, DHT_MSG_INODE_LK_ERROR,               "mknod lock failed for file: %s", local->loc2.name);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,               "mem allocation failed for refresh_frame");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,               "mem allocation failed for refresh_local");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,                           "loc_copy failed %s", loc->path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_LOC_FAILED,                           "parent loc build failed");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_INODE_LK_ERROR,                           "locking parent failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,                       "loc_copy failed %s", local->loc.path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_LOC_FAILED,                       "parent loc build failed");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_INODE_LK_ERROR,                       "locking parent failed");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_HASHED_SUBVOL_GET_FAILED,               "no subvolume in "               "layout for path=%s",               local->loc.path);
gf_msg("DHT", GF_LOG_ERROR, 0, DHT_MSG_INODE_LK_ERROR,               "Create lock failed for file: %s", local->loc2.name);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_HASHED_SUBVOL_GET_FAILED,               "no subvolume in layout for path=%s", loc->path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,                           "loc_copy failed %s", loc->path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_LOC_FAILED,                           "parent loc build failed");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_INODE_LK_ERROR,                           "locking parent failed");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_SET_INODE_CTX_FAILED,               "Failed to set hashed subvol for %s on inode vol is %s",               local->loc.path, hashed_subvol->name);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,               "dict_new failed");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,               "Failed to set dictionary value: key = %s",               conf->link_xattr_name);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,               "dict_new failed");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,               "Failed to set dictionary value: key = %s",               conf->link_xattr_name);
gf_msg(this->name, GF_LOG_ERROR, 0, 0, "%s: failed to set key %s",                   loc->path, conf->link_xattr_name);
gf_msg(this->name, GF_LOG_ERROR, 0, 0, "%s: failed to set key %s",               loc->path, conf->link_xattr_name);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,                   "Failed to set " GF_INTERNAL_IGNORE_DEEM_STATFS " in dict");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_NO_MEMORY,               "Memory accounting init failed");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_INVALID_OPTION,                       "Invalid option: Reconfigure: "                       "rebal-throttle should be "                       "within range of 0 and maximum number of"                       " cores available");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_INVALID_OPTION,                   "Invalid option: Reconfigure: "                   "rebal-throttle should be {lazy|normal|aggressive}"                   " or a number up to the number of cores available,"                   " not (%s), defaulting to (%d)",                   temp_str, conf->dthrottle);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_INVALID_OPTION,                       "Invalid option: Reconfigure: "                       "lookup-unhashed should be boolean,"                       " not (%s), defaulting to (%d)",                       temp_str, conf->search_unhashed);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_INVALID_OPTION,                   "Invalid option. Defrag pattern:"                   " Invalid number format \"%s\"",                   num);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_INVALID_CONFIGURATION,                   "Invalid volume configuration: "                   "node-uuid not specified");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_INVALID_OPTION,                   "Invalid option:"                   " Cannot parse glusterd node uuid");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_INVALID_OPTION,                       "Invalid option:"                       " Cannot parse rebalance-filter (%s)",                       temp_str);
gf_msg(this->name, GF_LOG_ERROR, 0,                   DHT_MSG_INIT_LOCAL_SUBVOL_FAILED,                   "dht_init_local_subvolumes failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,               " DHT initialisation failed. "               "failed to create local_t's memory pool");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_INIT_FAILED,               "failed to create lock mem_pool, failing "               "initialization");
gf_msg(this->name, GF_LOG_ERROR, 0,                   DHT_MSG_SET_SWITCH_PATTERN_ERROR, "Pattern (%s) too long",                   pattern);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_SUBVOL_ERROR,                           "%s is not a subvolume of %s. "                           "pattern can only be scheduled "                           "only to a subvolume of %s",                           child, this->name, this->name);
gf_msg("switch", GF_LOG_ERROR, 0, DHT_MSG_SET_SWITCH_PATTERN_ERROR,                   "Check \"scheduler.switch.case\" "                   "option in unify volume. Exiting");
gf_msg("switch", GF_LOG_ERROR, 0, DHT_MSG_SET_SWITCH_PATTERN_ERROR,                   "No nodes left for pattern '*'. Exiting");
gf_msg("", GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed :"               "loc->pargfid is NULL for %s",               loc->path);
gf_msg("", GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed :"               "loc->gfid is NULL for %s",               loc->path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,               "could not allocate memory for dict");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed:"               "%s: failed to set 'linkto' key in dict",               loc->path);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed:%s lookup failed with ret = %d", loc->path,               ret);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed :"               "Failed to get cached subvol"               " for %s on %s",               loc->name, this->name);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed :"               "Failed to get hashed subvol"               " for %s on %s",               loc->name, this->name);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,                   "Migrate file failed :"                   "Failed to set dictionary value:"                   " key = %s for %s",                   conf->link_xattr_name, loc->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,                   "Migrate file failed :"                   "Linkto setxattr failed %s -> %s",                   cached_subvol->name, loc->name);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_SUBVOL_ERROR,                   "Failed to get "                   "linkto subvol for %s",                   loc->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed :Failed lookup %s on %s ", loc->name,               hashed_subvol->name);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,               "dictionary allocation failed for"               "path:%s",               loc->path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,               "%s: failed to set dictionary value: key = gfid-req", loc->path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,               "%s: failed to set dictionary value: key = %s ", loc->path,               conf->link_xattr_name);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_MIGRATE_FILE_FAILED,               "%s: fd create failed (destination)", loc->path);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_MIGRATE_FILE_FAILED,               "%s: dict_new failed)", loc->path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,               "%s: failed to set dictionary value: key = %s ", loc->path,               GF_CLEAN_WRITE_PROTECTION);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_GFID_MISMATCH,                   "file %s exists in %s with different gfid", loc->path,                   to->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,                   "failed to open %s on %s", loc->path, to->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,                   "failed to create %s on %s", loc->path, to->name);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_GFID_MISMATCH,                   "file %s exists in %s with different gfid,"                   "found in lookup after create",                   loc->path, to->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,               "%s: file does not exist"               "on %s",               loc->path, to->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,               "chown failed for %s on %s", loc->path, to->name);
gf_msg(this->name, GF_LOG_ERROR, -ret,                           DHT_MSG_MIGRATE_FILE_FAILED,                           "fallocate failed for %s on %s", loc->path,                           to->name);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,               "failed to allocate dictionary");
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,               "failed to get statfs of %s on %s", loc->path, from->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,               "failed to get statfs of %s on %s", loc->path, to->name);
gf_msg("dht", GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,                           "insufficient memory");
gf_msg("dht", GF_LOG_ERROR, 0, ENOMEM,                           "failed to set dict");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,               "%s: fd create failed (source)", loc->path);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,               "failed to open file %s on %s", loc->path, from->name);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,               "%s: Could not allocate memory for dict", loc->path);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,               "failed to set xattr on %s in %s", loc->path, from->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,               "failed to set mode on %s in %s", loc->path, from->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file cleanup failed: failed to fstat "               "file %s on %s ",               loc->path, from->name);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, DHT_MSG_NO_MEMORY,               "Could not allocate memory for dict");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed:"               "%s: failed to set 'linkto' key in dict",               loc->path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,                   "Migrate file failed: %s: failed to "                   "set " GLUSTERFS_POSIXLK_COUNT " key in dict",                   loc->path);
gf_msg(this->name, GF_LOG_ERROR, *fop_errno,               DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed:"               "%s: lookup failed on %s",               loc->path, cached_subvol->name);
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "Create dst failed"               " on - %s for file - %s",               hashed_subvol->name, loc->path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_SUBVOL_INSUFF_SPACE,                   "Exiting migration for"                   " file - %s. flag - %d, stbuf.ia_nlink - %d",                   loc->path, flag, stbuf.ia_nlink);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed: failed to open %s on %s", loc->path,               cached_subvol->name);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed:failed to lookup %s on %s ", loc->path,               cached_subvol->name);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed: %s: failed to migrate data", loc->path);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed: failed to fstat file %s on %s ", loc->path,               cached_subvol->name);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,                   "dict_new failed");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,                   "Failed to set dictionary value: key = %s,"                   " path = %s",                   GLUSTERFS_INTERNAL_FOP_KEY, loc->path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,                   "Trace dict_set failed");
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,                   "Trace syncop_setxattr metalock failed");
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,                   "Migrate file failed:"                   "%s: Failed to lock on %s",                   loc->path, cached_subvol->name);
gf_msg(this->name, GF_LOG_ERROR, -ret,                       DHT_MSG_LOCK_MIGRATION_FAILED, "write lock failed on:%s",                       loc->path);
gf_msg(this->name, GF_LOG_ERROR, -ret,                   DHT_MSG_LOCK_MIGRATION_FAILED,                   "getactivelk failed for file: %s", loc->path);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,                   "failed to set xattr on %s in %s", loc->path,                   old_target->name);
gf_msg(this->name, GF_LOG_ERROR, errno,                       DHT_MSG_MIGRATE_FILE_FAILED, "%s: fd create failed",                       loc->path);
gf_msg(this->name, GF_LOG_ERROR, -ret,                       DHT_MSG_MIGRATE_FILE_FAILED,                       "failed to create linkto file on %s in %s", loc->path,                       old_target->name);
gf_msg(this->name, GF_LOG_ERROR, -ret,                           DHT_MSG_MIGRATE_FILE_FAILED,                           "chown failed for %s on %s", loc->path,                           old_target->name);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,                   "Trace dict_set failed");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_MIGRATE_FILE_FAILED,                   "Trace dict_set failed");
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,                   "Trace syncop_setxattr meta unlock failed");
gf_msg(this->name, GF_LOG_ERROR, -lk_ret,                   DHT_MSG_MIGRATE_FILE_FAILED,                   "Migrate file failed: "                   "%s: failed to reset target size back to 0",                   loc->path);
gf_msg(this->name, GF_LOG_ERROR, errno, DHT_MSG_SOCKET_ERROR,               "Failed to unlink listener "               "socket %s",               cmd_args->sock_file);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_MIGRATE_FILE_FAILED,               "Migrate file failed: %s lookup failed", entry_loc.path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_HASHED_SUBVOL_GET_FAILED,               "Failed to get hashed subvol for %s", entry_loc.path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_CACHED_SUBVOL_GET_FAILED,               "Failed to get cached subvol for %s", entry_loc.path);
gf_msg(this->name, GF_LOG_ERROR, DHT_MSG_NO_MEMORY, ENOMEM,               "Insufficient memory. Frame creation failed");
gf_msg(this->name, GF_LOG_ERROR, fop_errno,                   DHT_MSG_MIGRATE_FILE_FAILED, "migrate-data failed for %s",                   entry_loc.path);
gf_msg(this->name, GF_LOG_ERROR, fop_errno,                   DHT_MSG_MIGRATE_FILE_FAILED,                   "migrate-data on %s failed:", entry_loc.path);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_LAYOUT_FIX_FAILED,               "fix layout on %s failed", loc->path);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_DIR_LOOKUP_FAILED,                   "lookup failed for:%s", loc->path);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_READDIR_ERROR,                   "readdirp failed for "                   "path %s. Aborting fix-layout",                   loc->path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_LAYOUT_FIX_FAILED,                       "Fix layout failed for %s", entry_loc.path);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_LAYOUT_FIX_FAILED,                   "Setxattr failed for %s", loc->path);
gf_msg(this->name, GF_LOG_ERROR, 0,                       DHT_MSG_DEFRAG_PROCESS_DIR_FAILED,                       "gf_defrag_process_dir failed for "                       "directory: %s",                       loc->path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_SETTLE_HASH_FAILED,               "Settle hash failed for %s", loc->path);
gf_msg(this->name, GF_LOG_ERROR, -ret, 0,               "local "               "subvolume determination failed with error: %d",               -ret);
gf_msg(this->name, GF_LOG_ERROR, -ret, 0,               "local "               "subvolume determination failed with error: %d",               -ret);
gf_msg("dht", GF_LOG_ERROR, 0, 0,                   "Failed to get "                   "the total data size. Unable to estimate "                   "time to complete rebalance.");
gf_msg("dht", GF_LOG_ERROR, ret, 0,               "file_counter_thread: pthread_join failed.");
gf_msg(this->name, GF_LOG_ERROR, 0, 0,               "Failed to get "               "the total data size. Unable to estimate "               "time to complete rebalance.");
gf_msg(this->name, GF_LOG_ERROR, ret, 0,               "Failed to "               "create the file counter thread ");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0,               "Failed to initialise migration queue");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, 0,               "Failed to create migration threads");
gf_msg("DHT", GF_LOG_ERROR, ret, 0, "Thread[%d] creation failed. ",                   index);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_REBALANCE_START_FAILED,               "Failed to start rebalance: look up on / failed");
gf_msg(this->name, GF_LOG_ERROR, DHT_MSG_NO_MEMORY, ENOMEM,               "Insufficient memory. Frame creation failed");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_REBALANCE_START_FAILED,               "Failed to start rebalance:"               "Failed to set dictionary value: key = %s",               GF_XATTR_FIX_LAYOUT_KEY);
gf_msg(this->name, GF_LOG_ERROR, -ret, DHT_MSG_REBALANCE_FAILED,               "fix layout on %s failed", loc.path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_REBALANCE_START_FAILED,               "Could not create task for rebalance");
gf_msg(THIS->name, GF_LOG_ERROR, 0, 0,               "Unable to calculate estimated time for rebalance");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,                   "Failed to set dict value.");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,                   "Failed to set dict value.");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,                   "Failed to set dict value.");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_BRICK_ERROR,               "Couldn't find a local "               "brick");
gf_msg(frame->this->name, GF_LOG_ERROR, ENOMEM, 0,                   "Insufficient memory for src");
gf_msg(frame->this->name, GF_LOG_ERROR, ENOMEM, 0,                   "Insufficient memory for dst");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,               "Failed to calloc memory");
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,               "Failed to set dictionary value: key = %s,"               " path = %s",               DHT_CHANGELOG_RENAME_OP_KEY, oldloc->name);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,       \                   "Failed to set dictionary value: key = %s,"                 \                   " path = %s",                                               \                   GLUSTERFS_MARKER_DONT_ACCOUNT_KEY, local->loc.path);
\                gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,   \                       "Failed to create dictionary to "                       \                       "track rename");
\            gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_DICT_SET_FAILED,       \                   "Failed to set dictionary value: key = %s,"                 \                   " path = %s",                                               \                   DHT_CHANGELOG_RENAME_OP_KEY, (oldloc)->path);
gf_msg(this->name, GF_LOG_ERROR, 0, DHT_MSG_INVALID_VALUE,               "!local, should not happen");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, WRITE_BEHIND_MSG_NO_MEMORY,               "Memory accounting init"               "failed");
gf_msg(this->name, GF_LOG_ERROR, 0, WRITE_BEHIND_MSG_INIT_FAILED,               "FATAL: write-behind (%s) not configured with exactly "               "one child",               this->name);
gf_msg(this->name, GF_LOG_ERROR, 0, WRITE_BEHIND_MSG_EXCEEDED_MAX_SIZE,               "aggregate-size(%" PRIu64               ") cannot be more than "               "window-size(%" PRIu64 ")",               conf->aggregate_size, conf->window_size);
gf_msg(this->name, GF_LOG_ERROR, 0, READDIR_AHEAD_MSG_OUT_OF_SEQUENCE,               "Out of sequence directory preload.");
gf_msg(this->name, GF_LOG_ERROR, 0,               READDIR_AHEAD_MSG_DIR_RELEASE_PENDING_STUB,               "released a directory with a pending stub");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, READDIR_AHEAD_MSG_NO_MEMORY,               "Memory accounting init"               "failed");
gf_msg(this->name, GF_LOG_ERROR, 0,               READDIR_AHEAD_MSG_XLATOR_CHILD_MISCONFIGURED,               "FATAL: readdir-ahead not configured with exactly one"               " child");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, OPEN_BEHIND_MSG_NO_MEMORY,               "Memory accounting failed");
gf_msg(this->name, GF_LOG_ERROR, 0,               OPEN_BEHIND_MSG_XLATOR_CHILD_MISCONFIGURED,               "FATAL: volume (%s) not configured with exactly one "               "child",               this->name);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, MD_CACHE_MSG_NO_MEMORY,                   "out of memory");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, MD_CACHE_MSG_NO_MEMORY,                   "out of memory");
gf_msg("md-cache", GF_LOG_ERROR, 0, MD_CACHE_MSG_NO_XATTR_CACHE,                   "Disabled cache for xattrs, dict_set failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, MD_CACHE_MSG_NO_MEMORY,               "failed to create the frame");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, MD_CACHE_MSG_NO_MEMORY,               "failed to allocate memory");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, MD_CACHE_MSG_NO_MEMORY,               "out of memory");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, QUICK_READ_MSG_NO_MEMORY,               "Memory accounting init failed");
gf_msg(this->name, GF_LOG_ERROR, EINVAL,               QUICK_READ_MSG_INVALID_ARGUMENT,               "could not get cache-size option");
gf_msg(this->name, GF_LOG_ERROR, 0, QUICK_READ_MSG_INVALID_ARGUMENT,               "Cache size %" PRIu64               " is greater than the max size of %" PRIu64,               cache_size, max_cache_size);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, QUICK_READ_MSG_INVALID_CONFIG,               "Not reconfiguring cache-size");
gf_msg(this->name, GF_LOG_ERROR, 0,               QUICK_READ_MSG_XLATOR_CHILD_MISCONFIGURED,               "FATAL: volume (%s) not configured with exactly one "               "child",               this->name);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, READ_AHEAD_MSG_NO_MEMORY,               "Memory accounting init"               "failed");
gf_msg(this->name, GF_LOG_ERROR, 0,               READ_AHEAD_MSG_XLATOR_CHILD_MISCONFIGURED,               "FATAL: read-ahead not configured with exactly one"               " child");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, READ_AHEAD_MSG_NO_MEMORY,               "failed to create local_t's memory pool");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, NLC_MSG_NO_MEMORY,                   "inode ctx set failed");
gf_msg(this->name, GF_LOG_ERROR, 0, NLC_MSG_NO_TIMER_WHEEL,               "Initing the global timer wheel failed");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, TEMPLATE_MSG_NO_MEMORY,               "Memory accounting init failed");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, TEMPLATE_MSG_NO_GRAPH,               "not configured with exactly one child. exiting");
gf_msg(this->name, GF_LOG_ERROR, EINVAL, TEMPLATE_MSG_NO_GRAPH,               "dangling volume. check volfile ");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, TEMPLATE_MSG_NO_MEMORY,               "priv allocation failed");
gf_msg(this->name, GF_LOG_ERROR, 0, PS_MSG_LOCK_ERROR,                   "Unknown lock type: %" PRId32 "!", lock->l_type);
gf_msg(this->name, GF_LOG_ERROR, 0, PS_MSG_LOCK_ERROR,                   "Unknown lock type: %" PRId32 "!", lock->l_type);
gf_msg("authenticate", GF_LOG_ERROR, 0, PS_MSG_AUTHENTICATE_ERROR,               "AUTHENTICATION MODULE "               "\"IP\" HAS BEEN REPLACED BY \"ADDR\"");
gf_msg("authenticate", GF_LOG_ERROR, 0, PS_MSG_AUTHENTICATE_ERROR,               "dlopen(%s): %s\n", auth_file, dlerror());
gf_msg("authenticate", GF_LOG_ERROR, 0, PS_MSG_AUTHENTICATE_ERROR,               "dlsym(gf_auth) on %s\n", dlerror());
gf_msg("authenticate", GF_LOG_ERROR, 0, PS_MSG_VOL_VALIDATE_FAILED,               "volume option validation "               "failed");
gf_msg(xl->name, GF_LOG_ERROR, 0, PS_MSG_AUTH_INIT_FAILED,               "authentication init failed");
gf_msg("auth", GF_LOG_ERROR, 0, PS_MSG_REMOTE_CLIENT_REFUSED,               "no authentication module is interested in "               "accepting remote-client %s",               name);
gf_msg(this->name, GF_LOG_ERROR, 0, PS_MSG_ASPRINTF_FAILED,               "asprintf failed while setting error msg");
gf_msg(this->name, GF_LOG_ERROR, 0, PS_MSG_ASPRINTF_FAILED,                   "asprintf failed while setting error msg");
gf_msg(this->name, GF_LOG_ERROR, 0, PS_MSG_DICT_GET_FAILED,                   "Failed to set 'child_up' for xlator %s "                   "in the reply dict",                   tmp->name);
gf_msg(this->name, GF_LOG_ERROR, 0, PS_MSG_CHILD_STATUS_FAILED,                   "Not received child_up for this xlator %s", name);
gf_msg(this->name, GF_LOG_ERROR, 0, PS_MSG_ASPRINTF_FAILED,                   "asprintf failed while"                   "setting up error msg");
gf_msg(this->name, GF_LOG_ERROR, 0, PS_MSG_AUTH_INIT_FAILED,               "Authentication module not initialized");
gf_msg(this->name, GF_LOG_ERROR, ENOENT, PS_MSG_AUTHENTICATE_ERROR,                   "Cannot authenticate client"                   " from %s %s because brick is not attached in graph",                   client->client_uid, (clnt_version) ? clnt_version : "old");
gf_msg(this->name, GF_LOG_ERROR, EACCES, PS_MSG_AUTHENTICATE_ERROR,                   "Cannot authenticate client"                   " from %s %s",                   client->client_uid, (clnt_version) ? clnt_version : "old");
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, PS_MSG_NO_MEMORY,                   "BUG: dict allocation failed (pargfid: %s, name: %s), "                   "still continuing",                   uuid_utoa(resolve_loc->gfid), resolve_loc->name);
gf_msg(this->name, GF_LOG_ERROR, ENOMEM, PS_MSG_NO_MEMORY,                   "BUG: dict allocation failed (gfid: %s), "                   "still continuing",                   uuid_utoa(resolve_loc->gfid));
gf_msg(this->name, GF_LOG_ERROR, EPERM, PS_MSG_GFID_RESOLVE_FAILED,               "%s: parent type not directory (%d)", uuid_utoa(parent->gfid),               parent->ia_type);
gf_msg(this->name, GF_LOG_ERROR, EPERM, PS_MSG_GFID_RESOLVE_FAILED,               "%s: basename sent by client not allowed", resolve->bname);
gf_msg(this->name, GF_LOG_ERROR, EINVAL, PS_MSG_INVALID_ENTRY,               "Invalid pointer for "               "state->resolve_now");
gf_msg("server", GF_LOG_ERROR, 0, PS_MSG_FD_CREATE_FAILED,               "could not create the fd");
gf_msg("server", GF_LOG_ERROR, 0, PS_MSG_FD_CREATE_FAILED,               "fd creation for the inode %s failed",               state->loc.inode ? uuid_utoa(state->loc.inode->gfid) : NULL);
gf_msg("server", GF_LOG_ERROR, 0, PS_MSG_WRONG_STATE,                   "wrong state: %d", state);
gf_msg(frame->root->client->bound_xl->name, GF_LOG_ERROR, 0,                   PS_MSG_LOCK_ERROR,                   "fd - %" PRId64                   " (%s): Unknown "                   "lock type: %" PRId32 "!",                   state->resolve.fd_no, uuid_utoa(state->fd->inode->gfid),                   state->type);
gf_msg("", GF_LOG_ERROR, ret, LG_MSG_PTHREAD_KEY_CREATE_FAILED,               "failed to create the pthread key");
gf_msg(subvol->name, GF_LOG_ERROR, errno, LG_MSG_FD_CREATE_FAILED,               "fd_create of %s", uuid_utoa(loc->gfid));
gf_msg(subvol->name, GF_LOG_ERROR, errno,                   LG_MSG_FD_ANONYMOUS_FAILED,                   "fd_anonymous of "                   "%s",                   uuid_utoa(loc->gfid));
gf_msg(subvol->name, GF_LOG_ERROR, errno, LG_MSG_DIR_OP_FAILED,               "opendir of %s", uuid_utoa(loc->gfid));
gf_msg("graph-print", GF_LOG_ERROR, errno, LG_MSG_FWRITE_FAILED,               "fwrite failed");
gf_msg("graph-print", GF_LOG_ERROR, 0, LG_MSG_PRINT_FAILED,               "printing failed");
gf_msg("glusterfs", GF_LOG_ERROR, 0, LG_MSG_VOLUME_ERROR,               "volume \"%s\" can be added from command line only "               "on client side",               type);
gf_msg("glusterfs", GF_LOG_ERROR, 0, LG_MSG_INIT_FAILED,               "%s (%s) initialization failed", name, type);
gf_msg(trav->name, GF_LOG_ERROR, 0, LG_MSG_VALIDATION_FAILED,                   "validation failed: "                   "%s",                   errstr);
gf_msg(trav->name, GF_LOG_ERROR, 0, LG_MSG_TRANSLATOR_INIT_FAILED,                   "initializing translator failed");
gf_msg("graph", GF_LOG_ERROR, errno, LG_MSG_GETHOSTNAME_FAILED,               "gethostname failed");
gf_msg("graph", GF_LOG_ERROR, EINVAL, LG_MSG_GRAPH_ERROR,               "glusterfs graph settop failed");
gf_msg("graph", GF_LOG_ERROR, 0, LG_MSG_GRAPH_ERROR,               "glusterfs graph worm failed");
gf_msg("graph", GF_LOG_ERROR, 0, LG_MSG_GRAPH_ERROR,               "glusterfs graph ACL failed");
gf_msg("graph", GF_LOG_ERROR, 0, LG_MSG_GRAPH_ERROR,               "glusterfs graph mac compat failed");
gf_msg("graph", GF_LOG_ERROR, 0, LG_MSG_GRAPH_ERROR,               "glusterfs graph 'gfid-access' failed");
gf_msg("graph", GF_LOG_ERROR, 0, LG_MSG_GRAPH_ERROR,               "glusterfs graph meta failed");
gf_msg("graph", GF_LOG_ERROR, 0, LG_MSG_VALIDATION_FAILED,               "validate options failed");
gf_msg("graph", GF_LOG_ERROR, 0, LG_MSG_GRAPH_INIT_FAILED,               "init failed");
gf_msg("graph", GF_LOG_ERROR, 0, LG_MSG_UNKNOWN_OPTIONS_FAILED,               "unknown options "               "failed");
gf_msg("graph", GF_LOG_ERROR, 0, LG_MSG_EVENT_NOTIFY_FAILED,                   "graph new notification failed");
gf_msg("graph", GF_LOG_ERROR, 0, LG_MSG_EVENT_NOTIFY_FAILED,               "parent up notification failed");
gf_msg("glusterfsd-mgmt", GF_LOG_ERROR, 0, LG_MSG_CTX_NULL,               "ctx is NULL");
gf_msg("glusterfsd-mgmt", GF_LOG_ERROR, 0, LG_MSG_CTX_NULL,               "ctx is NULL");
gf_msg("glusterfsd-mgmt", GF_LOG_ERROR, 0, LG_MSG_ACTIVE_GRAPH_NULL,               "glusterfs_ctx->active is NULL");
gf_msg("glusterfsd-mgmt", GF_LOG_ERROR, errno,                   LG_MSG_TMPFILE_CREATE_FAILED,                   "Unable to "                   "create temporary volfile");
gf_msg("glusterfsd-mgmt", GF_LOG_ERROR, errno,                   LG_MSG_TMPFILE_DELETE_FAILED,                   "Temporary file"                   " delete failed.");
gf_msg("glusterfs", GF_LOG_ERROR, EAGAIN, LG_MSG_GRAPH_CLEANUP_FAILED,               "Failed to acquire a lock");
gf_msg("glusterfs", GF_LOG_ERROR, EAGAIN, LG_MSG_GRAPH_CLEANUP_FAILED,               "Failed to release a lock");
gf_msg("glusterfs", GF_LOG_ERROR, EINVAL, LG_MSG_GRAPH_SETUP_FAILED,               "%s (%s) set type failed", name, type);
gf_msg("glusterfs", GF_LOG_ERROR, EINVAL,                       LG_MSG_GRAPH_CLEANUP_FAILED,                       "%s failed to create clean "                       "up thread",                       volfile_obj->vol_id);
gf_msg("glusterfsd", GF_LOG_ERROR, errno,               LG_MSG_GRAPH_ATTACH_PID_FILE_UPDATED,               "pidfile %s truncation failed", pid_file);
gf_msg("glusterfsd", GF_LOG_ERROR, errno,               LG_MSG_GRAPH_ATTACH_PID_FILE_UPDATED, "pidfile %s write failed",               pid_file);
gf_msg("glusterfsd", GF_LOG_ERROR, errno,               LG_MSG_GRAPH_ATTACH_PID_FILE_UPDATED, "pidfile %s write failed",               pid_file);
gf_msg("mgmt", GF_LOG_ERROR, EINVAL, LG_MSG_GRAPH_SETUP_FAILED,               "Failed to get pidfile from dict for  volfile_id=%s",               volfile_obj->vol_id);
gf_msg("mgmt", GF_LOG_ERROR, EINVAL, LG_MSG_GRAPH_SETUP_FAILED,               "Failed to update "               "the pidfile for volfile_id=%s",               volfile_obj->vol_id);
gf_msg("glusterfsd", GF_LOG_ERROR, EINVAL, LG_MSG_GRAPH_ATTACH_FAILED,               "failed to construct the graph");
gf_msg("glusterfsd", GF_LOG_ERROR, EINVAL,                   LG_MSG_GRAPH_ATTACH_FAILED,                   "fuse xlator cannot be specified in volume file");
gf_msg("graph", GF_LOG_ERROR, 0, LG_MSG_EVENT_NOTIFY_FAILED,               "parent up notification failed");
gf_msg("glusterfs", GF_LOG_ERROR, EINVAL,                       LG_MSG_GRAPH_CLEANUP_FAILED,                       "%s failed to create clean "                       "up thread",                       volfile_id);
gf_msg("glusterfsd-mgmt", GF_LOG_ERROR, 0, LG_MSG_CTX_NULL,               "ctx is NULL");
gf_msg("glusterfsd-mgmt", GF_LOG_ERROR, 0, LG_MSG_CTX_NULL,               "failed to get volfile object");
gf_msg("glusterfsd-mgmt", GF_LOG_ERROR, EINVAL,                   LG_MSG_GRAPH_CLEANUP_FAILED,                   "Could not detach "                   "old graph. Aborting the reconfiguration operation");
gf_msg("libglusterfs", GF_LOG_ERROR, errno,                   LG_MSG_SET_ATTRIBUTE_FAILED,                   "Couldn't set "                   "extended attribute for %d",                   fd);
gf_msg("libglusterfs", GF_LOG_ERROR, errno,                   LG_MSG_SET_ATTRIBUTE_FAILED,                   "Couldn't set "                   "extended attribute for %s",                   path);
gf_msg(xlname, GF_LOG_ERROR, errno, LG_MSG_UNMOUNT_FAILED,               "Lazy unmount of %s", path);
gf_msg(THIS->name, GF_LOG_ERROR, ret, LG_MSG_PTHREAD_FAILED,               "Thread creation failed");
gf_msg("fd", GF_LOG_ERROR, 0, LG_MSG_EXPAND_FD_TABLE_FAILED,                       "multiple attempts to expand fd table"                       " have failed.");
gf_msg("fd", GF_LOG_ERROR, error, LG_MSG_EXPAND_FD_TABLE_FAILED,                       "Cannot expand fdtable");
gf_msg("monitoring", GF_LOG_ERROR, 0, LG_MSG_STRDUP_ERROR,               "failed to create metrics dir %s (%s)", dumppath,               strerror(errno));
gf_msg("monitoring", GF_LOG_ERROR, 0, LG_MSG_STRDUP_ERROR,               "failed to open tmp file %s (%s)", filepath, strerror(errno));
gf_msg("syncop", GF_LOG_ERROR, errno, LG_MSG_SWAPCONTEXT_FAILED,               "swapcontext failed");
gf_msg("syncop", GF_LOG_ERROR, errno, LG_MSG_GETCONTEXT_FAILED,               "getcontext failed");
gf_msg("syncop", GF_LOG_ERROR, errno, LG_MSG_SWAPCONTEXT_FAILED,               "swapcontext failed");
gf_msg(THIS->name, GF_LOG_ERROR, 0, 0,                       "lock mem allocation  failed");
gf_msg("", GF_LOG_ERROR, errno, LG_MSG_DIR_OP_FAILED,               "mkdir()"               " failed on path %s.",               path);
gf_msg("", GF_LOG_ERROR, 0, LG_MSG_STORE_HANDLE_CREATE_FAILED,                   "Unable to"                   " create store handle for path: %s",                   path);
gf_msg("", GF_LOG_ERROR, errno, LG_MSG_FILE_OP_FAILED,               "Failed to open %s.", tmppath);
gf_msg(this->name, GF_LOG_ERROR, errno, LG_MSG_DIR_OP_FAILED,               "Failed to open directory %s.", pdir);
gf_msg(this->name, GF_LOG_ERROR, errno, LG_MSG_DIR_OP_FAILED,               "Failed to fsync %s.", pdir);
gf_msg(this->name, GF_LOG_ERROR, errno, LG_MSG_DIR_OP_FAILED,                   "Failed to close %s", pdir);
gf_msg(THIS->name, GF_LOG_ERROR, errno, LG_MSG_FILE_OP_FAILED,               "Failed to fsync %s", shandle->path);
gf_msg(THIS->name, GF_LOG_ERROR, errno, LG_MSG_FILE_OP_FAILED,               "Failed to rename %s to %s", tmppath, shandle->path);
gf_msg("", GF_LOG_ERROR, errno, LG_MSG_FILE_OP_FAILED,               "Failed to mv %s to %s", tmppath, shandle->path);
gf_msg("", GF_LOG_ERROR, errno, LG_MSG_FILE_OP_FAILED,               "Unable to open file %s", handle->path);
gf_msg("", GF_LOG_ERROR, errno, LG_MSG_FILE_OP_FAILED,                   "Unable to open file %s", handle->path);
gf_msg("", GF_LOG_ERROR, errno, LG_MSG_FILE_OP_FAILED,               "Failed to open file: %s.", path);
gf_msg("", GF_LOG_ERROR, errno, LG_MSG_PATH_NOT_FOUND,               "Path "               "corresponding to %s.",               path);
gf_msg("", GF_LOG_ERROR, errno, LG_MSG_FILE_OP_FAILED,               "Unable to open file %s", shandle->path);
gf_msg("", GF_LOG_ERROR, 0, LG_MSG_INVALID_ENTRY,               "Glusterd "               "store may be corrupted, Invalid key and value (null)"               " in %s",               storepath);
gf_msg("", GF_LOG_ERROR, 0, LG_MSG_INVALID_ENTRY,               "Glusterd "               "store may be corrupted, Invalid key (null) in %s",               storepath);
gf_msg("", GF_LOG_ERROR, 0, LG_MSG_INVALID_ENTRY,               "Glusterd "               "store may be corrupted, Invalid value (null) for key"               " %s in %s",               key, storepath);
gf_msg("", GF_LOG_ERROR, errno, LG_MSG_FILE_OP_FAILED,               "Unable"               " to close file: %s, ret: %d",               (*iter)->filepath, ret);
gf_msg("", GF_LOG_ERROR, errno, LG_MSG_FILE_OP_FAILED,               "Failed to open '%s'", sh->path);
gf_msg("", GF_LOG_ERROR, errno, LG_MSG_LOCK_FAILED,               "Failed to gain lock on '%s'", sh->path);
gf_msg("", GF_LOG_ERROR, errno, LG_MSG_UNLOCK_FAILED,               "Failed to release lock on '%s'", sh->path);
gf_msg("client_t", GF_LOG_ERROR, 0, LG_MSG_EXPAND_CLIENT_TABLE_FAILED,               "gf_client_clienttable_expand failed");
./glusterfs/glusterfsd/src/glusterfsd.c:        gf_log("glusterfs", GF_LOG_CRITICAL, "asprintf () failed.");
./glusterfs/glusterfsd/src/glusterfsd.c:        gf_log("glusterfs", GF_LOG_CRITICAL, "asprintf () failed.");
./glusterfs/tests/basic/logchecks.c:    gf_log_set_loglevel(ctx, GF_LOG_CRITICAL);
./glusterfs/tests/basic/logchecks.c:    gf_log_set_loglevel(ctx, GF_LOG_CRITICAL);
./glusterfs/xlators/features/compress/src/cdc.c:        gf_log(this->name, GF_LOG_CRITICAL, "Operation mode not specified !!");
gf_log("glusterfs", GF_LOG_CRITICAL,               "Error loading NFS server library : "               "%s\n",               dlerror());
gf_log("glusterfs", GF_LOG_CRITICAL,               "Error finding function exp_file_parse "               "in symbol.");
gf_log("glusterfs", GF_LOG_CRITICAL,               "Error finding function exp_file_print in symbol.");
gf_log("glusterfs", GF_LOG_CRITICAL,               "Error finding function exp_file_deinit in lib.");
gf_log("glusterfs", GF_LOG_CRITICAL,               "Error loading NFS server library : %s\n", dlerror());
gf_log("glusterfs", GF_LOG_CRITICAL,               "Error finding function ng_file_parse in symbol.");
gf_log("glusterfs", GF_LOG_CRITICAL,               "Error finding function ng_file_print in symbol.");
gf_log("glusterfs", GF_LOG_CRITICAL,               "Error finding function ng_file_deinit in lib.");
gf_log(clnt->conn.name, GF_LOG_CRITICAL,               "cannot lookup the saved "               "frame corresponding to xid (%d)",               info->xid);
gf_log(trans->name, GF_LOG_CRITICAL,               "server %s has not responded in the last %d "               "seconds, disconnecting.",               trans->peerinfo.identifier, conn->ping_timeout);
gf_log("rpcsvc", GF_LOG_CRITICAL,                   "got CONNECT event, which should have not come");
gf_log("rpcsvc", GF_LOG_CRITICAL,                   "got MAP_XID event, which should have not come");
gf_log(this->name, GF_LOG_CRITICAL,           "Disabling barrier because of "           "the barrier timeout.");
gf_log(this->name, GF_LOG_CRITICAL,               "Couldn't add barrier "               "timeout event.");
gf_log(this->name, GF_LOG_CRITICAL,               "FATAL: posix-locks should have exactly one child");
gf_log(this->name, GF_LOG_CRITICAL,               "'locks' translator is not loaded over a storage "               "translator");
gf_log(this->name, GF_LOG_CRITICAL,           "Indexing gone corrupt at %s (reason: %s)."           " Geo-replication secondary content needs to be revalidated",           path, strerror(op_errno));
gf_log(this->name, GF_LOG_CRITICAL,               "continuation stub to unwind the call is absent, hence "               "call will be hung (call-stack id = %" PRIu64 ")",               frame->root->unique);
gf_log(this->name, GF_LOG_CRITICAL,               "Bogus operation mode (%s) specified", temp_str);
gf_log(THIS->name, GF_LOG_CRITICAL,                   "Quota "                   "configuration store may be corrupt.");
gf_log(THIS->name, GF_LOG_CRITICAL,                   "Quota "                   "configuration store may be corrupt.");
./glusterfs/xlators/performance/io-threads/src/io-threads.c:        gf_log(this->name, GF_LOG_EMERG, "watchdog firing too often");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "Failed to get iobuf");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "Failed to encode message");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:            gf_log(THIS->name, GF_LOG_ERROR, "out of memory");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log_callingfn(THIS->name, GF_LOG_ERROR, "Failed to serialize reply");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "Reply submission failed");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "ctx->active returned NULL");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log("glusterd", GF_LOG_ERROR, "Could not allocate memory");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log("glusterd", GF_LOG_ERROR, "Could not open tmp file");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log("glusterd", GF_LOG_ERROR, "could not flush cache");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log("glusterd", GF_LOG_ERROR, "could not seek back to start");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log("glusterd", GF_LOG_ERROR, "Could not open output file");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(this->name, GF_LOG_ERROR, "Couldn't get status op");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(this->name, GF_LOG_ERROR, "ctx returned NULL");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(this->name, GF_LOG_ERROR, "ctx->active returned NULL");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(this->name, GF_LOG_ERROR, "xlator is not loaded");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "Couldn't get status op");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "Couldn't get volname");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "ctx->active returned NULL");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "Failed to set node xlator name");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "%s xlator is not loaded", node_name);
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "Failed to set node xlator name");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:            gf_log(THIS->name, GF_LOG_ERROR, "%s", msg);
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "Couldn't get volname");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "ctx->active returned NULL");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "xlator %s is no loaded", volname);
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "ctx->active returned NULL");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "barrier notify failed");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "changelog notify failed");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(frame->this->name, GF_LOG_ERROR, "XDR decoding error");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(THIS->name, GF_LOG_ERROR, "Failed to serialize dictionary");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(frame->this->name, GF_LOG_ERROR, "XDR decoding error");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(frame->this->name, GF_LOG_ERROR, "XDR decoding error");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:            gf_log("", GF_LOG_ERROR, "failed to set volname");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:            gf_log("", GF_LOG_ERROR, "failed to serialize dict");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:            gf_log("", GF_LOG_ERROR, "Invalid op");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(frame->this->name, GF_LOG_ERROR, "XDR decode error");
./glusterfs/glusterfsd/src/glusterfsd-mgmt.c:        gf_log(frame->this->name, GF_LOG_ERROR, "XDR decode error");
./glusterfs/api/src/glfs.c:            gf_log("glfs", GF_LOG_ERROR, "available events: %s", msg);
./glusterfs/api/src/glfs.c:        gf_log("glfs", GF_LOG_ERROR, "path is NULL");
./glusterfs/api/src/glfs.c:            gf_log("glfs", GF_LOG_ERROR, "%s: path is not directory", path);
./glusterfs/rpc/rpc-transport/socket/src/socket.c:        gf_log(caller, GF_LOG_ERROR, "  %s", errbuf);
./glusterfs/rpc/rpc-transport/socket/src/socket.c:        gf_log(this->name, GF_LOG_ERROR, "buffer is empty %s", __func__);
./glusterfs/rpc/rpc-transport/socket/src/socket.c:    gf_log(this->name, GF_LOG_ERROR, "OpenSSL version does not support CRL");
./glusterfs/rpc/rpc-transport/socket/src/socket.c:    gf_log(this->name, GF_LOG_ERROR, "OpenSSL version does not support CRL");
./glusterfs/rpc/rpc-transport/socket/src/socket.c:        gf_log(this->name, GF_LOG_ERROR, "SSL_new failed");
./glusterfs/rpc/rpc-transport/socket/src/socket.c:        gf_log(this->name, GF_LOG_ERROR, "BIO_new_socket failed");
./glusterfs/rpc/rpc-transport/socket/src/socket.c:                    gf_log(this->name, GF_LOG_ERROR, "Port is already in use");
./glusterfs/rpc/rpc-transport/socket/src/socket.c:                gf_log(this->name, GF_LOG_ERROR, "Port is already in use");
./glusterfs/rpc/rpc-transport/socket/src/socket.c:            gf_log(this->name, GF_LOG_ERROR, "OpenSSL has no DH support");
./glusterfs/rpc/rpc-transport/socket/src/socket.c:            gf_log(this->name, GF_LOG_ERROR, "OpenSSL has no ECDH support");
./glusterfs/rpc/rpc-transport/socket/src/socket.c:            gf_log(this->name, GF_LOG_ERROR, "could not load CA list");
./glusterfs/rpc/rpc-transport/socket/src/socket.c:        gf_log_callingfn(this->name, GF_LOG_ERROR, "double init attempted");
./glusterfs/rpc/rpc-lib/src/rpc-clnt.c:        gf_log(clnt->conn.name, GF_LOG_ERROR, "Failed to build record header");
./glusterfs/rpc/rpc-lib/src/rpc-clnt-ping.c:        gf_log(THIS->name, GF_LOG_ERROR, "failed to start ping timer");
./glusterfs/rpc/rpc-lib/src/rpc-transport.c:        gf_log("rpc-transport", GF_LOG_ERROR, "%s", dlerror());
./glusterfs/rpc/rpc-lib/src/mgmt-pmap.c:        gf_log(THIS->name, GF_LOG_ERROR, "XDR decoding failed");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:            gf_log(GF_RPCSVC, GF_LOG_ERROR, "No vectored handler present");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "Invalid rpc_status value");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "Reply record creation failed");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:            gf_log(GF_RPCSVC, GF_LOG_ERROR, "failed to cache reply");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:            gf_log(GF_RPCSVC, GF_LOG_ERROR, "Program not found");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "option transport-type not set");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "option transport-type not set");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:            gf_log(GF_RPCSVC, GF_LOG_ERROR, "asprintf failed");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:                gf_log(GF_RPCSVC, GF_LOG_ERROR, "dict_set_str error");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:            gf_log(GF_RPCSVC, GF_LOG_ERROR, "asprintf failed");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:                gf_log(GF_RPCSVC, GF_LOG_ERROR, "dict_set_str error");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "Failed to init options");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "mem pool allocation failed");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "failed to register DUMP program");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "asprintf failed");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "asprintf failed");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "asprintf failed");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "asprintf failed");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "asprintf failed");
./glusterfs/rpc/rpc-lib/src/rpcsvc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "asprintf failed");
./glusterfs/rpc/rpc-lib/src/rpc-drc.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "DRC failed to detect duplicates");
./glusterfs/rpc/rpc-lib/src/rpcsvc-auth.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "Failed to add AUTH_GLUSTERFS");
./glusterfs/rpc/rpc-lib/src/rpcsvc-auth.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "Failed to add AUTH_GLUSTERFS-v2");
./glusterfs/rpc/rpc-lib/src/rpcsvc-auth.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "Failed to add AUTH_GLUSTERFS-v3");
./glusterfs/rpc/rpc-lib/src/rpcsvc-auth.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "Failed to add AUTH_UNIX");
./glusterfs/rpc/rpc-lib/src/rpcsvc-auth.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "Failed to add AUTH_NULL");
./glusterfs/rpc/rpc-lib/src/rpcsvc-auth.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "No init function defined");
./glusterfs/rpc/rpc-lib/src/rpcsvc-auth.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "Failed to add initers");
./glusterfs/rpc/rpc-lib/src/rpcsvc-auth.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "Failed to init auth schemes");
./glusterfs/rpc/rpc-lib/src/rpcsvc-auth.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "!svc");
./glusterfs/rpc/rpc-lib/src/rpcsvc-auth.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "No authentication!");
./glusterfs/contrib/umountd/umountd.c:                gf_log ("umountd", GF_LOG_ERROR, "signal () failed");
./glusterfs/contrib/umountd/umountd.c:                gf_log ("umountd", GF_LOG_ERROR, "signal () failed");
./glusterfs/xlators/system/posix-acl/src/posix-acl.c:        gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/system/posix-acl/src/posix-acl.c:        gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/system/posix-acl/src/posix-acl.c:        gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/system/posix-acl/src/posix-acl.c:        gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/system/posix-acl/src/posix-acl.c:        gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/namespace/src/namespace.c:        gf_log(this->name, GF_LOG_ERROR, "Can't allocate ns_priv structure.");
./glusterfs/xlators/features/barrier/src/barrier.c:                        gf_log(this->name, GF_LOG_ERROR, "Already disabled.");
./glusterfs/xlators/features/barrier/src/barrier.c:                        gf_log(this->name, GF_LOG_ERROR, "Already enabled");
./glusterfs/xlators/features/quota/src/quotad-aggregator.c:            gf_log_callingfn(THIS->name, GF_LOG_ERROR, "Failed to get iobuf");
./glusterfs/xlators/features/quota/src/quotad-aggregator.c:            gf_log_callingfn("", GF_LOG_ERROR, "Failed to encode message");
./glusterfs/xlators/features/quota/src/quota.c:        gf_log(this->name, GF_LOG_ERROR, "Received null argument");
./glusterfs/xlators/features/locks/src/posix.c:                    gf_log(this->name, GF_LOG_ERROR, "lock preempt failed");
./glusterfs/xlators/features/locks/src/common.c:    gf_log("posix-locks", GF_LOG_ERROR, "Unexpected case in subtract_locks");
./glusterfs/xlators/features/thin-arbiter/src/thin-arbiter.c:        gf_log(this->name, GF_LOG_ERROR, "dangling volume. check volfile ");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "dict_new failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "fd creation failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:                gf_log(this->name, GF_LOG_ERROR, "inode link failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log_callingfn("quota", GF_LOG_ERROR, "dict set failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "dict_new failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "dict_new failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "dict_new failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "dict_new failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "dict_set failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "dict_new failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "dict_set failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "dict_new failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:            gf_log(this->name, GF_LOG_ERROR, "dict_set failed.");
./glusterfs/xlators/features/marker/src/marker-quota.c:                gf_log(this->name, GF_LOG_ERROR, "dict_get failed.");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "dict_new failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "dict_new failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "loc copy failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "dict_new failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "dict_set failed");
./glusterfs/xlators/features/marker/src/marker-quota.c:        gf_log(this->name, GF_LOG_ERROR, "Failed to create fd");
./glusterfs/xlators/features/marker/src/marker.c:            gf_log("loc fill", GF_LOG_ERROR, "strdup failed");
./glusterfs/xlators/features/marker/src/marker-quota-helper.c:        gf_log("loc fill", GF_LOG_ERROR, "strdup failed");
./glusterfs/xlators/features/marker/src/marker-quota-helper.c:        gf_log(this->name, GF_LOG_ERROR, "marker_force_inode_ctx_get() failed");
./glusterfs/xlators/features/arbiter/src/arbiter.c:        gf_log(this->name, GF_LOG_ERROR, "dangling volume. check volfile ");
./glusterfs/xlators/features/selinux/src/selinux.c:        gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/compress/src/cdc.c:        gf_log(this->name, GF_LOG_ERROR, "Need subvolume == 1");
./glusterfs/xlators/features/compress/src/cdc-helper.c:        gf_log(this->name, GF_LOG_ERROR, "Cannot open file: %s", file);
./glusterfs/xlators/features/compress/src/cdc-helper.c:        gf_log(this->name, GF_LOG_ERROR, "Compression Error: ret (%d)", ret);
./glusterfs/xlators/features/compress/src/cdc-helper.c:        gf_log(this->name, GF_LOG_ERROR, "Zlib: Unable to initialize inflate");
./glusterfs/xlators/features/compress/src/cdc-helper.c:        gf_log(this->name, GF_LOG_ERROR, "Decompression Error: ret (%d)", ret);
./glusterfs/xlators/features/trash/src/trash.c:        gf_log(this->name, GF_LOG_ERROR, "failed to create frame");
./glusterfs/xlators/features/trash/src/trash.c:            gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/trash/src/trash.c:        gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/trash/src/trash.c:            gf_log(this->name, GF_LOG_ERROR, "setting key gfid-req failed");
./glusterfs/xlators/features/trash/src/trash.c:            gf_log(this->name, GF_LOG_ERROR, "setting key gfid-req failed");
./glusterfs/xlators/features/trash/src/trash.c:        gf_log(this->name, GF_LOG_ERROR, "failed to create frame");
./glusterfs/xlators/features/trash/src/trash.c:        gf_log(this->name, GF_LOG_ERROR, "failed to create frame");
./glusterfs/xlators/features/trash/src/trash.c:        gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/trash/src/trash.c:            gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/trash/src/trash.c:            gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/trash/src/trash.c:            gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/trash/src/trash.c:        gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/trash/src/trash.c:        gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/trash/src/trash.c:        gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/trash/src/trash.c:            gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/trash/src/trash.c:        gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/trash/src/trash.c:            gf_log(this->name, GF_LOG_ERROR, "out of memory");
./glusterfs/xlators/features/quiesce/src/quiesce.c:            gf_log(this->name, GF_LOG_ERROR, "Cannot create timer");
./glusterfs/xlators/features/quiesce/src/quiesce.c:        gf_log_callingfn(this->name, GF_LOG_ERROR, "this->private == NULL");
./glusterfs/xlators/features/read-only/src/worm.c:            gf_log(this->name, GF_LOG_ERROR, "Error setting worm state");
./glusterfs/xlators/features/read-only/src/worm.c:            gf_log(this->name, GF_LOG_ERROR, "Error setting worm state");
./glusterfs/xlators/features/read-only/src/worm.c:            gf_log(this->name, GF_LOG_ERROR, "Error initializing state");
./glusterfs/xlators/features/read-only/src/worm.c:        gf_log(this->name, GF_LOG_ERROR, "Error allocating priv");
./glusterfs/xlators/features/read-only/src/worm.c:            gf_log(this->name, GF_LOG_ERROR, "Error creating the dict");
./glusterfs/xlators/features/read-only/src/worm.c:            gf_log(this->name, GF_LOG_ERROR, "Error setting xattr");
./glusterfs/xlators/features/read-only/src/worm-helper.c:        gf_log(this->name, GF_LOG_ERROR, "Error creating the dict");
./glusterfs/xlators/features/read-only/src/worm-helper.c:        gf_log(this->name, GF_LOG_ERROR, "Error in setting the dict");
./glusterfs/xlators/features/read-only/src/worm-helper.c:        gf_log(this->name, GF_LOG_ERROR, "Error setting xattr");
./glusterfs/xlators/features/read-only/src/worm-helper.c:        gf_log(this->name, GF_LOG_ERROR, "Empty val");
./glusterfs/xlators/features/read-only/src/worm-helper.c:        gf_log(this->name, GF_LOG_ERROR, "Error setting xattr");
./glusterfs/xlators/features/read-only/src/worm-helper.c:        gf_log(this->name, GF_LOG_ERROR, "Error creating the dict");
./glusterfs/xlators/features/read-only/src/worm-helper.c:        gf_log(this->name, GF_LOG_ERROR, "Error in setting the dict");
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:        gf_loglevel_t loglevel = GF_LOG_ERROR;
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:        gf_log("send_fuse_iov", GF_LOG_ERROR, "Invalid arguments");
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:        gf_log("fuse", GF_LOG_ERROR, "fd is NULL");
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:    gf_log("glusterfs-fuse", GF_LOG_ERROR, "kernel notifier loop terminated");
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:    gf_log("glusterfs-fuse", GF_LOG_ERROR, "timed response loop terminated");
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:        gf_log("glusterfs-fuse", GF_LOG_ERROR, "got INIT after first message");
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:        gf_log(xl->name, GF_LOG_ERROR, "failed to set 'gfid-req'");
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:        gf_log(this->name, GF_LOG_ERROR, "could not get mount status");
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:            gf_log(this->name, GF_LOG_ERROR, "Out of memory");
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:                    gf_log("glusterfs-fuse", GF_LOG_ERROR, "Out of memory");
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:            gf_log("glusterfs-fuse", GF_LOG_ERROR, "Out of memory");
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:        gf_log("glusterfs-fuse", GF_LOG_ERROR, "Out of memory");
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:        gf_log("glusterfs-fuse", GF_LOG_ERROR, "Out of memory");
./glusterfs/xlators/mount/fuse/src/fuse-bridge.c:        gf_log("glusterfs-fuse", GF_LOG_ERROR, "Out of memory");
./glusterfs/xlators/mount/fuse/src/fuse-helpers.c:            gf_log(this->name, GF_LOG_ERROR, "procfs path exceeds buffer size");
./glusterfs/xlators/nfs/server/src/nfs.c:        gf_log(GF_NFS, GF_LOG_ERROR, "dict_set_str error");
./glusterfs/xlators/nfs/server/src/nfs-fops.c:                    gf_log (GF_NFS, GF_LOG_ERROR, "iobref creation failed");
./glusterfs/xlators/nfs/server/src/mount3.c:            gf_log (GF_MNT, GF_LOG_ERROR, "Failed to build exports list");
./glusterfs/xlators/meta/src/meta.c:        gf_log(this->name, GF_LOG_ERROR, "Memory accounting init failed");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volgen.c:        gf_log("glusterd", GF_LOG_ERROR, "failed to generate user-xlator type");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volgen.c:        gf_log(THIS->name, GF_LOG_ERROR, "Could not generate gfproxy volfiles");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-volgen.c:        gf_log(THIS->name, GF_LOG_ERROR, "Could not generate shd volfiles");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-handshake.c:            gf_log(this->name, GF_LOG_ERROR, "Couldn't find volinfo");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-handshake.c:            gf_log(this->name, GF_LOG_ERROR, "Couldn't find volinfo");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-utils.c:        gf_log(frame->this->name, GF_LOG_ERROR, "iov is NULL");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-utils.c:        gf_log(frame->this->name, GF_LOG_ERROR, "XDR decoding error");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-utils.c:        gf_log(this->name, GF_LOG_ERROR, "called with null rpc");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-mgmt.c:        gf_log(this->name, GF_LOG_ERROR, "Brick Op Failed");
./glusterfs/xlators/mgmt/glusterd/src/glusterd.c:            gf_log(this->name, GF_LOG_ERROR, "Failed to store max op-version");
./glusterfs/xlators/mgmt/glusterd/src/glusterd-snapshot.c:    gf_loglevel_t loglevel = GF_LOG_ERROR;
./glusterfs/xlators/mgmt/glusterd/src/glusterd-snapshot.c:    gf_loglevel_t loglevel = GF_LOG_ERROR;
./glusterfs/xlators/mgmt/glusterd/src/glusterd-snapshot.c:    gf_loglevel_t loglevel = GF_LOG_ERROR;
./glusterfs/xlators/mgmt/glusterd/src/glusterd-snapshot.c:    gf_loglevel_t loglevel = GF_LOG_ERROR;
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:        gf_log(this->name, GF_LOG_ERROR, "Layout is NULL");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:        gf_log("DHT", GF_LOG_ERROR, "rebal_entry is NULL");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:        gf_log(this->name, GF_LOG_ERROR, "pattern_match failed");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:        gf_log(this->name, GF_LOG_ERROR, "Child loc build failed");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:            gf_log(this->name, GF_LOG_ERROR, "loc_copy failed");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:        gf_log(this->name, GF_LOG_ERROR, "dir_dfmeta is NULL");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:        gf_log(this->name, GF_LOG_ERROR, "dir_dfmeta->head is NULL");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:        gf_log(this->name, GF_LOG_ERROR, "dir_dfmeta->iterator is NULL");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:        gf_log(this->name, GF_LOG_ERROR, "dir_dfmeta->equeue is NULL");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:        gf_log(this->name, GF_LOG_ERROR, "dir_dfmeta->offset_var is NULL");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:        gf_log(this->name, GF_LOG_ERROR, "dict_new failed");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:        gf_log(this->name, GF_LOG_ERROR, "Failed to set new-commit-hash");
./glusterfs/xlators/cluster/dht/src/dht-rebalance.c:        gf_log(this->name, GF_LOG_ERROR, "Failed to create fd");
./glusterfs/xlators/debug/io-stats/src/io-stats.c:    gf_log(this->name, GF_LOG_ERROR, "Error parsing socket identifier");
./glusterfs/xlators/debug/io-stats/src/io-stats.c:        gf_log(this->name, GF_LOG_ERROR, "No filename given");
./glusterfs/xlators/debug/io-stats/src/io-stats.c:        gf_log(this->name, GF_LOG_ERROR, "Out of memory.");
./glusterfs/xlators/protocol/auth/login/src/login.c:        gf_log("auth/login", GF_LOG_ERROR, "remote-subvolume not specified");
./glusterfs/xlators/protocol/auth/addr/src/addr.c:        gf_log("auth/addr", GF_LOG_ERROR, "peer-info not present");
./glusterfs/xlators/protocol/client/src/client-handshake.c:            gf_log(THIS->name, GF_LOG_ERROR, "Failed to set subdir_mount");
./glusterfs/xlators/protocol/server/src/server-handshake.c:        gf_log(xl->name, GF_LOG_ERROR, "failed to set 'gfid-req' for subdir");
./glusterfs/xlators/protocol/server/src/server.c:        gf_log(GF_RPCSVC, GF_LOG_ERROR, "Failed to reconfigure authentication");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log(THIS->name, GF_LOG_ERROR, "failed to set hostname");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log(THIS->name, GF_LOG_ERROR, "failed to create frame");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("cli", GF_LOG_ERROR, "Unable to get transport type");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log(THIS->name, GF_LOG_ERROR, "dict set failed");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log(THIS->name, GF_LOG_ERROR, "dict set failed");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log(THIS->name, GF_LOG_ERROR, "dict set failed");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log(THIS->name, GF_LOG_ERROR, "dict set failed");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log(THIS->name, GF_LOG_ERROR, "failed to create frame");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("cli", GF_LOG_ERROR, "Failed to fetch volname");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("cli", GF_LOG_ERROR, "Failed to fetch command");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get default soft limit");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("cli", GF_LOG_ERROR, "Failed to set default soft limit");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get volume name");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get quota option type");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("cli", GF_LOG_ERROR, "Failed to set type in xdata");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("cli", GF_LOG_ERROR, "Failed to set volume-uuid");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("cli", GF_LOG_ERROR, "Failed to set max_count");
./glusterfs/cli/src/cli-cmd-volume.c:            gf_log("cli", GF_LOG_ERROR, "Failed to set gfid");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get opcode");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get volume name");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("cli", GF_LOG_ERROR, "Failed to fetch volname");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log(THIS->name, GF_LOG_ERROR, "failed to create frame");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log(THIS->name, GF_LOG_ERROR, "failed to create frame");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log("", GF_LOG_ERROR, "geo-replication not installed");
./glusterfs/cli/src/cli-cmd-volume.c:        gf_log(THIS->name, GF_LOG_ERROR, "failed to create frame");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "%s", msg);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "%s", rsp.op_errstr);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:                    gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Couldn't get daemon name");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Couldn't get filepath");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, "dict get failed");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Failed to get uuid from dictionary");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "dict get failed");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "count not set");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "node down and has failed to set dict");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, "Failed to get volname");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get command");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("glusterd", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to print rebalance status");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "%s", msg);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("", GF_LOG_ERROR, "failed to get command");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, "dict_get on operation failed");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log(frame->this->name, GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, "dict_get on operation failed");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log(frame->this->name, GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get quota type");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get type");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to set quota-list-count in dict");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "failed to add node to the list");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "failed to get max_count");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(this->name, GF_LOG_ERROR, DICT_SERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, "failed to get volname");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("", GF_LOG_ERROR, "out of memory");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(THIS->name, GF_LOG_ERROR, "Failed to create the dict");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, "failed to set flags");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, DICT_SERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(this->name, GF_LOG_ERROR, DICT_SERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log(this->name, GF_LOG_ERROR, "Failed to set dict");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(THIS->name, GF_LOG_ERROR, DICT_SERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("", GF_LOG_ERROR, "struct member empty.");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "struct member empty.");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("", GF_LOG_ERROR, "struct member empty.");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("", GF_LOG_ERROR, "Unable to read status data");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("", GF_LOG_ERROR, "Unable to print status output");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("", GF_LOG_ERROR, "Unable to fetch workdir");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("", GF_LOG_ERROR, "Failed to get %s.", output_name);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("", GF_LOG_ERROR, "Failed to add new line char");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("", GF_LOG_ERROR, "Unable to get command from dict");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("", GF_LOG_ERROR, "Failed to get %s.", output_name);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Invalid data");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Invalid data");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Couldn't get brick name");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get tasks count");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Failed to get local");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(THIS->name, GF_LOG_ERROR, "Failed to create the dict");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "local not found");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Error outputting to xml");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "status all failed");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:    //                        gf_log ("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, "failed to get volname");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not get sub-cmd");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "frame->local is NULL");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Failed to get snapname");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not fetch config type");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(THIS->name, GF_LOG_ERROR, "Could not fetch config-key");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Could not fetch voldisplaycount");
./glusterfs/cli/src/cli-rpc-ops.c:                    gf_log("cli", GF_LOG_ERROR, "Could not fetch %s", buf);
./glusterfs/cli/src/cli-rpc-ops.c:                    gf_log("cli", GF_LOG_ERROR, "Could not fetch %s", buf);
./glusterfs/cli/src/cli-rpc-ops.c:                    gf_log("cli", GF_LOG_ERROR, "Could not fetch %s", buf);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Failed to get %s", key);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Failed to get %s", key);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Failed to get %s", key);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get %s", key);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Unable to fetch snapname %s ", key_buffer);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Unable to fetch snap-id %s ", key_buffer);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Unable to list details of the snaps");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Unable to get snapcount");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Unable to print snap details");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not fetch origin-volname");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not fetch snapcount");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not fetch snaps-available");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Unable to print snap details");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not fetch snap count");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Could not get %s ", key);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to fetch brickcount");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Unable to get snapname");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Unable to get snap UUID");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Unable to get volume count");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Could not get snap volume status");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get snapname");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to save snapname");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to save command type");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not save command string as delete");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not save command type in snap dict");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not get snapname");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not save snapname in snap dict");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not save command type");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not save command string as status");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Setting volume lock flag failed");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "frame->local is NULL");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not fetch status type");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Could not fetch status of snap");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get volume name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap uuid");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap uuid");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap uuid");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap uuid");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get volname");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Could not get sub-cmd");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap uuid");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get clone name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snapname name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap uuid");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Could not fetch config type");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, XDR_DECODE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log(frame->this->name, GF_LOG_ERROR, "failed to get type");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to fetch data from dict.");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to generate snapshot event");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get volume name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get clone name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snapname name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap name");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to get snap name");
./glusterfs/cli/src/cli-rpc-ops.c:                    gf_log("cli", GF_LOG_ERROR, "Snapshot info failed");
./glusterfs/cli/src/cli-rpc-ops.c:                    gf_log("cli", GF_LOG_ERROR, "Snapshot info failed");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to display snapshot list");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, "Failed to delete snap");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get sub-cmd");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not get snapcount");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get sub-cmd");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Could not get snapcount");
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "cli_to_glusterd for snapshot failed");
./glusterfs/cli/src/cli-rpc-ops.c:                gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Value of count :%d is invalid", count);
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, DICT_UNSERIALIZE_FAIL);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get command type");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, "Failed to print bitrot scrub status");
./glusterfs/cli/src/cli-rpc-ops.c:            gf_log("cli", GF_LOG_ERROR, XML_ERROR);
./glusterfs/cli/src/cli-rpc-ops.c:        gf_log("cli", GF_LOG_ERROR, "cli_to_glusterd for bitrot failed");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "spawning child failed");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "reading data from child failed");
./glusterfs/cli/src/cli-xml-output.c:            gf_log("cli", GF_LOG_ERROR, "struct member empty.");
./glusterfs/cli/src/cli-xml-output.c:                gf_log("cli", GF_LOG_ERROR, "struct member empty.");
./glusterfs/cli/src/cli-xml-output.c:                gf_log("cli", GF_LOG_ERROR, "struct member empty.");
./glusterfs/cli/src/cli-xml-output.c:                gf_log("cli", GF_LOG_ERROR, "struct member empty.");
./glusterfs/cli/src/cli-xml-output.c:                gf_log("cli", GF_LOG_ERROR, "struct member empty.");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get type");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get snap name");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get snap uuid");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get clone name");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get clone uuid");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get vol name");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get volume id");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get snap name");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get snap uuid");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get snapcount");
./glusterfs/cli/src/cli-xml-output.c:            gf_log("cli", GF_LOG_ERROR, "Could not get %s ", key);
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get %s", key);
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get %s", key);
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get %s", key);
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get %s", key);
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Unable to fetch snapname %s ", key_buffer);
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Unable to fetch snap-id %s ", key_buffer);
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Unable to fetch snap-time %s ", keyprefix);
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Fail to get snap vol count");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get snapcount");
./glusterfs/cli/src/cli-xml-output.c:            gf_log("cli", GF_LOG_ERROR, "Could not get %s ", key);
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to fetch brickcount");
./glusterfs/cli/src/cli-xml-output.c:            gf_log("cli", GF_LOG_ERROR, "Unable to get Brick Path");
./glusterfs/cli/src/cli-xml-output.c:            gf_log("cli", GF_LOG_ERROR, "Unable to get Volume Group");
./glusterfs/cli/src/cli-xml-output.c:            gf_log("cli", GF_LOG_ERROR, "Unable to get Data Percent");
./glusterfs/cli/src/cli-xml-output.c:            gf_log("cli", GF_LOG_ERROR, "Unable to get LV Size");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Unable to get snapname");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Unable to get snap UUID");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Unable to get volume count");
./glusterfs/cli/src/cli-xml-output.c:            gf_log("cli", GF_LOG_ERROR, "Could not get snap volume status");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Could not fetch status type");
./glusterfs/cli/src/cli-xml-output.c:            gf_log("cli", GF_LOG_ERROR, "Could not get snapcount");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Could not fetch auto-delete");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Could not fetch volcount");
./glusterfs/cli/src/cli-xml-output.c:            gf_log("cli", GF_LOG_ERROR, "Could not fetch %s", buf);
./glusterfs/cli/src/cli-xml-output.c:            gf_log("cli", GF_LOG_ERROR, "Could not fetch %s", buf);
./glusterfs/cli/src/cli-xml-output.c:            gf_log("cli", GF_LOG_ERROR, "Could not fetch %s", buf);
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Could not fetch config type");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "invalid command %d", cmd);
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get snap name");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get snap uuid");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get snap name");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get snap uuid");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Failed to get sub-cmd");
./glusterfs/cli/src/cli-xml-output.c:        gf_log("cli", GF_LOG_ERROR, "Error creating xml output");
./glusterfs/cli/src/cli-quotad-client.c:        gf_log("cli", GF_LOG_ERROR, "failed to register notify");
./glusterfs/cli/src/cli.c:        gf_log("cli", GF_LOG_ERROR, "Memory accounting init failed.");
./glusterfs/cli/src/cli.c:        gf_log("cli", GF_LOG_ERROR, "Failed to generate uuid.");
./glusterfs/cli/src/cli.c:        gf_log("cli", GF_LOG_ERROR, "Failed to create iobuf pool.");
./glusterfs/cli/src/cli.c:        gf_log("cli", GF_LOG_ERROR, "Failed to create event pool.");
./glusterfs/cli/src/cli.c:        gf_log("cli", GF_LOG_ERROR, "Failed to create call pool.");
./glusterfs/cli/src/cli.c:        gf_log("cli", GF_LOG_ERROR, "Failed to create frame mem pool.");
./glusterfs/cli/src/cli.c:        gf_log("cli", GF_LOG_ERROR, "Failed to create stack mem pool.");
./glusterfs/cli/src/cli.c:        gf_log("cli", GF_LOG_ERROR, "Failed to stub mem pool.");
./glusterfs/cli/src/cli.c:        gf_log("cli", GF_LOG_ERROR, "Failed to create dict pool.");
./glusterfs/cli/src/cli.c:        gf_log("cli", GF_LOG_ERROR, "Failed to create dict pair pool.");
./glusterfs/cli/src/cli.c:        gf_log("cli", GF_LOG_ERROR, "Failed to create dict data pool.");
./glusterfs/cli/src/cli.c:        gf_log("cli", GF_LOG_ERROR, "Failed to create logbuf pool.");
./glusterfs/cli/src/cli.c:        gf_log("cli", GF_LOG_ERROR, "failed to register notify");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Out of memory");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Out of memory");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Out of memory");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Out of memory");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Out of memory");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Out of memory");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Unable to parse create volume CLI");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "dict_new failed");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "dict_new failed");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log(THIS->name, GF_LOG_ERROR, "Failed to allocate memory for data");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log(THIS->name, GF_LOG_ERROR, "dict set on global key failed.");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log(THIS->name, GF_LOG_ERROR, "dict set on global key failed.");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Unable to parse add-brick CLI");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Unable to parse remove-brick CLI");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Unable to parse reset-brick CLI");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Failed to allocate dictionary");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Unable to parse reset-brick CLI");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Could not set clear-stats in dict");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Error parsing dumpoptions");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Out of memory");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log(THIS->name, GF_LOG_ERROR, "Failed to create the dict");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log(THIS->name, GF_LOG_ERROR, "failed to set volname");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log(THIS->name, GF_LOG_ERROR, "failed to set dict");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log(THIS->name, GF_LOG_ERROR, "failed to set dict");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Clone name too long");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Could not save volcount");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Too less words for snap create command");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Snapname too long");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Could not save volcount");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Description not provided");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Failed to save volname in dictionary");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid syntax");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Unable to save snap-name %s", words[2]);
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Unable to save snap-name %s", words[2]);
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Invalid option");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Unable to save force option");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Unable to save snap-name %s", words[2]);
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Value not provided for %s", key);
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Could not set global key");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Could not set global locks");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid wordcount(%d)", wordcount);
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Failed to set volname");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("", GF_LOG_ERROR, "Invalid command: Not enough arguments");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("", GF_LOG_ERROR, "Opword Mismatch");
./glusterfs/cli/src/cli-cmd-parser.c:                gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:                gf_log("cli", GF_LOG_ERROR, "create command parsing failed.");
./glusterfs/cli/src/cli-cmd-parser.c:                gf_log("cli", GF_LOG_ERROR, "Invalid Syntax");
./glusterfs/cli/src/cli-cmd-parser.c:                gf_log("cli", GF_LOG_ERROR, "clone command parsing failed.");
./glusterfs/cli/src/cli-cmd-parser.c:            gf_log("", GF_LOG_ERROR, "Opword Mismatch");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("", GF_LOG_ERROR, "Failed to set type.");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Invalid syntax");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Failed to validate volume name");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log("cli", GF_LOG_ERROR, "Unable to parse bitrot command");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log(THIS->name, GF_LOG_ERROR, "dict set on key failed");
./glusterfs/cli/src/cli-cmd-parser.c:        gf_log(THIS->name, GF_LOG_ERROR, "dict set on value failed");
./glusterfs/cli/src/cli-cmd-system.c:            gf_log(THIS->name, GF_LOG_ERROR, "failed to create frame");
./glusterfs/cli/src/cli-cmd-system.c:        gf_log("cli", GF_LOG_ERROR, "Failed to parse command");
./glusterfs/cli/src/cli-cmd-system.c:        gf_log("", GF_LOG_ERROR, "Unable to set command in dict");
./glusterfs/cli/src/cli-cmd-system.c:            gf_log("", GF_LOG_ERROR, "Unable to set %s in dict", cmd_arg_name);
./glusterfs/cli/src/cli-cmd-system.c:        gf_log("", GF_LOG_ERROR, "Unable to set cmd_args_count in dict");
./glusterfs/cli/src/cli-cmd-system.c:        gf_log("", GF_LOG_ERROR, "Unable to set volname in dict");
./glusterfs/cli/src/cli-cmd-system.c:            gf_log(THIS->name, GF_LOG_ERROR, "failed to create frame");
./glusterfs/cli/src/cli-cmd-system.c:        gf_log("", GF_LOG_ERROR, "Unable to set filename in dict");
./glusterfs/cli/src/cli-cmd-system.c:        gf_log("", GF_LOG_ERROR, "Unable to set volname in dict");
./glusterfs/cli/src/cli-cmd-system.c:            gf_log(THIS->name, GF_LOG_ERROR, "failed to create frame");
gf_log(this->name, GF_LOG_ERROR,                   "Failed to unserialize "                   "req-buffer to dictionary");
gf_log(this->name, GF_LOG_ERROR, "can't terminate %s - not found",               xlator_req.name);
gf_log(this->name, GF_LOG_ERROR,               "failed to "               "unserialize req-buffer to dictionary");
gf_log(this->name, GF_LOG_ERROR,               "failed to "               "unserialize req-buffer to dictionary");
gf_log(this->name, GF_LOG_ERROR,                   "Couldn't get "                   "xlator %s ",                   key);
gf_log(this->name, GF_LOG_ERROR,                   "xlator %s is not "                   "loaded",                   xname);
gf_log(THIS->name, GF_LOG_ERROR,               "No volfile-id provided, erroring out");
gf_log(this->name, GF_LOG_ERROR,               "failed to "               "unserialize req-buffer to dictionary");
gf_log(this->name, GF_LOG_ERROR,               "Failed to unserialize "               "req-buffer to dictionary");
gf_log(this->name, GF_LOG_ERROR,               "Couldn't get brickname from"               " dict");
gf_log(this->name, GF_LOG_ERROR,               "ctx->active->first "               "returned NULL");
gf_log(this->name, GF_LOG_ERROR,               "Failed to serialize output dict to rsp");
gf_log(THIS->name, GF_LOG_ERROR,               "Failed to unserialize "               "req buffer to dictionary");
gf_log(THIS->name, GF_LOG_ERROR, "%s xlator is not loaded",               subvol_name);
gf_log(THIS->name, GF_LOG_ERROR,                       "Error setting volname to dict");
gf_log(THIS->name, GF_LOG_ERROR,               "Failed to serialize output dict to rsp");
gf_log(THIS->name, GF_LOG_ERROR,               "Failed to "               "unserialize req-buffer to dict");
gf_log(THIS->name, GF_LOG_ERROR,               "xlator nfs-server is "               "not loaded");
gf_log(THIS->name, GF_LOG_ERROR,               "Failed to serialize output dict to rsp");
gf_log(this->name, GF_LOG_ERROR,               "failed to "               "unserialize req-buffer to dictionary");
gf_log(THIS->name, GF_LOG_ERROR,               "Failed to unserialize "               "request dictionary");
gf_log(THIS->name, GF_LOG_ERROR, "%s xlator is not loaded",               "features/barrier");
gf_log(THIS->name, GF_LOG_ERROR, "%s xlator is not loaded",               "features/changelog");
gf_log(frame->this->name, GF_LOG_ERROR,               "failed to get the 'volume file' from server");
gf_log(frame->this->name, GF_LOG_ERROR,               "failed to unserialize xdata to dictionary");
gf_log(frame->this->name, GF_LOG_ERROR,               "Failed (%s) to process servers list: %s", strerror(errno),               servers_list);
gf_log("mgmt", GF_LOG_ERROR,                       "Graph reconfigure succeeded with out having "                       "checksum.");
gf_log("mgmt", GF_LOG_ERROR,               "Server is operating at an "               "op-version which is not supported");
gf_log("mgmt", GF_LOG_ERROR, "failed to fetch volume file (key:%s)",               ctx->cmd_args.volfile_id);
gf_log(THIS->name, GF_LOG_ERROR,                   "No volfile-id provided, erroring out");
gf_log(THIS->name, GF_LOG_ERROR,               "Failed to set min-op-version"               " in request dict");
gf_log(THIS->name, GF_LOG_ERROR,               "Failed to set max-op-version"               " in request dict");
gf_log(THIS->name, GF_LOG_ERROR,                   "Failed to set brick_name in request dict");
gf_log(frame->this->name, GF_LOG_ERROR,               "failed to get the rsp from server");
gf_log(frame->this->name, GF_LOG_ERROR,               "failed to get the rsp from server");
gf_log(frame->this->name, GF_LOG_ERROR,               "Received error (%s) from server", strerror(rsp.op_errno));
gf_log("glusterfsd-mgmt", GF_LOG_ERROR,                       "failed to set remote-host: %s", server->volfile_server);
gf_log("glusterfsd-mgmt", GF_LOG_ERROR,                           "failed to fetch volume file (key:%s)",                           ctx->cmd_args.volfile_id);
gf_log(THIS->name, GF_LOG_ERROR,                   "failed to set 'transport.socket.ssl-enabled' "                   "in options dict");
gf_log(frame->this->name, GF_LOG_ERROR,               "failed to register the port with glusterd");
gf_log(frame->this->name, GF_LOG_ERROR,               "failed to register the port with glusterd");
gf_log("glusterfs", GF_LOG_ERROR, "failed to set volfile server: %s",               strerror(errno));
gf_log(frame->this->name, GF_LOG_ERROR,               "failed to unserialize xdata to dictionary");
gf_log(frame->this->name, GF_LOG_ERROR,               "Failed (%s) to process servers list: %s", strerror(errno),               servers_list);
gf_log("glfs", GF_LOG_ERROR, "failed to set volfile server: %s",               strerror(errno));
gf_log("glfs", GF_LOG_ERROR, "failed to set leaseid: %s",               strerror(errno));
gf_log("glfs", GF_LOG_ERROR, "%s: not a valid path (%s)", path,               strerror(errno));
gf_log("glfs", GF_LOG_ERROR,                   "%s: path doesn't have write permission", path);
gf_log("glfs", GF_LOG_ERROR,               "%s: failed to set statedump path, no memory", path);
gf_log(this->name, GF_LOG_ERROR,           "SSL connect error (client: %s) (server: %s)",           this->peerinfo.identifier, this->myinfo.identifier);
gf_log(this->name, GF_LOG_ERROR,               "setsockopt() for SO_REUSEADDR failed (%s)", strerror(errno));
gf_log(this->name, GF_LOG_ERROR, "binding to %s failed: %s",                       this->myinfo.identifier, strerror(errno));
gf_log(this->name, GF_LOG_ERROR, "binding to %s failed: %s",                   this->myinfo.identifier, strerror(errno));
gf_log(this->name, GF_LOG_ERROR,               "msg size (%u) bigger than the maximum allowed size on "               "sockets (%u)",               size, RPC_MAX_FRAGMENT_SIZE);
gf_log("rpc", GF_LOG_ERROR,                       "older version of protocol/process trying to "                       "connect from %s. use newer version on that node",                       this->peerinfo.identifier);
gf_log("rpc", GF_LOG_ERROR,                       "wrong MSG-TYPE (%d) received from %s", in->msg_type,                       this->peerinfo.identifier);
gf_log(this->name, GF_LOG_ERROR,                       "connection to %s failed (%s);
closing newly accepted socket %d",                    gf_log(this->name, GF_LOG_ERROR,                           "failed to register the socket "                           "with event");
gf_log(this->name, GF_LOG_ERROR, "socket creation failed (%s)",                   strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                       "setting receive window "                       "size failed: %d: %d: %s",                       priv->sock, priv->windowsize, strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                       "setting send window size "                       "failed: %d: %d: %s",                       priv->sock, priv->windowsize, strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                           "NODELAY on %d failed (%s)", priv->sock,                           strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                           "Failed to set keep-alive: %s", strerror(errno));
gf_log(this->name, GF_LOG_ERROR, "NBIO on %d failed (%s)",                       priv->sock, strerror(errno));
gf_log(this->name,                   ((sa_family == AF_UNIX) ? GF_LOG_DEBUG : GF_LOG_ERROR),                   "connection attempt on %s failed, (%s)",                   this->peerinfo.identifier, strerror(errno));
"            gf_log(this->name, GF_LOG_ERROR,                   "Thread creation "                   "failed");
gf_log(this->name, GF_LOG_ERROR, "socket creation failed (%s)",                   strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                       "setting receive window size "                       "failed: %d: %d: %s",                       priv->sock, priv->windowsize, strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                       "setting send window size failed:"                       " %d: %d: %s",                       priv->sock, priv->windowsize, strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                       "setsockopt() failed for NODELAY (%s)", strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                       "NBIO on socket %d failed "                       "(errno:%s);
closing socket",            gf_log(this->name, GF_LOG_ERROR,                   "__socket_server_bind failed;
"            gf_log(this->name, GF_LOG_ERROR,                   "could not set socket %d to listen mode (errno:%s);
gf_log(this->name, GF_LOG_ERROR,                   "'transport.socket.keepalive' takes only "                   "boolean options, not taking any action");
gf_log(this->name, GF_LOG_ERROR, "invalid number format: %s",                   optstr);
gf_log(this->name, GF_LOG_ERROR,                   "'non-blocking-io' takes only boolean options,"                   " not taking any action");
gf_log(this->name, GF_LOG_ERROR,                       "failed to open %s, "                       "DH ciphers are disabled",                       dh_param);
gf_log(this->name, GF_LOG_ERROR,                       "failed to read DH param from %s: %s "                       "DH ciphers are disabled.",                       dh_param, ERR_error_string(err, NULL));
gf_log(this->name, GF_LOG_ERROR,                       "failed to load EC curve %s: %s. "                       "ECDH ciphers are disabled.",                       ec_curve, ERR_error_string(err, NULL));
gf_log(this->name, GF_LOG_ERROR,                   "failed to find any valid ciphers");
gf_log(this->name, GF_LOG_ERROR, "could not load our cert at %s",                   priv->ssl_own_cert);
gf_log(this->name, GF_LOG_ERROR, "could not load private key at %s",                   priv->ssl_private_key);
gf_log(this->name, GF_LOG_ERROR,                   "'non-blocking-io' takes only boolean options,"                   " not taking any action");
gf_log(this->name, GF_LOG_ERROR,                   "'transport.socket.nodelay' takes only "                   "boolean options, not taking any action");
gf_log(this->name, GF_LOG_ERROR, "invalid number format: %s",                   optstr);
gf_log(this->name, GF_LOG_ERROR,                   "'transport.socket.keepalive' takes only "                   "boolean options, not taking any action");
gf_log(this->name, GF_LOG_ERROR,                   "invalid value given for ssl-enabled boolean");
gf_log(this->name, GF_LOG_ERROR,                   "cannot bind to unix-domain socket %d (%s)", sock,                   strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                   "transport.address-family not specified. "                   "Could not guess default value from (remote-host:%s or "                   "transport.unix.connect-path:%s) options",                   data_to_str(remote_host_data),                   data_to_str(connect_path_data));
gf_log(this->name, GF_LOG_ERROR,                   "unknown address-family (%s) specified", address_family);
gf_log(this->name, GF_LOG_ERROR,               "option remote-host missing in volume %s", this->name);
gf_log(this->name, GF_LOG_ERROR,               "option remote-host has data NULL in volume %s", this->name);
gf_log(this->name, GF_LOG_ERROR,                   "option remote-port has invalid port in volume %s",                   this->name);
gf_log(this->name, GF_LOG_ERROR, "DNS resolution failed on host %s",               remote_host);
gf_log(this->name, GF_LOG_ERROR,               "option transport.unix.connect-path not specified for "               "address-family unix");
gf_log(this->name, GF_LOG_ERROR,               "connect-path value length %d > %d octets",               connect_path_data->len + 1, UNIX_PATH_MAX);
gf_log(this->name, GF_LOG_ERROR,               "transport.unix.connect-path is null-string");
gf_log(this->name, GF_LOG_ERROR,               "missing option transport.socket.listen-path");
gf_log(this->name, GF_LOG_ERROR,               "option transport.unix.listen-path has value length "               "%" GF_PRI_SIZET " > %d",               strlen(listen_path), UNIX_PATH_MAX);
gf_log(this->name, GF_LOG_ERROR,               "getaddrinfo failed for host %s, service %s (%s)", listen_host,               service, gai_strerror(ret));
gf_log(this->name, GF_LOG_ERROR, "unknown address family %d",                   sockaddr->sa_family);
gf_log(this->name, GF_LOG_ERROR, "unknown address-family %d",                   sockaddr->sa_family);
gf_log(this->name, GF_LOG_ERROR,                   "unknown address family (%s) specified", address_family);
gf_log(this->name, GF_LOG_ERROR, "getnameinfo failed (%s)",               gai_strerror(ret));
gf_log(this->name, GF_LOG_ERROR,                       "cannot fill inet/inet6 identifier for server");
gf_log(this->name, GF_LOG_ERROR,                       "cannot fill inet/inet6 identifier for client");
gf_log(this->name, GF_LOG_ERROR, "unknown address family (%d)",                   ((struct sockaddr *)&this->myinfo.sockaddr)->sa_family);
gf_log(conn->name, GF_LOG_ERROR,               "bailing out frame type(%s), op(%s(%d)), xid = 0x%x, "               "unique = %" PRIu64 ", sent = %s, timeout = %d for %s",               trav->rpcreq->prog->progname,               (trav->rpcreq->prog->procnames)                   ? trav->rpcreq->prog->procnames[trav->rpcreq->procnum]                   : "--",               trav->rpcreq->procnum, trav->rpcreq->xid,               ((call_frame_t *)(trav->frame))->root->unique, frame_sent,               conn->frame_timeout, peerid);
gf_log(conn->name, GF_LOG_ERROR,                       "Error adding to timer event queue");
gf_log(conn->name, GF_LOG_ERROR,               "cannot lookup the saved frame for reply with xid (%u)", xid);
gf_log(conn->name, GF_LOG_ERROR, "no request with frame for xid (%u)",               xid);
gf_log("rpc-clnt", GF_LOG_ERROR,               "lkowner field is too "               "big (%d), it does not fit in the rpc-header",               au->lk_owner.lk_owner_len);
gf_log("rpc-auth", GF_LOG_ERROR,               "lkowner field is too "               "big (%d), it does not fit in the rpc-header",               au->lk_owner.lk_owner_len);
gf_log(clnt->conn.name, GF_LOG_ERROR,               "Program registration failed:"               " %s, Num: %d, Ver: %d",               program->progname, program->prognum, program->progver);
gf_log("rpc-transport", GF_LOG_ERROR,               "'option transport-type <xx>' missing in volume '%s'",               trans_name);
gf_log("rpc-transport", GF_LOG_ERROR, "dlsym (rpc_transport_ops) on %s",               dlerror());
gf_log("rpc-transport", GF_LOG_ERROR,               "dlsym (gf_rpc_transport_init) on %s", dlerror());
gf_log("rpc-transport", GF_LOG_ERROR,               "dlsym (gf_rpc_transport_fini) on %s", dlerror());
gf_log("rpc-transport", GF_LOG_ERROR,                   "volume option validation failed");
gf_log(THIS->name, GF_LOG_ERROR,               "failed to register the port with glusterd");
gf_log("rpcsvc", GF_LOG_ERROR,                                     \                   "error getting memory for rpc request");
\            gf_log(GF_RPCSVC, GF_LOG_ERROR,                   "RPC procedure %d not available for Program %s", procnum,                   program->progname);
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "RPC Program procedure not"               " available for procedure %d in %s for  %s",               req->procnum, program->progname, peername);
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "RPC Program procedure not"               " available for procedure %d in %s for %s",               req->procnum, program->progname, peername);
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "RPC version not supported "               "(XID: 0x%" GF_PRI_RPC_XID ", Ver: %" GF_PRI_RPC_VERSION               ", Program: %" GF_PRI_RPC_PROG_ID               ", "               "ProgVers: %" GF_PRI_RPC_PROG_VERS ", Proc: %" GF_PRI_RPC_PROC               ") "               "from trans (%s)",               rpc_call_xid(&rpcmsg), rpc_call_rpcvers(&rpcmsg),               rpc_call_program(&rpcmsg), rpc_call_progver(&rpcmsg),               rpc_call_progproc(&rpcmsg), trans->name);
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "auth failed on request. "               "(XID: 0x%" GF_PRI_RPC_XID ", Ver: %" GF_PRI_RPC_VERSION               ", Program: %" GF_PRI_RPC_PROG_ID               ", "               "ProgVers: %" GF_PRI_RPC_PROG_VERS ", Proc: %" GF_PRI_RPC_PROC               ") "               "from trans (%s)",               rpc_call_xid(&rpcmsg), rpc_call_rpcvers(&rpcmsg),               rpc_call_program(&rpcmsg), rpc_call_progver(&rpcmsg),               rpc_call_progproc(&rpcmsg), trans->name);
gf_log("rpcsvc", GF_LOG_ERROR,               "rpc actor (%d:%d:%d) failed to complete successfully",               req->prognum, req->progver, req->procnum);
gf_log(GF_RPCSVC, GF_LOG_ERROR, "invalid address family (%d)",                   trans->peerinfo.sockaddr.ss_family);
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "Request received from non-"               "privileged port. Failing request for %s.",               req->trans->peerinfo.identifier);
gf_log("rpc-clnt", GF_LOG_ERROR,               "Failed to build record "               " header");
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "Failed to build record "               " header");
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "failed to submit message "               "(XID: 0x%x, Program: %s, ProgVers: %d, Proc: %d) to "               "rpc-transport (%s)",               req->xid, req->prog ? req->prog->progname : "(not matched)",               req->prog ? req->prog->progver : 0, req->procnum,               trans ? trans->name : "");
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "Could not register the IPv6"               " service with rpcbind");
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "Could not unregister the IPv6"               " service with rpcbind");
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "Could not register with"               " portmap %d %d %u",               newprog->prognum, newprog->progver, port);
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "Could not unregister with"               " portmap");
gf_log(GF_RPCSVC, GF_LOG_ERROR, "invalid port for listener %s",                       listener->trans->name);
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "portmap unregistration of"               " program failed");
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "rpcbind (ipv6)"               " unregistration of program failed");
gf_log(GF_RPCSVC, GF_LOG_ERROR,                   "Program "                   "unregistration failed"                   ": %s, Num: %d, Ver: %d, Port: %d",                   program->progname, program->prognum, program->progver,                   program->progport);
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "Program registration failed:"               " %s, Num: %d, Ver: %d, Port: %d",               program->progname, program->prognum, program->progver,               program->progport);
gf_log(GF_RPCSVC, GF_LOG_ERROR,                   "Failed to parse "                   "dict");
gf_log(GF_RPCSVC, GF_LOG_ERROR,                   "Failed to parse bool "                   "string");
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "Failed to init "               "authentication");
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "Failed to"               " read rpc-auth.ports.insecure value");
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "Failed to"               " convert rpc-auth.ports.insecure value");
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "Failed to get mempool for DRC, drc-size: %d", drc_size);
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "registration of drc_notify function failed");
gf_log(GF_RPCSVC, GF_LOG_ERROR,               "Registration of auth failed:"               " %s",               authitem->name);
gf_log(this->name, GF_LOG_ERROR,               "hardlink failed: %s exceeds max link count (%u/%u).",               real_oldpath, stbuf.ia_nlink, priv->max_hardlinks);
gf_log(this->name, GF_LOG_ERROR,               "Calloc is failed to allocate "               "memory for diskxl object");
gf_log("POSIX", GF_LOG_ERROR,                       "setxattr failed - %s"                       " %d",                       GF_CS_OBJECT_SIZE, ret);
gf_log("POSIX", GF_LOG_ERROR,                       "truncate failed - %s"                       " %d",                       GF_CS_OBJECT_SIZE, ret);
gf_log("POSIX", GF_LOG_ERROR,                           "removexattr "                           "failed post processing- %s"                           " %d",                           GF_CS_OBJECT_SIZE, ret);
gf_log(this->name, GF_LOG_ERROR, "setxattr failed - %s %d",                       custom_xattrs->key, ret);
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting init"               "failed");
gf_log(this->name, GF_LOG_ERROR,                   "client sent umask, but not the original mode");
gf_log(this->name, GF_LOG_ERROR,                   "failed to reconfigure snapshot-directory option to %s",                   path);
\            gf_log(this->name, GF_LOG_ERROR,                                   \                   "Cannot allocate new call frame.");
\            gf_log(this->name, GF_LOG_ERROR,                                   \                   "Cannot allocate function stub.");
\            gf_log(this->name, GF_LOG_ERROR,                                   \                   "Cannot allocate function local.");
\        gf_log(this->name, GF_LOG_ERROR,               "translator needs a single subvolume.");
gf_log(this->name, GF_LOG_ERROR,               "dangling volume. please check volfile.");
gf_log(this->name, GF_LOG_ERROR,                       "Could not fetch "                       " barrier key from the dictionary.");
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting "               "initialization failed.");
gf_log(this->name, GF_LOG_ERROR,               "'barrier' not configured with exactly one child");
gf_log(this->name, GF_LOG_ERROR,               "Missing inode, can't adjust for quota");
gf_log(this->name, GF_LOG_ERROR,               "FATAL: quota (%s) not configured for min of 1 child",               this->name);
gf_log(this->name, GF_LOG_ERROR,               "Invalid length: Total length is less "               "than minimum length.");
gf_log(this->name, GF_LOG_ERROR, "gfid: %s. No null byte present.",               args->gfid);
gf_log(this->name, GF_LOG_ERROR, "gfid: %s. Invalid length",                   args->gfid);
gf_log(this->name, GF_LOG_ERROR, "gfid: %s. Invalid length",                   args->gfid);
gf_log(this->name, GF_LOG_ERROR, "gfid: %s. Invalid length",                   args->gfid);
gf_log(this->name, GF_LOG_ERROR, "gfid: %s. Invalid length",                   args->gfid);
gf_log(this->name, GF_LOG_ERROR, "gfid: %s. Invalid length",                   args->gfid);
gf_log(this->name, GF_LOG_ERROR, "gfid: %s. Invalid length",                   args->gfid);
gf_log(this->name, GF_LOG_ERROR, "gfid: %s. Invalid length",                   args->gfid);
gf_log(this->name, GF_LOG_ERROR, "gfid: %s. Invalid length",               args->gfid);
gf_log(this->name, GF_LOG_ERROR,               "not configured with exactly one child. exiting");
gf_log(this->name, GF_LOG_ERROR,               "failed to create local_t's memory pool");
gf_log(this->name, GF_LOG_ERROR,               "'dentry-fop-serializer' not configured with exactly one child");
gf_log("locks", GF_LOG_ERROR,               "unlock on %s "               "(type=ENTRYLK_WRLCK) attempted but no matching lock "               "found",               lock->basename);
gf_log(this->name, GF_LOG_ERROR,                   "Unexpected case in entrylk (cmd=%d). Please file"                   "a bug report at http://bugs.gluster.com",                   cmd);
gf_log(this->name, GF_LOG_ERROR,               "got error (errno=%d, stderror=%s) from child", op_errno,               strerror(op_errno));
gf_log(this ? this->name : "locks", GF_LOG_ERROR,               "truncate failed with "               "ret: %d, error: %s",               op_ret, strerror(op_errno));
gf_log(this ? this->name : "locks", GF_LOG_ERROR,               "truncate on %s failed with"               " ret: %d, error: %s",               loc->path, -1, strerror(ENOMEM));
gf_log(this ? this->name : "locks", GF_LOG_ERROR,               "ftruncate failed with"               " ret: %d, error: %s",               -1, strerror(ENOMEM));
gf_log(this->name, GF_LOG_ERROR,                   "clear locks: invalid lock type %d", args.type);
gf_log(this->name, GF_LOG_ERROR,                   "clear locks of type %s failed: %s",                   clrlk_type_names[args.type], strerror(*op_errno));
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting init"               "failed");
gf_log(this->name, GF_LOG_ERROR,               "failed to create local_t's memory pool");
gf_log(this->name, GF_LOG_ERROR,               " Matching lock not found for unlock %llu-%llu, by %s "               "on %p for gfid:%s",               (unsigned long long)lock->fl_start,               (unsigned long long)lock->fl_end, lkowner_utoa(&lock->owner),               lock->client, inode ? uuid_utoa(inode->gfid) : "UNKNOWN");
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting "               "initialization failed.");
gf_log(this->name, GF_LOG_ERROR,               "'thin_arbiter' not configured with exactly one child");
gf_log(this->name, GF_LOG_ERROR,               "not configured with children. exiting");
gf_log(this->name,               (-ret == ENOENT || -ret == ESTALE) ? GF_LOG_DEBUG : GF_LOG_ERROR,               "readdirp failed "               "for %s: %s",               loc->path, strerror(-ret));
gf_log(this->name, GF_LOG_ERROR,               "failed to get inode ctx for "               "%s",               loc->path);
gf_log(this->name, GF_LOG_ERROR,               "failed to get inode ctx for "               "%s",               loc->path);
gf_log(this->name, GF_LOG_ERROR,               "get contri_key "               "failed for %s",               uuid_utoa(contri->gfid));
gf_log(this->name, GF_LOG_ERROR,               "get contri_key "               "failed for %s",               uuid_utoa(contri->gfid));
gf_log(this->name, GF_LOG_ERROR,               "failed to get inode ctx for "               "%s",               loc->path);
gf_log(this->name, GF_LOG_ERROR,                   "Failed to spawn "                   "new synctask");
gf_log(this->name, GF_LOG_ERROR,               "parent_loc fill failed for "               "child inode %s: ",               uuid_utoa(loc->inode->gfid));
gf_log(this->name,                       (-ret == ENOENT || -ret == ESTALE) ? GF_LOG_DEBUG                                                          : GF_LOG_ERROR,                       "build ancestry failed for inode %s",                       uuid_utoa(child_loc.inode->gfid));
gf_log(this->name, GF_LOG_ERROR,                   "parent_loc fill "                   "failed for child inode %s: ",                   uuid_utoa(child_loc.inode->gfid));
gf_log(this->name, GF_LOG_ERROR,                       "Failed to "                       "create contribution node for %s, "                       "abort update txn",                       child_loc.path);
gf_log(this->name,               (-ret == ENOENT || -ret == ESTALE) ? GF_LOG_DEBUG : GF_LOG_ERROR,               "opendir failed "               "for %s: %s",               loc->path, strerror(-ret));
gf_log(this->name,                   (-ret == ENOENT || -ret == ESTALE) ? GF_LOG_DEBUG                                                      : GF_LOG_ERROR,                   "readdirp failed "                   "for %s: %s",                   loc->path, strerror(-ret));
gf_log(this->name, GF_LOG_ERROR,               "%s: Failed to remove "               "extended attribute: %s",               local->loc.path, k);
gf_log(this->name, GF_LOG_ERROR,               "Failed to create synctask "               "for cleaning up quota extended attributes");
gf_log(this->name, GF_LOG_ERROR,                   "failed to get the "                   "path for the entry %s",                   entry->d_name);
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting init"               " failed");
gf_log(this->name, GF_LOG_ERROR,               "please specify the volume-uuid"               "in the translator options");
gf_log(this->name, GF_LOG_ERROR, "invalid volume uuid %s",               priv->volume_uuid);
gf_log(this->name, GF_LOG_ERROR,               "please specify the timestamp-file"               "in the translator options");
gf_log(this->name, GF_LOG_ERROR,                   "Invalid quota "                   "version %d",                   priv->version);
gf_log(this->name, GF_LOG_ERROR,               "marker translator needs subvolume defined.");
gf_log(this->name, GF_LOG_ERROR, "Invalid quota version %d",               priv->version);
gf_log(this->name, GF_LOG_ERROR,               "failed to create local_t's memory pool");
gf_log("marker", GF_LOG_ERROR, "parent is NULL for %s",               uuid_utoa(inode->gfid));
gf_log("marker", GF_LOG_ERROR, "failed to resolve path for %s",               uuid_utoa(inode->gfid));
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting "               "initialization failed.");
gf_log(this->name, GF_LOG_ERROR,               "'arbiter' not configured with exactly one child");
gf_log(this->name, GF_LOG_ERROR, "Invalid operation mode (%d)",               priv->op_mode);
gf_log(this->name, GF_LOG_ERROR, "Invalid operation mode (%d) ",               priv->op_mode);
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting init"               "failed");
gf_log(this->name, GF_LOG_ERROR,               "Zlib output buffer overflow"               " ->ncount (%d) | ->MAX_IOVEC (%d)",               ci->ncount, MAX_IOVEC);
gf_log(this->name, GF_LOG_ERROR, "unable to init Zlib (retval: %d)",               ret);
gf_log(this->name, GF_LOG_ERROR,                   "Cannot allocate xdata"                   " dict");
gf_log(this->name, GF_LOG_ERROR,               "Data deflated, but could not set canary"               " value in dict for identification");
gf_log(this->name, GF_LOG_ERROR,               "Checksum or length mismatched in inflated data");
gf_log(this->name, GF_LOG_ERROR,                       "Failed to create \"shard_unlink\" thread");
gf_log(this->name, GF_LOG_ERROR,               "Failed to init mutex for \"shard_unlink\" thread");
gf_log(this->name, GF_LOG_ERROR,               "Failed to init cond var for \"shard_unlink\" thread");
gf_log(this->name, GF_LOG_ERROR,               "Failed to initialize resources for \"shard_unlink\" thread");
gf_log(this->name, GF_LOG_ERROR,               "rename trash directory "               "failed: %s",               strerror(op_errno));
gf_log(this->name, GF_LOG_ERROR,               "mkdir failed for "               "internal op directory : %s",               strerror(op_errno));
gf_log(this->name, GF_LOG_ERROR,               "mkdir failed for trash"               " directory : %s",               strerror(op_errno));
gf_log(this->name, GF_LOG_ERROR,               "Directory creation failed [%s]. "               "Therefore unlinking %s without moving to trash "               "directory",               strerror(op_errno), local->loc.name);
gf_log(this->name, GF_LOG_ERROR,               "Directory creation failed [%s]. "               "Therefore truncating %s without moving the "               "original copy to trash directory",               strerror(op_errno), local->loc.name);
gf_log(this->name, GF_LOG_ERROR,                       "failed to create trash inode_table"                       "  during graph reconfigure");
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting init"               "failed");
gf_log(this->name, GF_LOG_ERROR,               "not configured with exactly one child. exiting");
gf_log(this->name, GF_LOG_ERROR,               "no option specified for 'max-trashable-file-size', "               "using default = %lld MB",               GF_DEFAULT_MAX_FILE_SIZE / GF_UNIT_MB);
gf_log(this->name, GF_LOG_ERROR,               "failed to create local_t's memory pool");
gf_log(this->name, GF_LOG_ERROR,               "no option specified for 'brick-path'");
gf_log(this->name, GF_LOG_ERROR,                   "failed to create trash inode_table disable trash");
gf_log(this->name, GF_LOG_ERROR,               "'quiesce' not configured with exactly one child");
gf_log(this->name, GF_LOG_ERROR,                       "failed to create the quiesce-dequeue thread");
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting "               "initialization failed.");
gf_log(this->name, GF_LOG_ERROR,               "translator not configured with exactly one child");
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting "               "initialization failed.");
gf_log(this->name, GF_LOG_ERROR,                           "Cannot set atime less than "                           "the mtime for a WORM-Retained "                           "file");
gf_log(this->name, GF_LOG_ERROR,                           "Cannot decrease the atime of a"                           " WORM-Retained file in "                           "Enterprise mode");
gf_log(this->name, GF_LOG_ERROR,                           "Cannot set atime less than "                           "the mtime for a WORM-Retained "                           "file");
gf_log(this->name, GF_LOG_ERROR,                           "Cannot decrease the atime of a"                           " WORM-Retained file in "                           "Enterprise mode");
gf_log(this->name, GF_LOG_ERROR,                   "Failed to set the fd ctx "                   "for gfid:%s . Worm feature may not work for the gfid",                   uuid_utoa(inode->gfid));
gf_log(this->name, GF_LOG_ERROR,               "translator not configured with exactly one child");
gf_log(this->name, GF_LOG_ERROR,               "failed to create read_only_priv_t's memory pool");
gf_log(this->name, GF_LOG_ERROR,                   "Error in setting "                   "the dict");
gf_log("fuse-resolve", GF_LOG_ERROR,               "Invalid pointer for state->resolve_now");
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "inconsistent write to fuse device: "               "written %zd, expectd %d",               res, fouh->len);
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "failed to dump fuse message (W): %s", strerror(errno));
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "send_fuse_iov() "               "failed: %s",               strerror(ret));
gf_log("glusterfs-fuse", GF_LOG_ERROR,                   "unique %" PRIu64 " INTERRUPT for %" PRIu64                   ":"                   " failed to allocate timed message",                   finh->unique, fii->unique);
gf_log("fuse", GF_LOG_ERROR, "failed to resolve path %s",               state->loc.path);
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "%" PRIu64 ": GETATTR %" PRIu64 " (%s) resolution failed",               state->finh->unique, state->finh->nodeid,               uuid_utoa(state->resolve.gfid));
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "%" PRIu64 ": SETATTR %" PRIu64 " (%s) resolution failed",               state->finh->unique, state->finh->nodeid,               uuid_utoa(state->resolve.gfid));
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "%" PRIu64 ": ACCESS %" PRIu64 " (%s) resolution failed",               state->finh->unique, state->finh->nodeid,               uuid_utoa(state->resolve.gfid));
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "READLINK %" PRIu64 " (%s) resolution failed",               state->finh->unique, uuid_utoa(state->resolve.gfid));
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "MKNOD %" PRIu64 "/%s (%s/%s) resolution failed",               state->finh->nodeid, state->resolve.bname,               uuid_utoa(state->resolve.gfid), state->resolve.bname);
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "MKDIR %" PRIu64 " (%s/%s) resolution failed",               state->finh->nodeid, uuid_utoa(state->resolve.gfid),               state->resolve.bname);
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "UNLINK %" PRIu64 " (%s/%s) resolution failed",               state->finh->nodeid, uuid_utoa(state->resolve.gfid),               state->resolve.bname);
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "RMDIR %" PRIu64 " (%s/%s) resolution failed",               state->finh->nodeid, uuid_utoa(state->resolve.gfid),               state->resolve.bname);
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "SYMLINK %" PRIu64 " (%s/%s) -> %s resolution failed",               state->finh->nodeid, uuid_utoa(state->resolve.gfid),               state->resolve.bname, state->name);
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "RENAME %" PRIu64 " %s/%s -> %s/%s src resolution failed",               state->finh->unique, uuid_utoa_r(state->resolve.gfid, loc_uuid),               state->resolve.bname,               uuid_utoa_r(state->resolve2.gfid, loc2_uuid),               state->resolve2.bname);
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "RENAME %" PRIu64 " %s/%s -> %s/%s dst resolution failed",               state->finh->unique, uuid_utoa_r(state->resolve.gfid, loc_uuid),               state->resolve.bname,               uuid_utoa_r(state->resolve2.gfid, loc2_uuid),               state->resolve2.bname);
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "%" PRIu64 ": OPEN %s resolution failed", state->finh->unique,               uuid_utoa(state->resolve.gfid));
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "%" PRIu64 ": WRITE iobref allocation failed",               state->finh->unique);
gf_log("glusterfs-fuse", GF_LOG_ERROR,                   "FLUSH unique %" PRIu64                   ":"                   " interrupt record allocation failed",                   finh->unique);
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "%" PRIu64 ": SETXATTR dict allocation failed", finh->unique);
gf_log("glusterfs-fuse", GF_LOG_ERROR,                   "%" PRIu64 ": SETXATTR value allocation failed",                   finh->unique);
gf_log(THIS->name, GF_LOG_ERROR, "sizes not equal %d != %d",                       len, len_next);
gf_log("glusterfs-fuse", GF_LOG_ERROR,                       "GETLK not supported. loading "                       "'features/posix-locks' on server side "                       "will add GETLK support.");
gf_log("glusterfs-fuse", GF_LOG_ERROR,                       "SETLK not supported. loading "                       "'features/posix-locks' on server side "                       "will add SETLK support.");
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "SETLK%s unique %" PRIu64               ":"               " interrupt record allocation failed",               state->finh->opcode == FUSE_SETLK ? "" : "W",               state->finh->unique);
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "unsupported FUSE protocol version %d.%d", fini->major,               fini->minor);
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "failed to start timed response thread (%s)", strerror(errno));
gf_log("glusterfs-fuse", GF_LOG_ERROR,                   "failed to start messenger daemon (%s)", strerror(errno));
gf_log("glusterfs-fuse", GF_LOG_ERROR, "FUSE init failed (%s)",               strerror(ret));
gf_log(this->name, GF_LOG_ERROR, "first lookup on root failed (%s)",               strerror(errno));
gf_log(this->name, GF_LOG_ERROR, "poll error %s",                           strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                           "mount pipe closed without status");
gf_log(this->name, GF_LOG_ERROR,                   "Server authenication failed. Shutting down.");
gf_log(this->name, GF_LOG_ERROR, "poll error %s",                               strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                               "mount pipe closed without status");
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting init"               "failed");
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "failed to dump fuse message (R): %s", strerror(errno));
gf_log("fuse", GF_LOG_ERROR,               "Mandatory option 'mountpoint' is not specified.");
gf_log(this_xl->name, GF_LOG_ERROR, "%s %s does not exist",                   ZR_MOUNTPOINT_OPT, value_string);
gf_log(this_xl->name, GF_LOG_ERROR,                   "Mountpoint %s seems to have a stale "                   "mount, run 'umount %s' and try again.",                   value_string, value_string);
gf_log(this_xl->name, GF_LOG_ERROR, "%s %s is not a directory",               ZR_MOUNTPOINT_OPT, value_string);
gf_log("glusterfs-fuse", GF_LOG_ERROR,                   "failed to remove old fuse dump file %s: %s", value_string,                   strerror(errno));
gf_log("glusterfs-fuse", GF_LOG_ERROR,                   "failed to open fuse dump file %s: %s", value_string,                   strerror(errno));
gf_log("glusterfs-fuse", GF_LOG_ERROR,               "Failed to initialize "               "group cache.");
gf_log(this_xl->name, GF_LOG_ERROR,               "could not create pipe to separate mount process");
gf_log(this_xl->name, GF_LOG_ERROR,                   "could not create a new event history");
gf_log(this->name, GF_LOG_ERROR,                   "getpwuid_r(%u) "                   "failed",                   frame->root->uid);
gf_log(this->name, GF_LOG_ERROR,                   "getpwuid_r(%u): "                   "no matching record",                   frame->root->uid);
gf_log(this->name, GF_LOG_ERROR,                   "could not map %s to "                   "group list (ngroups %d, max %d)",                   result->pw_name, ngroups, GF_MAX_AUX_GROUPS);
gf_log(this->name, GF_LOG_ERROR, "failed to open %s: %s", filename,                   strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                       "failed to allocate gid buffer");
gf_log(this->name, GF_LOG_ERROR, "cannot find gid list in %s",                       filename);
gf_log(this->name, GF_LOG_ERROR, "failed to parse %s",                           filename);
gf_log(GF_NFS, GF_LOG_ERROR,                   "Failed to parse "                   "transport.socket.bind-address string");
gf_log(GF_NFS, GF_LOG_ERROR,               "dict_set_str error when trying to enable ipv6");
gf_log(this->name, GF_LOG_ERROR,                   "failed to set transport.address-family");
gf_log(this->name, GF_LOG_ERROR,                       "failed to set "                       "transport.address-family "                       "to %s",                       addr_family);
gf_log("brick-op", GF_LOG_ERROR,                       "Failed to fetch disk"                       " utilization from the brick (%s:%s). Please "                       "check health of the brick. Error code was %s",                       brickinfo->hostname, brickinfo->path, strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                   "Failed to set transport.address-family for %s",                   volinfo->volname);
gf_log("glusterd", GF_LOG_ERROR,               "failed to generate user-xlator option matcher");
gf_log("glusterd", GF_LOG_ERROR, "invalid user xlator position %s = %s",               key, value_str);
gf_log(THIS->name, GF_LOG_ERROR,               "Could not generate gfproxy client volfiles");
gf_log(this->name, GF_LOG_ERROR,                       "glusterd_add_bulk_volume %s"                       " thread creation failed",                       "bulkvoldict");
gf_log(this->name, GF_LOG_ERROR,                           "adding brick to process failed");
gf_log(this->name, GF_LOG_ERROR, "brick process %d is not running",               pid);
gf_log(this->name, GF_LOG_ERROR, "brick process %d is not running",               pid);
gf_log(this->name, GF_LOG_ERROR, "open failed %s to open a file %s",               strerror(errno), fname);
gf_log(this->name, GF_LOG_ERROR,               "Missing %s extended attribute on brick root (%s),"               " brick is deemed not to be a part of the volume (%s) ",               GF_XATTR_VOL_ID_KEY, brickinfo->path, volinfo->volname);
gf_log(this->name, GF_LOG_ERROR,               "Mismatching %s extended attribute on brick root (%s),"               " brick is deemed not to be a part of the volume (%s)",               GF_XATTR_VOL_ID_KEY, brickinfo->path, volinfo->volname);
gf_log("", GF_LOG_ERROR,                       "Failed to get "                       "volfile path");
gf_log(this->name, GF_LOG_ERROR,               "mount command"               " failed.");
gf_log("", GF_LOG_ERROR,                   "Null UUID while attempting to read peer from '%s'",                   filepath);
gf_log(this->name, GF_LOG_ERROR, "%s",                   "Failed to aggregate response from "                   " node/brick");
gf_log(this->name, GF_LOG_ERROR,               "Failed to get "               "no-timestamp flag ");
gf_log(this->name, GF_LOG_ERROR,               "Failed to set " GF_INTERNAL_IGNORE_DEEM_STATFS " in dict");
gf_log(this->name, GF_LOG_ERROR,               "failed to set xattr in dict for %s (linkto:%s)", loc->path,               to->name);
gf_log(this->name, GF_LOG_ERROR,               "%s: failed to set 'linkto' key in dict", loc->path);
gf_log(this->name, GF_LOG_ERROR,               "%s: failed to set gfid in dict for create", loc->path);
gf_log(this->name, GF_LOG_ERROR,                   "Create dst failed"                   " on - %s for file - %s",                   hashed_subvol->name, loc->path);
gf_log(this->name, GF_LOG_ERROR,                   "%s: failed to set last-fsync flag on "                   "%s (%s)",                   loc->path, hashed_subvol->name, strerror(ENOMEM));
gf_log(this->name, GF_LOG_ERROR,                   "failed to set xattr in dict for %s (linkto:%s)", loc->path,                   hashed_subvol->name);
gf_log(this->name, GF_LOG_ERROR,                   "Failed to allocate "                   "memory for container");
gf_log(this->name, GF_LOG_ERROR,                   "Failed to allocate "                   "memory for df_entry");
gf_log(this->name, GF_LOG_ERROR,                   "Failed to allocate "                   "memory for loc");
gf_log(this->name, GF_LOG_ERROR,               "dht_dfoffset_ctx_t"               "initialization failed");
gf_log(this->name, GF_LOG_ERROR,               "failed to set dict for "               "key: %s",               conf->link_xattr_name);
gf_log(this->name, GF_LOG_ERROR,               "Failed to open dir %s, "               "err:%d",               loc->path, -ret);
gf_log(this->name, GF_LOG_ERROR,                       "Child loc"                       " build failed for entry: %s",                       entry->d_name);
gf_log(this->name, GF_LOG_ERROR, "Failed to set %s",               conf->commithash_xattr_name);
gf_log(this->name, GF_LOG_ERROR,               "Failed to set commit hash on %s. "               "Rebalance cannot proceed.",               loc.path);
gf_log(this->name, GF_LOG_ERROR,               "delay-gen not configured with one subvolume");
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting init"               " failed");
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting init"               " failed");
gf_log(this->name, GF_LOG_ERROR,               "error-gen not configured with one subvolume");
gf_log(this->name, GF_LOG_ERROR,               "gf_strdup failed, failing username "               "resolution.");
gf_log(this->name, GF_LOG_ERROR,               "gf_strdup failed, failing username "               "resolution.");
gf_log(this->name, GF_LOG_ERROR,               "failed to set "               "interval %d",               interval);
gf_log(this->name, GF_LOG_ERROR,               "failed to set "               "duration(%d) - %" PRId64,               interval, sec);
gf_log(this->name, GF_LOG_ERROR,               "failed to set total "               "read(%d) - %" GF_PRI_ATOMIC,               interval, GF_ATOMIC_GET(stats->data_read));
gf_log(this->name, GF_LOG_ERROR,               "failed to set total "               "write(%d) - %" GF_PRI_ATOMIC,               interval, GF_ATOMIC_GET(stats->data_written));
gf_log(this->name, GF_LOG_ERROR,                       "failed to "                       "set read-%db+, with: %" PRId64,                       (1 << i), count);
gf_log(this->name, GF_LOG_ERROR,                       "failed to "                       "set write-%db+, with: %" PRId64,                       (1 << i), count);
gf_log(this->name, GF_LOG_ERROR,                   "failed to set "                   "%s-fop-hits: %" GF_PRI_ATOMIC,                   gf_fop_list[i], fop_hits);
gf_log(this->name, GF_LOG_ERROR,                   "failed to set %s "                   "avglatency(%d) with %f",                   gf_fop_list[i], interval, stats->latency[i].avg);
gf_log(this->name, GF_LOG_ERROR,                   "failed to set %s "                   "minlatency(%d) with %f",                   gf_fop_list[i], interval, stats->latency[i].min);
gf_log(this->name, GF_LOG_ERROR,                   "failed to set %s "                   "maxlatency(%d) with %f",                   gf_fop_list[i], interval, stats->latency[i].max);
gf_log(this->name, GF_LOG_ERROR,                   "failed to "                   "set %s-upcall-hits: %" PRIu64,                   gf_upcall_list[i], fop_hits);
gf_log(this->name, GF_LOG_ERROR, "%s: no \"../\" allowed in path",               path_in_value);
gf_log(this->name, GF_LOG_ERROR,               "failed to open %s "               "for writing",               filename);
gf_log(this->name, GF_LOG_ERROR,                   "could not create stats-dump directory %s", _IOS_DUMP_DIR);
gf_log(this->name, GF_LOG_ERROR,                   "could not create stats-sample directory %s", _IOS_SAMP_DIR);
gf_log(this->name, GF_LOG_ERROR,               "Invalid path for stats dump (%s) and/or latency "               "samples (%s)",               stats_filename, samples_filename);
gf_log(this->name, GF_LOG_ERROR,                   "could not open stats-dump file %s (%s)", stats_filename,                   strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                   "could not open samples-dump file %s (%s)", samples_filename,                   strerror(errno));
gf_log(this ? this->name : "io-stats", GF_LOG_ERROR,                   "Failed to start thread"                   "while reconfigure. Returning %d",                   ret);
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting init"               " failed");
gf_log(this->name, GF_LOG_ERROR,               "io_stats translator requires at least one subvolume");
gf_log(this ? this->name : "io-stats", GF_LOG_ERROR,                   "Failed to start thread"                   "in init. Returning %d",                   ret);
gf_log(this->name, GF_LOG_ERROR,                           "Failed to set top-op in dict");
gf_log(this->name, GF_LOG_ERROR,                           "Failed to reset top stats");
gf_log(this->name, GF_LOG_ERROR,                           "Failed to set stats-cleared"                           " in dict");
gf_log(this->name, GF_LOG_ERROR,                           "Failed to set info-op in dict");
gf_log(this->name, GF_LOG_ERROR,                               "Failed to set stats-cleared"                               " in dict");
gf_log(this->name, GF_LOG_ERROR,               "Memory accounting init"               " failed");
gf_log(this->name, GF_LOG_ERROR,               "must specify only one of 'include-ops' and "               "'exclude-ops'");
gf_log(this->name, GF_LOG_ERROR,               "trace translator requires one subvolume");
gf_log(this->name, GF_LOG_ERROR,               "cannot allocate "               "xl->private");
gf_log(this->name, GF_LOG_ERROR,               "must specify only one of 'include-ops' and "               "'exclude-ops'");
gf_log(this->name, GF_LOG_ERROR,               "event history cannot be "               "initialized");
gf_log("rot13", GF_LOG_ERROR,               "FATAL: rot13 should have exactly one child");
gf_log(this->name, GF_LOG_ERROR,                   "encrypt-write takes only boolean options");
gf_log(this->name, GF_LOG_ERROR,                   "decrypt-read takes only boolean options");
gf_log("auth/login", GF_LOG_ERROR,               "asprintf failed while setting search string, "               "returning REJECT");
gf_log("auth/login", GF_LOG_ERROR,                           "wrong username/password combination");
gf_log("auth/login", GF_LOG_ERROR,                           "wrong password for user %s", username);
gf_log("auth/addr", GF_LOG_ERROR,               "asprintf failed while setting search string");
gf_log("auth/addr", GF_LOG_ERROR,                   "asprintf failed while setting search string");
gf_log("auth/addr", GF_LOG_ERROR,                       "client is bound to port %d which is not privileged",                       peer_port);
gf_log("authenticate/addr", GF_LOG_ERROR,                   "unknown address family %d",                   ((struct sockaddr *)&peer_info->sockaddr)->sa_family);
gf_log(xl->name, GF_LOG_ERROR, "first lookup on subdir (%s) failed: %s",               basename, strerror(errno));
gf_log(xl->name, GF_LOG_ERROR, "lookup on root failed: %s",               strerror(errno));
gf_log(this->name, GF_LOG_ERROR,                       "first lookup on subdir (%s) failed: %s",                       client->subdir_mount, strerror(errno));
gf_log(this->name, GF_LOG_ERROR,               "graph janitor Thread"               " creation is failed for brick %s",               victim_name);
gf_log(this->name, GF_LOG_ERROR,               "victim brick %s is not"               " found in graph",               victim_name);
gf_log(THIS->name, GF_LOG_ERROR,                   "failed to set"                   "flag");
gf_log(THIS->name, GF_LOG_ERROR,                   "failed to set "                   "volume");
gf_log("cli", GF_LOG_ERROR,                   "Failed to set force "                   "option");
gf_log(THIS->name, GF_LOG_ERROR,               "memory allocation failed for"               "bricklist");
gf_log("cli", GF_LOG_ERROR,                   "Failed to set force "                   "option");
gf_log("cli", GF_LOG_ERROR,               "Failed to fetch default "               "soft-limit");
gf_log(THIS->name, GF_LOG_ERROR,               "failed to move offset to "               "the beginning: %s",               strerror(errno));
gf_log("cli", GF_LOG_ERROR,                   "Failed to get quota "                   "limits for %s",                   uuid_utoa((unsigned char *)buf));
gf_log("cli", GF_LOG_ERROR,                   "Error in printing "                   "xml output");
gf_log("cli", GF_LOG_ERROR,                   "Error outputting in "                   "xml format");
gf_log("cli", GF_LOG_ERROR,               "Could not fetch and display quota"               " limits");
gf_log("cli", GF_LOG_ERROR,                   "Failed to set ignore-"                   "partition option");
gf_log("cli", GF_LOG_ERROR,                   "Error parsing "                   "statedump options");
gf_log("cli", GF_LOG_ERROR,               "Error parsing "               "clear-locks options");
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(frame->this->name, GF_LOG_ERROR,               "Unable to get volname from dict");
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,                   "failed to check that debug xlator was added");
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,                       "Out of memory");
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,                   "failed to check that user xlator was added");
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,                       "Out of memory");
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log("cli", GF_LOG_ERROR,               "failed to check that server graph has been changed");
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log("cli", GF_LOG_ERROR,               "Failed to print remove-brick rebalance status");
gf_log("cli", GF_LOG_ERROR,                       "remove-brick-id is not present in dict");
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log("cli", GF_LOG_ERROR,                   "Failed to output in xml format for quota list command");
gf_log("cli", GF_LOG_ERROR,                   "Failed to output in xml format for quota list command");
gf_log("cli", GF_LOG_ERROR,                       "could not convert default soft limit to percent");
gf_log("cli", GF_LOG_ERROR,               "Failed to get the xattr %s on %s. Reason : %s", key, mountdir,               strerror(errno));
gf_log("cli", GF_LOG_ERROR, "Failed to get quota size on path %s: %s",               mountdir, strerror(errno));
gf_log("cli", GF_LOG_ERROR, "umount on %s failed, reason : %s",               mountdir, strerror(errno));
gf_log(frame->this->name, GF_LOG_ERROR,               "failed to get default soft limit");
gf_log("cli", GF_LOG_ERROR,               "Failed to set quota-list-success-count in dict");
gf_log("cli", GF_LOG_ERROR, "pthread_create failed: %s",                   strerror(errno));
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               "getspec failed");
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               "pump_b2p failed");
gf_log(THIS->name, GF_LOG_ERROR,               "Failed to set min-op-version in request dict");
gf_log(THIS->name, GF_LOG_ERROR,               "Failed to set max-op-version in request dict");
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log("", GF_LOG_ERROR, "Failed to open %s Error : %s",               common_pem_file, strerror(errno));
gf_log("", GF_LOG_ERROR, "Failed to write to %s",                       common_pem_file);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               "failed to get type");
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log("cli", GF_LOG_ERROR,                   "Unable to get lock summary from dictionary");
gf_log("cli", GF_LOG_ERROR,                   "Failed to create xml output for delete");
gf_log("cli", GF_LOG_ERROR,                   "Failed to create xml output for snapshot delete command");
gf_log("cli", GF_LOG_ERROR,                       "Could not fetch snap_max_hard_limit for %s", volname);
gf_log("cli", GF_LOG_ERROR,                       "Could not fetch snap-max-soft-limit for %s", volname);
gf_log("cli", GF_LOG_ERROR,                           "Could not fetch"                           " effective snap_max_hard_limit for %s",                           volname);
gf_log("cli", GF_LOG_ERROR,                   "Could not list details of volume in a snap");
gf_log("cli", GF_LOG_ERROR, "Unable to fetch snap-time %s ",               prefix_str);
gf_log("cli", GF_LOG_ERROR,                   "Could not get volume related information");
gf_log("cli", GF_LOG_ERROR,               "Could not save command type in snap dictionary");
gf_log("cli", GF_LOG_ERROR,                       "Failed to set op_errstr in local dictionary");
gf_log("cli", GF_LOG_ERROR,                   "Failed to create xml output for snapshot status");
gf_log("cli", GF_LOG_ERROR,                       "At least one option from "                       "snap-max-hard-limit, snap-max-soft-limit, "                       "auto-delete and snap-activate-on-create "                       "should be set");
gf_log("cli", GF_LOG_ERROR,                       "Failed to display snapshot config output.");
gf_log("cli", GF_LOG_ERROR,                       "Failed to display snapshot status output.");
gf_log("cli", GF_LOG_ERROR,                   "Failed to write xml element \"snapCount\"");
gf_log("cli", GF_LOG_ERROR,                   "Failed to fetch volname from local dictionary");
gf_log("cli", GF_LOG_ERROR,                   "Could not populate snap request dictionary");
gf_log("cli", GF_LOG_ERROR,                   "cli_to_glusterd for snapshot delete failed");
gf_log("cli", GF_LOG_ERROR,                   "Could not populate snap request dictionary");
gf_log("cli", GF_LOG_ERROR,                   "cli_to_glusterd for snapshot status failed");
gf_log("cli", GF_LOG_ERROR,                   "Failed to begin snapshot xml composite op");
gf_log("cli", GF_LOG_ERROR,                   "cli to glusterd for snapshot status command failed");
gf_log("cli", GF_LOG_ERROR,                   "cli to glusterd for snapshot delete command failed");
gf_log("cli", GF_LOG_ERROR,                   "Failed to end snapshot xml composite op");
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log("cli", GF_LOG_ERROR,               "Failed to retrieve count from the dictionary");
gf_log("cli", GF_LOG_ERROR,                   "Failed to retrieve %s from the dictionary", dict_key);
gf_log("cli", GF_LOG_ERROR,                   "Failed to retrieve key value for %s from the dictionary",                   dict_key);
gf_log("cli", GF_LOG_ERROR,               "failed to get count value from dictionary");
gf_log(((call_frame_t *)myframe)->this->name, GF_LOG_ERROR,               XDR_DECODE_FAIL);
gf_log("cli", GF_LOG_ERROR,                   "Failed to create "                   "xml output for snapshot's origin volume");
gf_log("cli", GF_LOG_ERROR,                   "Could not list "                   "details of volume in a snap");
gf_log("cli", GF_LOG_ERROR,                   "Failed to create "                   "xml output for snapshot's origin volume");
gf_log("cli", GF_LOG_ERROR,                   "failed to create xml "                   "output for snapshot status");
gf_log("cli", GF_LOG_ERROR,               "Failed to get "               "snap-max-hard-limit");
gf_log("cli", GF_LOG_ERROR,               "Failed to get "               "snap-max-soft-limit");
gf_log("cli", GF_LOG_ERROR,               "Could not fetch snap-activate-on-create-delete");
gf_log("cli", GF_LOG_ERROR,                   "Could not fetch"                   " effective snap_max_hard_limit for "                   "%s",                   str_value);
gf_log("cli", GF_LOG_ERROR,               "At least one option from "               "snap-max-hard-limit, snap-max-soft-limit, auto-delete"               " and snap-activate-on-create should be set");
gf_log("cli", GF_LOG_ERROR,                       "Failed to create xml "                       "output for snapshot config set command");
gf_log("cli", GF_LOG_ERROR,                       "Failed to create xml "                       "output for snapshot config show command");
gf_log("cli", GF_LOG_ERROR, "Unknown config command :%d",                   config_command);
gf_log("cli", GF_LOG_ERROR,               "Failed to output "               "xml begin block");
gf_log("cli", GF_LOG_ERROR,               "Failed to output "               "xml common block");
gf_log("cli", GF_LOG_ERROR,                       "Failed to create "                       "xml output for snapshot create command");
gf_log("cli", GF_LOG_ERROR,                       "Failed to create "                       "xml output for snapshot clone command");
gf_log("cli", GF_LOG_ERROR,                       "Failed to create "                       "xml output for snapshot restore command");
gf_log("cli", GF_LOG_ERROR,                       "Failed to create "                       "xml output for snapshot list command");
gf_log("cli", GF_LOG_ERROR,                       "Failed to create"                       "xml output for snapshot status command");
gf_log("cli", GF_LOG_ERROR,                       "Failed to create "                       "xml output for snapshot info command");
gf_log("cli", GF_LOG_ERROR,                       "Failed to create "                       "xml output for snapshot config command");
gf_log("cli", GF_LOG_ERROR,                       "Failed to create "                       "xml output for snapshot config command");
gf_log("cli", GF_LOG_ERROR, "Unexpected snapshot command: %d",                   cmd_type);
gf_log("cli", GF_LOG_ERROR,               "Failed to output "               "xml end block");
gf_log("cli", GF_LOG_ERROR,               "Failed to get "               "sub-cmd");
gf_log("cli", GF_LOG_ERROR,               "Failed to get snapshot "               "command type from dictionary");
gf_log("cli", GF_LOG_ERROR,               "Failed to get "               "sub-cmd");
gf_log("cli", GF_LOG_ERROR,               "Failed to get snapshot "               "command type from dictionary");
gf_log("cli", GF_LOG_ERROR,               "Error creating xml "               "output");
gf_log("cli", GF_LOG_ERROR,               "Failed to retrieve count "               "from the dictionary");
gf_log("cli", GF_LOG_ERROR,               "Value of count :%d is "               "invalid",               count);
gf_log("cli", GF_LOG_ERROR,                   "Failed to"                   " retrieve %s from the "                   "dictionary",                   dict_key);
gf_log("cli", GF_LOG_ERROR,                   "Failed to "                   "retrieve key value for %s from"                   "the dictionary",                   dict_key);
gf_log("cli", GF_LOG_ERROR,               "Unable to retrieve "               "hostname");
gf_log("cli", GF_LOG_ERROR,                   "Unable to allocate "                   "memory");
gf_log("cli", GF_LOG_ERROR,                               "Volume create "                               "cancelled, exiting");
gf_log("", GF_LOG_ERROR,                       "incorrect transport"                       " protocol specified");
gf_log(THIS->name, GF_LOG_ERROR,                   "Setting daemon name to dictionary failed");
gf_log(THIS->name, GF_LOG_ERROR,                       "Setting output directory to"                       "dictionary failed");
gf_log(THIS->name, GF_LOG_ERROR,                       "Setting filename to dictionary failed");
gf_log(THIS->name, GF_LOG_ERROR,                       "Setting "                       "get-state command type to dictionary "                       "failed");
gf_log("cli", GF_LOG_ERROR,                       "Failed to set "                       "quota patch in request dictionary");
gf_log("cli", GF_LOG_ERROR,                   "Failed to set quota "                   "limit count in request dictionary");
gf_log("cli", GF_LOG_ERROR,                       "Operation "                       "cancelled, exiting");
gf_log("cli", GF_LOG_ERROR,                       "Operation "                       "cancelled, exiting");
gf_log("cli", GF_LOG_ERROR,                           "Add brick"                           " cancelled, exiting");
gf_log("cli", GF_LOG_ERROR,                           "Remove "                           "brick cancelled, exiting");
gf_log("", GF_LOG_ERROR,               "cli_cmd_volume_remove_brick_parse: "               "Unable to get memory");
gf_log("", GF_LOG_ERROR,               "cli_cmd_volume_remove_brick_parse: "               "Unable to get memory");
gf_log("", GF_LOG_ERROR,                       "Duplicate bricks"                       " found %s",                       words[brick_index]);
gf_log("cli", GF_LOG_ERROR,               "Unable to allocate "               "memory");
gf_log("cli", GF_LOG_ERROR,               "Unable to save snap "               "description");
gf_log("cli", GF_LOG_ERROR,               "Invalid number of  words for snap clone command");
gf_log("cli", GF_LOG_ERROR,               "Could not save clone "               "name(%s)",               (char *)words[cmdi]);
gf_log("cli", GF_LOG_ERROR,               "Could not "               "save snap name(%s)",               (char *)words[cmdi + 1]);
gf_log("cli", GF_LOG_ERROR,               "Could not save snap "               "name(%s)",               (char *)words[cmdi]);
gf_log("cli", GF_LOG_ERROR,                   "Could not "                   "save volume name(%s)",                   (char *)words[i]);
gf_log("cli", GF_LOG_ERROR,                   "Could not save "                   "time-stamp option");
gf_log("cli", GF_LOG_ERROR,                   "Could not save snap "                   "description");
gf_log("cli", GF_LOG_ERROR,                   "Could not save "                   "snap force option");
gf_log("cli", GF_LOG_ERROR,                   "Unable to save "                   "snapname %s",                   words[cmdi]);
gf_log("cli", GF_LOG_ERROR,               "Could not save "               "volume name %s",               words[wordcount - 1]);
gf_log("cli", GF_LOG_ERROR,                   "Could not save "                   "type of snapshot info");
gf_log("cli", GF_LOG_ERROR,               "User cancelled a snapshot "               "restore operation for snap %s",               (char *)words[2]);
gf_log("cli", GF_LOG_ERROR,                   "Could not save "                   "volume name %s",                   words[wordcount - 1]);
gf_log("cli", GF_LOG_ERROR,                   "Unable to save "                   "snapname %s",                   words[2]);
gf_log("cli", GF_LOG_ERROR,               "Could not save "               "type of snapshot delete");
gf_log("cli", GF_LOG_ERROR,                   "Count not save "                   "snap name %s",                   words[cmdi]);
gf_log("cli", GF_LOG_ERROR,               "Count not save "               "volume name %s",               words[wordcount - 1]);
gf_log("cli", GF_LOG_ERROR,                   "Could not save cmd "                   "of snapshot status");
gf_log("cli", GF_LOG_ERROR,               "Could not set "               "%s in dictionary",               key);
gf_log("cli", GF_LOG_ERROR,                   "Failed to parse snap "                   "config hard limit");
gf_log("cli", GF_LOG_ERROR,                   "Soft limit cannot be "                   "set to volumes");
gf_log("cli", GF_LOG_ERROR,                   "Failed to parse snap "                   "config soft limit");
gf_log("cli", GF_LOG_ERROR,                   "auto-delete option "                   "cannot be set to volumes");
gf_log("cli", GF_LOG_ERROR,                   "Failed to set "                   "value of auto-delete in request "                   "dictionary");
gf_log("cli", GF_LOG_ERROR,                   "activate-on-create "                   "option cannot be set to volumes");
gf_log("cli", GF_LOG_ERROR,                   "Failed to set value "                   "of activate-on-create in request dictionary");
gf_log("cli", GF_LOG_ERROR,               "Unable to set "               "config-command");
gf_log("cli", GF_LOG_ERROR,                   "Unable to set hold-snap-locks value "                   "as _gf_true");
gf_log("cli", GF_LOG_ERROR,                   "Setting volume lock "                   "flag failed");
gf_log("cli", GF_LOG_ERROR,                       "Failed to parse "                       "snapshot info command");
gf_log("cli", GF_LOG_ERROR,                       "Failed to parse "                       "snapshot list command");
gf_log("cli", GF_LOG_ERROR,                           "Failed to parse "                           "snapshot delete command");
gf_log("cli", GF_LOG_ERROR,                           "config command parsing failed.");
gf_log("cli", GF_LOG_ERROR,                       "Unable to set "                       "config type");
gf_log("cli", GF_LOG_ERROR,                       "Failed to parse "                       "snapshot status command");
gf_log("cli", GF_LOG_ERROR,                       "Failed to parse "                       "restore command");
gf_log("cli", GF_LOG_ERROR,                       "Failed to parse "                       "start command");
gf_log("cli", GF_LOG_ERROR,                           "Failed to parse deactivate "                           "command");
gf_log("cli", GF_LOG_ERROR,               "Global operation "               "cancelled, exiting");
gf_log(THIS->name, GF_LOG_ERROR,               "dict set on global"               " key failed.");
gf_log(THIS->name, GF_LOG_ERROR,               "dict set on global key "               "failed.");
gf_log("", GF_LOG_ERROR,                       "Unable to set "                       "%s in dict",                       cmd_arg_name);
gf_log(THIS->name, GF_LOG_ERROR, "Unable to stat %s (%s)", path,               strerror(errno));
gf_log(THIS->name, GF_LOG_ERROR,               "read failed on path %s. File size=%" GF_PRI_SIZET               "read size=%d",               path, file_len, ret);
gf_log(THIS->name, GF_LOG_ERROR,               "failed to get volfile "               "checksum for volfile id %s.",               volfile_id);
